//! –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ Phase 2 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤

use timeline_studio_lib::core::{
  performance::{DataType, RuntimeConfig},
  telemetry::{LogLevel, TelemetryConfigBuilder},

  AppEvent,

  CacheManager,
  // Event System
  EventBus,
  EventHandler,
  MemoryManager,
  // Plugin System
  PluginManager,

  // Performance
  RuntimeManager,
  Service,
  // DI and Services
  ServiceContainer,

  // Telemetry & Observability
  TelemetryManager,
  ZeroCopyManager,
};

use async_trait::async_trait;
use std::sync::Arc;
use timeline_studio_lib::video_compiler::error::VideoCompilerError;
use tokio::time::{sleep, Duration};

/// –ü—Ä–∏–º–µ—Ä –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞ –≤–∏–¥–µ–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏
struct VideoProcessingService {
  runtime_manager: Arc<RuntimeManager>,
  memory_manager: Arc<MemoryManager>,
  _cache_manager: Arc<CacheManager>,
  zerocopy_manager: Arc<ZeroCopyManager>,
  event_bus: Arc<EventBus>,
  plugin_manager: Arc<PluginManager>,
}

#[async_trait]
impl Service for VideoProcessingService {
  fn name(&self) -> &'static str {
    "video_processing"
  }

  async fn initialize(&mut self) -> timeline_studio_lib::video_compiler::error::Result<()> {
    log::info!("Initializing VideoProcessingService");

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º runtime pools
    self.runtime_manager.initialize().await?;

    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –æ—á–∏—Å—Ç–∫—É memory manager
    self.memory_manager.start_background_cleanup().await;

    log::info!("VideoProcessingService initialized successfully");
    Ok(())
  }
}

impl VideoProcessingService {
  fn new(
    runtime_manager: Arc<RuntimeManager>,
    memory_manager: Arc<MemoryManager>,
    cache_manager: Arc<CacheManager>,
    zerocopy_manager: Arc<ZeroCopyManager>,
    event_bus: Arc<EventBus>,
    plugin_manager: Arc<PluginManager>,
  ) -> Self {
    Self {
      runtime_manager,
      memory_manager,
      _cache_manager: cache_manager,
      zerocopy_manager,
      event_bus,
      plugin_manager,
    }
  }

  /// –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∏–¥–µ–æ —Ñ–∞–π–ª —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤—Å–µ—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
  async fn process_video(
    &self,
    file_path: &str,
  ) -> timeline_studio_lib::video_compiler::error::Result<String> {
    log::info!("Starting video processing for: {file_path}");

    // –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –Ω–∞—á–∞–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    self
      .event_bus
      .publish_app_event(AppEvent::MediaImported {
        media_id: uuid::Uuid::new_v4().to_string(),
        path: file_path.to_string(),
      })
      .await?;

    // –í—ã–ø–æ–ª–Ω—è–µ–º CPU-intensive –∑–∞–¥–∞—á—É —á–µ—Ä–µ–∑ RuntimeManager
    let decode_result = self
      .runtime_manager
      .execute_cpu_intensive(async {
        log::info!("Decoding video...");
        sleep(Duration::from_millis(100)).await; // –°–∏–º—É–ª—è—Ü–∏—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
        Ok::<String, timeline_studio_lib::video_compiler::error::VideoCompilerError>(
          "decoded_frames".to_string(),
        )
      })
      .await?;

    log::info!("Video decoded in {:?}", decode_result.duration);

    // –í—ã–¥–µ–ª—è–µ–º zero-copy –±—É—Ñ–µ—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–¥—Ä–æ–≤
    let yuv_frame = self
      .zerocopy_manager
      .get_frame_buffer(1920, 1080, DataType::Yuv420p)
      .await?;
    log::info!("Allocated YUV frame buffer: {} bytes", yuv_frame.size());

    // –°–æ–∑–¥–∞–µ–º RGB –±—É—Ñ–µ—Ä –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ view
    let rgb_frame = self
      .zerocopy_manager
      .get_frame_buffer(1920, 1080, DataType::Rgb24)
      .await?;
    let frame_view = self
      .zerocopy_manager
      .create_view(&rgb_frame, 0, rgb_frame.size())
      .await?;
    log::info!("Created zero-copy frame view: {} bytes", frame_view.size());

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã —á–µ—Ä–µ–∑ –ø–ª–∞–≥–∏–Ω—ã
    let plugins = self.plugin_manager.list_loaded_plugins().await;
    for (plugin_id, state) in plugins {
      if state == timeline_studio_lib::core::plugins::plugin::PluginState::Active {
        log::info!("Applying effects from plugin: {plugin_id}");
        // –ó–¥–µ—Å—å –±—ã –≤—ã–∑—ã–≤–∞–ª–∏ –ø–ª–∞–≥–∏–Ω –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–¥—Ä–∞
      }
    }

    // –í—ã–ø–æ–ª–Ω—è–µ–º IO-bound –∑–∞–¥–∞—á—É –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    let save_result = self
      .runtime_manager
      .execute_io_bound(async {
        log::info!("Saving processed video...");
        sleep(Duration::from_millis(50)).await; // –°–∏–º—É–ª—è—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        Ok::<String, timeline_studio_lib::video_compiler::error::VideoCompilerError>(
          "/output/processed_video.mp4".to_string(),
        )
      })
      .await?;

    log::info!("Video saved in {:?}", save_result.duration);
    let output_path = save_result.result?;

    // –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    self
      .event_bus
      .publish_app_event(AppEvent::MediaProcessed {
        media_id: uuid::Uuid::new_v4().to_string(),
      })
      .await?;

    log::info!("Video processing completed: {output_path}");
    Ok(output_path)
  }
}

/// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π –º–µ–¥–∏–∞
struct MediaEventHandler {
  _cache_manager: Arc<CacheManager>,
}

#[async_trait]
impl EventHandler for MediaEventHandler {
  type Event = AppEvent;

  async fn handle(
    &self,
    event: AppEvent,
  ) -> timeline_studio_lib::video_compiler::error::Result<()> {
    match event {
      AppEvent::MediaImported { media_id, path } => {
        log::info!("Media imported: {media_id} -> {path}");

        // –ö—ç—à–∏—Ä—É–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –º–µ–¥–∏–∞ —Ñ–∞–π–ª–∞
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∑–¥–µ—Å—å –±—ã –±—ã–ª —Ä–µ–∞–ª—å–Ω—ã–π –∫—ç—à —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏

        Ok(())
      }
      AppEvent::MediaProcessed { media_id } => {
        log::info!("Media processing completed: {media_id}");
        Ok(())
      }
      _ => Ok(()),
    }
  }

  fn name(&self) -> &'static str {
    "media_event_handler"
  }
}

#[tokio::main]
async fn main() -> Result<(), VideoCompilerError> {
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
  env_logger::init();

  println!("üöÄ Phase 2 Integration Demo - Timeline Studio Backend");
  println!("=====================================\n");

  // 1. –°–æ–∑–¥–∞–µ–º DI Container
  println!("üì¶ Creating DI Container...");
  let service_container = ServiceContainer::new();

  // 2. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Telemetry
  println!("üìä Setting up Telemetry...");
  let telemetry_config = TelemetryConfigBuilder::new()
    .service_name("timeline-studio-phase2-demo")
    .environment("integration-test")
    .log_level(LogLevel::Info)
    .build();

  let telemetry_manager = TelemetryManager::new(telemetry_config)
    .await
    .map_err(|e| VideoCompilerError::InternalError(e.to_string()))?;
  let tracer = telemetry_manager.tracer();
  let metrics_collector = telemetry_manager.metrics();
  let health_manager = telemetry_manager.health();

  // 3. –°–æ–∑–¥–∞–µ–º Event Bus
  println!("üîÑ Creating Event Bus...");
  let event_bus = Arc::new(EventBus::new());

  // 4. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Performance –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
  println!("‚ö° Setting up Performance components...");
  let runtime_config = RuntimeConfig::default();
  let runtime_manager = Arc::new(RuntimeManager::new(runtime_config));
  runtime_manager.initialize().await?;

  let memory_manager = Arc::new(MemoryManager::new());
  let cache_manager = Arc::new(CacheManager::new());
  let zerocopy_manager = Arc::new(ZeroCopyManager::new());

  // 5. –°–æ–∑–¥–∞–µ–º Plugin Manager
  println!("üîå Creating Plugin Manager...");
  let plugin_manager = Arc::new(
    PluginManager::new(
      timeline_studio_lib::core::plugins::plugin::Version::new(1, 0, 0),
      event_bus.clone(),
      Arc::new(service_container),
    )
    .with_telemetry(tracer, metrics_collector.clone())?,
  );

  // 6. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Health Checks –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
  println!("üè• Setting up Health Checks...");
  telemetry_manager
    .setup_system_health_checks(Some(event_bus.clone()), Some(plugin_manager.clone()))
    .await?;

  // 7. –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å–µ—Ä–≤–∏—Å
  println!("üé¨ Creating Video Processing Service...");
  let mut video_service = VideoProcessingService::new(
    runtime_manager,
    memory_manager,
    cache_manager.clone(),
    zerocopy_manager.clone(),
    event_bus.clone(),
    plugin_manager,
  );

  video_service.initialize().await?;

  // 8. –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π
  println!("üì® Registering Event Handlers...");
  let media_handler = MediaEventHandler {
    _cache_manager: cache_manager,
  };
  event_bus
    .subscribe(media_handler)
    .await
    .map_err(|e| VideoCompilerError::InternalError(e.to_string()))?;

  // 9. –î–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç—É —Å–∏—Å—Ç–µ–º—ã
  println!("\nüéØ Running Integration Tests...\n");

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º health checks
  println!("üîç Running Health Checks...");
  let health_summary = health_manager.check_all().await;
  println!("Overall health status: {:?}", health_summary.status);
  println!("Health checks completed: {}", health_summary.checks.len());

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∏–¥–µ–æ —Ñ–∞–π–ª–æ–≤
  println!("\nüé¨ Processing video files...");
  for i in 1..=3 {
    let file_path = format!("/videos/sample_{i}.mp4");

    println!("\n--- Processing {file_path} ---");
    match video_service.process_video(&file_path).await {
      Ok(output) => println!("‚úÖ Successfully processed: {output}"),
      Err(e) => println!("‚ùå Processing failed: {e}"),
    }
  }

  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
  println!("\nüìà Performance Statistics:");

  let runtime_stats = video_service.runtime_manager.get_runtime_stats().await;
  println!("System Stats:");
  println!("  CPU cores: {}", runtime_stats.system_stats.cpu_count);
  println!(
    "  Memory usage: {:.1} MB / {:.1} MB",
    runtime_stats.system_stats.memory_usage as f64 / 1024.0 / 1024.0,
    runtime_stats.system_stats.total_memory as f64 / 1024.0 / 1024.0
  );

  for (pool_name, stats) in runtime_stats.pool_stats {
    println!(
      "Worker Pool '{}': {} total, {} completed, {} active",
      pool_name, stats.total_tasks, stats.completed_tasks, stats.active_tasks
    );
  }

  let (memory_stats, pool_stats) = video_service.memory_manager.get_full_stats().await;
  println!("Memory Stats:");
  println!(
    "  Allocations: {}, Efficiency: {:.1}%",
    memory_stats.allocations,
    pool_stats.recycling_efficiency() * 100.0
  );

  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º telemetry —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  println!("Metrics collected successfully");

  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º zero-copy —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  let zerocopy_stats = zerocopy_manager.get_stats().await;
  println!("Zero-Copy Stats:");
  println!(
    "  Operations: {}, Bytes saved: {:.2} MB",
    zerocopy_stats.zero_copy_operations,
    zerocopy_stats.bytes_saved as f64 / 1024.0 / 1024.0
  );

  // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É
  println!("\nüõë Shutting down gracefully...");
  telemetry_manager
    .shutdown()
    .await
    .map_err(|e| VideoCompilerError::InternalError(e.to_string()))?;

  println!("\n‚ú® Phase 2 Integration Demo completed successfully!");
  println!("\nüìã Demonstrated features:");
  println!("  ‚úÖ Dependency Injection Container");
  println!("  ‚úÖ Event-Driven Architecture");
  println!("  ‚úÖ Plugin System integration");
  println!("  ‚úÖ OpenTelemetry observability");
  println!("  ‚úÖ Health checks system");
  println!("  ‚úÖ Performance optimization");
  println!("  ‚úÖ Memory management");
  println!("  ‚úÖ Caching system");
  println!("  ‚úÖ Async runtime tuning");
  println!("  ‚úÖ Zero-copy operations");
  println!("\nüéâ Phase 2 refactoring architecture is ready for production!");

  Ok(())
}
