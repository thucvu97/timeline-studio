// Auto-generated test data from real media files
// Generated by scripts/analyze-test-media.js

#[cfg(test)]
#[allow(clippy::module_inception)]
pub mod test_data {
  use std::path::PathBuf;
  use std::sync::OnceLock;

  #[derive(Debug, Clone)]
  #[allow(dead_code)]
  pub struct TestMediaFile {
    pub filename: &'static str,
    pub path: PathBuf,
    pub format_name: &'static str,
    pub duration: f64,
    pub size: u64,
    pub bit_rate: u64,

    // Video properties
    pub has_video: bool,
    pub video_codec: Option<&'static str>,
    pub width: Option<u32>,
    pub height: Option<u32>,
    pub fps: Option<&'static str>,
    pub video_bit_rate: u64,

    // Audio properties
    pub has_audio: bool,
    pub audio_codec: Option<&'static str>,
    pub sample_rate: u32,
    pub channels: Option<u32>,
    pub audio_bit_rate: u64,

    // Special properties
    pub is_360: bool,
    pub has_cyrillic: bool,
  }

  impl TestMediaFile {
    pub fn get_path(&self) -> PathBuf {
      let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("test-data")
        .join(self.filename);

      // In CI, return a dummy path if test-data doesn't exist
      if (std::env::var("CI").is_ok() || std::env::var("GITHUB_ACTIONS").is_ok()) && !path.exists()
      {
        PathBuf::from("/tmp/dummy_test_file")
      } else {
        path
      }
    }
  }

  // Using Box::leak to prevent static destructor issues
  static TEST_FILES: OnceLock<&'static Vec<TestMediaFile>> = OnceLock::new();

  pub fn test_data_available() -> bool {
    let test_data_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
      .parent()
      .unwrap()
      .join("test-data");

    test_data_dir.exists() && test_data_dir.is_dir()
  }

  pub fn get_test_files() -> &'static Vec<TestMediaFile> {
    TEST_FILES.get_or_init(|| {
      Box::leak(Box::new(vec![
        TestMediaFile {
          filename: "C0666.MP4",
          path: PathBuf::new(),
          format_name: "mov,mp4,m4a,3gp,3g2,mj2",
          duration: 8.2,
          size: 268715286,
          bit_rate: 263446358,

          has_video: true,
          video_codec: Some("hevc"),
          width: Some(3840),
          height: Some(2160),
          fps: Some("50/1"),
          video_bit_rate: 202226438,

          has_audio: true,
          audio_codec: Some("pcm_s16be"),
          sample_rate: 48000,
          channels: Some(2),
          audio_bit_rate: 1536000,

          is_360: false,
          has_cyrillic: false,
        },
        TestMediaFile {
          filename: "C0783.MP4",
          path: PathBuf::new(),
          format_name: "mov,mp4,m4a,3gp,3g2,mj2",
          duration: 5.8,
          size: 201604898,
          bit_rate: 280006802,

          has_video: true,
          video_codec: Some("hevc"),
          width: Some(3840),
          height: Some(2160),
          fps: Some("50/1"),
          video_bit_rate: 201424745,

          has_audio: true,
          audio_codec: Some("pcm_s16be"),
          sample_rate: 48000,
          channels: Some(2),
          audio_bit_rate: 1536000,

          is_360: false,
          has_cyrillic: false,
        },
        TestMediaFile {
          filename: "DJI_02_20250402_104352.WAV",
          path: PathBuf::new(),
          format_name: "wav",
          duration: 1864.2,
          size: 268448300,
          bit_rate: 1152000,

          has_video: false,
          video_codec: None,
          width: None,
          height: None,
          fps: None,
          video_bit_rate: 0,

          has_audio: true,
          audio_codec: Some("pcm_s24le"),
          sample_rate: 48000,
          channels: Some(1),
          audio_bit_rate: 1152000,

          is_360: false,
          has_cyrillic: false,
        },
        TestMediaFile {
          filename: "DSC07845.png",
          path: PathBuf::new(),
          format_name: "png_pipe",
          duration: 0.0,
          size: 6020511,
          bit_rate: 0,

          has_video: true,
          video_codec: Some("png"),
          width: Some(4240),
          height: Some(2832),
          fps: Some("25/1"),
          video_bit_rate: 0,

          has_audio: false,
          audio_codec: None,
          sample_rate: 0,
          channels: None,
          audio_bit_rate: 0,

          is_360: false,
          has_cyrillic: false,
        },
        TestMediaFile {
          filename: "Kate.mp4",
          path: PathBuf::new(),
          format_name: "mov,mp4,m4a,3gp,3g2,mj2",
          duration: 7.7,
          size: 74604623,
          bit_rate: 77723269,

          has_video: true,
          video_codec: Some("h264"),
          width: Some(3840),
          height: Some(2160),
          fps: Some("50/1"),
          video_bit_rate: 75547964,

          has_audio: true,
          audio_codec: Some("aac"),
          sample_rate: 44100,
          channels: Some(2),
          audio_bit_rate: 191999,

          is_360: false,
          has_cyrillic: false,
        },
        TestMediaFile {
          filename: "water play3.mp4",
          path: PathBuf::new(),
          format_name: "mov,mp4,m4a,3gp,3g2,mj2",
          duration: 3.4,
          size: 48104293,
          bit_rate: 112549014,

          has_video: true,
          video_codec: Some("hevc"),
          width: Some(3840),
          height: Some(2160),
          fps: Some("50/1"),
          video_bit_rate: 100985640,

          has_audio: false,
          audio_codec: None,
          sample_rate: 0,
          channels: None,
          audio_bit_rate: 0,

          is_360: false,
          has_cyrillic: false,
        },
        TestMediaFile {
          filename: "проводка после лобби.mp4",
          path: PathBuf::new(),
          format_name: "mov,mp4,m4a,3gp,3g2,mj2",
          duration: 19.9,
          size: 255990182,
          bit_rate: 102984008,

          has_video: true,
          video_codec: Some("hevc"),
          width: Some(3840),
          height: Some(2160),
          fps: Some("50/1"),
          video_bit_rate: 100000226,

          has_audio: false,
          audio_codec: None,
          sample_rate: 0,
          channels: None,
          audio_bit_rate: 0,

          is_360: false,
          has_cyrillic: true,
        },
      ]))
    })
  }

  static VIDEO_FILES: OnceLock<&'static Vec<&'static TestMediaFile>> = OnceLock::new();
  static AUDIO_FILES: OnceLock<&'static Vec<&'static TestMediaFile>> = OnceLock::new();
  static IMAGE_FILES: OnceLock<&'static Vec<&'static TestMediaFile>> = OnceLock::new();

  pub fn get_video_files() -> &'static Vec<&'static TestMediaFile> {
    VIDEO_FILES.get_or_init(|| {
      Box::leak(Box::new(
        get_test_files().iter().filter(|f| f.has_video).collect(),
      ))
    })
  }

  pub fn get_audio_files() -> &'static Vec<&'static TestMediaFile> {
    AUDIO_FILES.get_or_init(|| {
      Box::leak(Box::new({
        get_test_files()
          .iter()
          .filter(|f| f.has_audio && !f.has_video)
          .collect()
      }))
    })
  }

  pub fn get_image_files() -> &'static Vec<&'static TestMediaFile> {
    IMAGE_FILES.get_or_init(|| {
      Box::leak(Box::new({
        get_test_files()
          .iter()
          .filter(|f| f.has_video && f.duration == 0.0)
          .collect()
      }))
    })
  }

  // Helper functions for tests
  pub fn get_test_video() -> &'static TestMediaFile {
    get_video_files()
      .first()
      .expect("No test video files available")
  }

  pub fn get_test_audio() -> &'static TestMediaFile {
    get_audio_files()
      .first()
      .expect("No test audio files available")
  }

  #[allow(dead_code)]
  pub fn get_test_image() -> &'static TestMediaFile {
    get_image_files()
      .first()
      .expect("No test image files available")
  }

  pub fn get_file_with_cyrillic() -> Option<&'static TestMediaFile> {
    get_test_files().iter().find(|f| f.has_cyrillic)
  }

  pub fn get_largest_file() -> &'static TestMediaFile {
    get_test_files().iter().max_by_key(|f| f.size).unwrap()
  }

  #[allow(dead_code)]
  pub fn get_longest_video() -> &'static TestMediaFile {
    get_video_files()
      .iter()
      .max_by(|a, b| a.duration.partial_cmp(&b.duration).unwrap())
      .unwrap()
  }
}

#[cfg(test)]
mod tests {
  use super::test_data::*;

  #[test]
  fn test_files_exist() {
    if !test_data_available() {
      eprintln!("Skipping test: test-data directory not found");
      return;
    }

    for file in get_test_files().iter() {
      let path = file.get_path();
      assert!(path.exists(), "Test file not found: {path:?}");
    }
  }

  #[test]
  fn test_video_properties() {
    let video = get_test_video();
    assert!(video.has_video);
    assert!(video.width.is_some());
    assert!(video.height.is_some());
    assert!(video.duration > 0.0);
  }

  #[test]
  fn test_audio_properties() {
    let audio = get_test_audio();
    assert!(audio.has_audio);
    assert!(!audio.has_video);
    assert!(audio.sample_rate > 0);
  }

  #[test]
  fn test_cyrillic_filename() {
    if let Some(file) = get_file_with_cyrillic() {
      assert!(file.has_cyrillic);
      // Test that we can handle cyrillic filenames
      let path = file.get_path();

      // In CI, we use a dummy path that doesn't contain the filename
      if std::env::var("CI").is_ok() || std::env::var("GITHUB_ACTIONS").is_ok() {
        // Just verify we have some path
        assert!(!path.as_os_str().is_empty());
      } else {
        assert!(path.to_string_lossy().contains(file.filename));
      }
    }
  }
}
