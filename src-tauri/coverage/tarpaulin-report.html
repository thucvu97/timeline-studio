<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","build.rs"],"content":"fn main() {\n  tauri_build::build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","filesystem.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::Path;\n\n/**\n * Структура для статистики файла\n */\n#[derive(Debug, Serialize, Deserialize)]\npub struct FileStats {\n  pub size: u64,\n  #[serde(rename = \"lastModified\")]\n  pub last_modified: u64,\n}\n\n/**\n * Проверяет существование файла\n */\n#[tauri::command]\npub fn file_exists(path: String) -\u003e Result\u003cbool, String\u003e {\n  let file_path = Path::new(\u0026path);\n  Ok(file_path.exists() \u0026\u0026 file_path.is_file())\n}\n\n/**\n * Получает статистику файла (размер и время модификации)\n */\n#[tauri::command]\npub fn get_file_stats(path: String) -\u003e Result\u003cFileStats, String\u003e {\n  let file_path = Path::new(\u0026path);\n\n  if !file_path.exists() {\n    return Err(format!(\"File does not exist: {}\", path));\n  }\n\n  match fs::metadata(file_path) {\n    Ok(metadata) =\u003e {\n      let size = metadata.len();\n\n      // Получаем время модификации в миллисекундах\n      let last_modified = metadata\n        .modified()\n        .map_err(|e| format!(\"Failed to get modification time: {}\", e))?\n        .duration_since(std::time::UNIX_EPOCH)\n        .map_err(|e| format!(\"Failed to convert time: {}\", e))?\n        .as_millis() as u64;\n\n      Ok(FileStats {\n        size,\n        last_modified,\n      })\n    }\n    Err(e) =\u003e Err(format!(\"Failed to get file metadata: {}\", e)),\n  }\n}\n\n/**\n * Получает платформу операционной системы\n */\n#[tauri::command]\npub fn get_platform() -\u003e Result\u003cString, String\u003e {\n  Ok(std::env::consts::OS.to_string())\n}\n\n/**\n * Рекурсивно ищет файлы в директории с заданным именем\n */\n#[tauri::command]\npub fn search_files_by_name(\n  directory: String,\n  filename: String,\n  max_depth: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n  let dir_path = Path::new(\u0026directory);\n\n  if !dir_path.exists() {\n    return Err(format!(\"Directory does not exist: {}\", directory));\n  }\n\n  let mut found_files = Vec::new();\n  let max_depth = max_depth.unwrap_or(5); // По умолчанию максимум 5 уровней\n\n  search_files_recursive(dir_path, \u0026filename, \u0026mut found_files, 0, max_depth)?;\n\n  Ok(found_files)\n}\n\n/**\n * Рекурсивная функция для поиска файлов\n */\nfn search_files_recursive(\n  dir: \u0026Path,\n  target_filename: \u0026str,\n  found_files: \u0026mut Vec\u003cString\u003e,\n  current_depth: u32,\n  max_depth: u32,\n) -\u003e Result\u003c(), String\u003e {\n  if current_depth \u003e= max_depth {\n    return Ok(());\n  }\n\n  match fs::read_dir(dir) {\n    Ok(entries) =\u003e {\n      for entry in entries {\n        match entry {\n          Ok(entry) =\u003e {\n            let entry_path = entry.path();\n\n            if entry_path.is_file() {\n              if let Some(filename) = entry_path.file_name() {\n                if filename == target_filename {\n                  if let Some(path_str) = entry_path.to_str() {\n                    found_files.push(path_str.to_string());\n                  }\n                }\n              }\n            } else if entry_path.is_dir() {\n              // Рекурсивно ищем в поддиректории\n              search_files_recursive(\n                \u0026entry_path,\n                target_filename,\n                found_files,\n                current_depth + 1,\n                max_depth,\n              )?;\n            }\n          }\n          Err(e) =\u003e {\n            eprintln!(\"Error reading directory entry: {}\", e);\n          }\n        }\n      }\n    }\n    Err(e) =\u003e return Err(format!(\"Failed to read directory: {}\", e)),\n  }\n\n  Ok(())\n}\n\n/**\n * Получает абсолютный путь к файлу\n */\n#[tauri::command]\npub fn get_absolute_path(path: String) -\u003e Result\u003cString, String\u003e {\n  let file_path = Path::new(\u0026path);\n\n  match file_path.canonicalize() {\n    Ok(absolute_path) =\u003e {\n      if let Some(path_str) = absolute_path.to_str() {\n        Ok(path_str.to_string())\n      } else {\n        Err(\"Failed to convert path to string\".to_string())\n      }\n    }\n    Err(e) =\u003e Err(format!(\"Failed to get absolute path: {}\", e)),\n  }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::{NamedTempFile, TempDir};\n    use std::fs;\n\n    #[test]\n    fn test_file_exists() {\n        let temp_file = NamedTempFile::new().unwrap();\n        let path = temp_file.path().to_str().unwrap().to_string();\n        \n        let result = file_exists(path.clone());\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n        \n        let result = file_exists(\"/nonexistent/file.txt\".to_string());\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n    }\n\n    #[test]\n    fn test_get_file_stats() {\n        let temp_file = NamedTempFile::new().unwrap();\n        fs::write(temp_file.path(), b\"test content\").unwrap();\n        let path = temp_file.path().to_str().unwrap().to_string();\n        \n        let result = get_file_stats(path);\n        assert!(result.is_ok());\n        \n        let stats = result.unwrap();\n        assert_eq!(stats.size, 12); // \"test content\" is 12 bytes\n        assert!(stats.last_modified \u003e 0);\n    }\n\n    #[test]\n    fn test_get_file_stats_nonexistent() {\n        let result = get_file_stats(\"/nonexistent/file.txt\".to_string());\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"File does not exist\"));\n    }\n\n    #[test]\n    fn test_get_file_stats_directory() {\n        let temp_dir = TempDir::new().unwrap();\n        let path = temp_dir.path().to_str().unwrap().to_string();\n        \n        // get_file_stats actually succeeds for directories since it only checks existence\n        let result = get_file_stats(path);\n        assert!(result.is_ok());\n        let stats = result.unwrap();\n        assert!(stats.last_modified \u003e 0);\n    }\n\n    #[test]\n    fn test_get_platform() {\n        let result = get_platform();\n        assert!(result.is_ok());\n        \n        let platform = result.unwrap();\n        assert!(!platform.is_empty());\n        \n        // Platform should be one of the known values\n        let valid_platforms = vec![\"windows\", \"macos\", \"linux\", \"ios\", \"android\"];\n        assert!(valid_platforms.contains(\u0026platform.as_str()));\n    }\n\n    #[test]\n    fn test_search_files_by_name() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create test files\n        fs::write(temp_dir.path().join(\"test1.txt\"), b\"content\").unwrap();\n        fs::write(temp_dir.path().join(\"test2.txt\"), b\"content\").unwrap();\n        fs::write(temp_dir.path().join(\"other.doc\"), b\"content\").unwrap();\n        \n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"test1.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 1);\n        assert!(files[0].contains(\"test1.txt\"));\n    }\n\n    #[test]\n    fn test_search_files_by_name_with_subdirectories() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create subdirectories\n        let sub_dir = temp_dir.path().join(\"subdir\");\n        fs::create_dir(\u0026sub_dir).unwrap();\n        \n        // Create files in different locations\n        fs::write(temp_dir.path().join(\"target.txt\"), b\"content\").unwrap();\n        fs::write(sub_dir.join(\"target.txt\"), b\"content\").unwrap();\n        \n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"target.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 2);\n    }\n\n    #[test]\n    fn test_search_files_by_name_max_depth() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create nested directories\n        let sub1 = temp_dir.path().join(\"level1\");\n        let sub2 = sub1.join(\"level2\");\n        let sub3 = sub2.join(\"level3\");\n        fs::create_dir_all(\u0026sub3).unwrap();\n        \n        // Create files at different depths\n        fs::write(temp_dir.path().join(\"file.txt\"), b\"content\").unwrap();\n        fs::write(sub1.join(\"file.txt\"), b\"content\").unwrap();\n        fs::write(sub2.join(\"file.txt\"), b\"content\").unwrap();\n        fs::write(sub3.join(\"file.txt\"), b\"content\").unwrap();\n        \n        // Search with max depth of 2\n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"file.txt\".to_string(),\n            Some(2)\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        // Should find files at depth 0 and 1, but not 2 or 3\n        assert_eq!(files.len(), 2);\n    }\n\n    #[test]\n    fn test_search_files_by_name_empty_result() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"nonexistent.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 0);\n    }\n\n    #[test]\n    fn test_search_files_by_name_nonexistent_directory() {\n        let result = search_files_by_name(\n            \"/nonexistent/directory\".to_string(),\n            \"file.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Directory does not exist\"));\n    }\n\n    #[test]\n    fn test_get_absolute_path() {\n        let temp_file = NamedTempFile::new().unwrap();\n        let path = temp_file.path().to_str().unwrap().to_string();\n        \n        let result = get_absolute_path(path.clone());\n        assert!(result.is_ok());\n        \n        let abs_path = result.unwrap();\n        assert!(abs_path.starts_with('/') || abs_path.contains(':'));\n    }\n\n    #[test]\n    fn test_get_absolute_path_nonexistent() {\n        // get_absolute_path can still work with non-existent files\n        // as long as the parent directory exists\n        let result = get_absolute_path(\"./nonexistent.txt\".to_string());\n        \n        // This might succeed or fail depending on the current directory\n        // If it succeeds, check that it's absolute\n        if let Ok(abs_path) = result {\n            assert!(abs_path.starts_with('/') || abs_path.contains(':'));\n        }\n    }\n\n    #[test]\n    #[cfg(unix)]\n    fn test_search_files_recursive_error_handling() {\n        // Test error handling in recursive search\n        let temp_dir = TempDir::new().unwrap();\n        \n        use std::os::unix::fs::PermissionsExt;\n        \n        // Create a readable file in root\n        fs::write(temp_dir.path().join(\"test.txt\"), b\"content\").unwrap();\n        \n        // Create a directory with restricted permissions\n        let restricted_dir = temp_dir.path().join(\"restricted\");\n        fs::create_dir(\u0026restricted_dir).unwrap();\n        \n        // Create a file inside before restricting\n        fs::write(restricted_dir.join(\"test.txt\"), b\"content\").unwrap();\n        \n        // Now restrict the directory\n        fs::set_permissions(\u0026restricted_dir, fs::Permissions::from_mode(0o000)).unwrap();\n        \n        // Search should find the file in root directory but fail on restricted directory\n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"test.txt\".to_string(),\n            None\n        );\n        \n        // Clean up permissions before assertions\n        fs::set_permissions(\u0026restricted_dir, fs::Permissions::from_mode(0o755)).unwrap();\n        \n        // The function returns error when it can't read a directory\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Failed to read directory\"));\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":9}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":28}},{"line":104,"address":[],"length":0,"stats":{"Line":11}},{"line":105,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":11}},{"line":108,"address":[],"length":0,"stats":{"Line":11}},{"line":109,"address":[],"length":0,"stats":{"Line":14}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":1}}],"covered":49,"coverable":54},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","language.rs"],"content":"use once_cell::sync::Lazy;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Mutex;\n\n// Поддерживаемые языки\nconst SUPPORTED_LANGUAGES: [\u0026str; 6] = [\"en\", \"ru\", \"es\", \"pt\", \"fr\", \"de\"];\nconst DEFAULT_LANGUAGE: \u0026str = \"en\";\n\n// Глобальное состояние для хранения текущего языка\nstatic APP_LANGUAGE: Lazy\u003cMutex\u003cString\u003e\u003e = Lazy::new(|| Mutex::new(DEFAULT_LANGUAGE.to_string()));\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LanguageResponse {\n  pub language: String,\n  pub system_language: String,\n}\n\n/// Получение системного языка\nfn get_system_language() -\u003e String {\n  // Получаем системную локаль\n  let locale = match sys_locale::get_locale() {\n    Some(loc) =\u003e loc,\n    None =\u003e DEFAULT_LANGUAGE.to_string(),\n  };\n\n  // Извлекаем код языка (первые 2 символа)\n  let lang_code = locale.chars().take(2).collect::\u003cString\u003e().to_lowercase();\n\n  // Проверяем, поддерживается ли язык, иначе возвращаем значение по умолчанию\n  if SUPPORTED_LANGUAGES.contains(\u0026lang_code.as_str()) {\n    lang_code\n  } else {\n    DEFAULT_LANGUAGE.to_string()\n  }\n}\n\n/// Проверка, поддерживается ли язык\nfn is_supported_language(lang: \u0026str) -\u003e bool {\n  SUPPORTED_LANGUAGES.contains(\u0026lang)\n}\n\n/// Получение текущего языка приложения\n#[tauri::command]\npub fn get_app_language() -\u003e LanguageResponse {\n  let system_language = get_system_language();\n  let app_language = APP_LANGUAGE.lock().unwrap().clone();\n\n  LanguageResponse {\n    language: app_language,\n    system_language,\n  }\n}\n\n/// Установка языка приложения\n#[tauri::command]\npub fn set_app_language(lang: String) -\u003e Result\u003cLanguageResponse, String\u003e {\n  // Проверяем, поддерживается ли язык\n  if !is_supported_language(\u0026lang) {\n    return Err(format!(\"Unsupported language: {}\", lang));\n  }\n\n  // Устанавливаем новый язык\n  let mut app_language = APP_LANGUAGE.lock().unwrap();\n  *app_language = lang;\n\n  Ok(LanguageResponse {\n    language: app_language.clone(),\n    system_language: get_system_language(),\n  })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_supported_language() {\n        // Test supported languages\n        assert!(is_supported_language(\"en\"));\n        assert!(is_supported_language(\"ru\"));\n        assert!(is_supported_language(\"es\"));\n        assert!(is_supported_language(\"pt\"));\n        assert!(is_supported_language(\"fr\"));\n        assert!(is_supported_language(\"de\"));\n        \n        // Test unsupported languages\n        assert!(!is_supported_language(\"ja\"));\n        assert!(!is_supported_language(\"ko\"));\n        assert!(!is_supported_language(\"zh\"));\n        assert!(!is_supported_language(\"\"));\n    }\n\n    #[test]\n    fn test_get_system_language() {\n        let lang = get_system_language();\n        // Should return a valid language code\n        assert!(!lang.is_empty());\n        assert!(SUPPORTED_LANGUAGES.contains(\u0026lang.as_str()));\n    }\n\n    #[test]\n    fn test_get_app_language() {\n        let response = get_app_language();\n        // Should return default language initially\n        assert!(!response.language.is_empty());\n        assert!(!response.system_language.is_empty());\n        assert!(is_supported_language(\u0026response.language));\n        assert!(is_supported_language(\u0026response.system_language));\n    }\n\n    #[test]\n    fn test_set_app_language_valid() {\n        // Test setting a valid language\n        let result = set_app_language(\"ru\".to_string());\n        assert!(result.is_ok());\n        \n        let response = result.unwrap();\n        assert_eq!(response.language, \"ru\");\n        assert!(!response.system_language.is_empty());\n        \n        // Verify the language was actually set\n        let current = get_app_language();\n        assert_eq!(current.language, \"ru\");\n        \n        // Reset to default\n        let _ = set_app_language(DEFAULT_LANGUAGE.to_string());\n    }\n\n    #[test]\n    fn test_set_app_language_invalid() {\n        // Test setting an invalid language\n        let result = set_app_language(\"xyz\".to_string());\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Unsupported language\"));\n    }\n\n    #[test]\n    fn test_supported_languages_constant() {\n        // Verify the constant is properly defined\n        assert_eq!(SUPPORTED_LANGUAGES.len(), 6);\n        assert_eq!(DEFAULT_LANGUAGE, \"en\");\n    }\n\n    #[test]\n    fn test_language_response_serialization() {\n        let response = LanguageResponse {\n            language: \"en\".to_string(),\n            system_language: \"en\".to_string(),\n        };\n        \n        let json = serde_json::to_string(\u0026response).unwrap();\n        assert!(json.contains(\"\\\"language\\\":\\\"en\\\"\"));\n        assert!(json.contains(\"\\\"system_language\\\":\\\"en\\\"\"));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":5}},{"line":21,"address":[],"length":0,"stats":{"Line":10}},{"line":22,"address":[],"length":0,"stats":{"Line":5}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":15}},{"line":39,"address":[],"length":0,"stats":{"Line":15}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}}],"covered":20,"coverable":22},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","lib.rs"],"content":"// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n// Модуль для работы с языком\nmod language;\nuse language::{get_app_language, set_app_language};\n\n// Модуль для работы с медиафайлами\nmod media;\nuse media::{get_media_files, get_media_metadata};\n\n// Модуль для работы с файловой системой\nmod filesystem;\n\n// Модуль Video Compiler\nmod video_compiler;\nuse video_compiler::{initialize, PreviewGenerator, VideoCompilerState};\n\n// Модуль Video Server\nmod video_server;\nuse video_server::{VideoServerState, VideoRegistrationResponse};\n\n// Импортируем GPU и Frame Extraction команды\nuse video_compiler::commands::{\n  cancel_render, check_ffmpeg_capabilities, check_hardware_acceleration, clear_frame_cache,\n  clear_prerender_cache, clear_preview_cache, compile_video, extract_recognition_frames,\n  extract_subtitle_frames, extract_timeline_frames, generate_preview, get_active_jobs,\n  get_cache_stats, get_compiler_settings, get_current_gpu_info, get_gpu_capabilities,\n  get_prerender_cache_info, get_render_progress, get_system_info, prerender_segment,\n  set_ffmpeg_path, update_compiler_settings,\n};\n\n#[tauri::command]\nfn greet() -\u003e String {\n  let now = SystemTime::now();\n  let epoch_ms = now.duration_since(UNIX_EPOCH).unwrap().as_millis();\n  format!(\"Hello world from Rust! Current epoch: {}\", epoch_ms)\n}\n\n// Video Compiler Commands (non-duplicate ones only)\n\n#[tauri::command]\nasync fn get_video_info(\n  file_path: String,\n  state: tauri::State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cvideo_compiler::preview::VideoInfo, String\u003e {\n  use std::path::Path;\n\n  let path = Path::new(\u0026file_path);\n  let preview_generator = PreviewGenerator::new(state.cache_manager.clone());\n\n  match preview_generator.get_video_info(path).await {\n    Ok(info) =\u003e Ok(info),\n    Err(e) =\u003e {\n      log::error!(\"Ошибка получения информации о видео: {}\", e);\n      Err(e.to_string())\n    }\n  }\n}\n\n#[tauri::command]\nasync fn clear_all_cache(state: tauri::State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c(), String\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_all().await;\n  log::info!(\"Весь кэш очищен\");\n  Ok(())\n}\n\n#[tauri::command]\nasync fn register_video(\n  path: String,\n  state: tauri::State\u003c'_, VideoServerState\u003e,\n) -\u003e Result\u003cVideoRegistrationResponse, String\u003e {\n  use std::path::PathBuf;\n  \n  let path_buf = PathBuf::from(\u0026path);\n  if !path_buf.exists() {\n    return Err(\"File does not exist\".to_string());\n  }\n  \n  let id = state.register_video(path_buf).await;\n  \n  Ok(VideoRegistrationResponse {\n    id: id.clone(),\n    url: format!(\"http://localhost:4567/video/{}\", id),\n  })\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n  // Инициализация runtime для async операций\n  let runtime = tokio::runtime::Runtime::new().unwrap();\n  \n  // Инициализация Video Compiler state\n  let video_compiler_state = runtime.block_on(async {\n    match initialize().await {\n      Ok(state) =\u003e {\n        log::info!(\"Video Compiler успешно инициализирован\");\n        state\n      }\n      Err(e) =\u003e {\n        log::error!(\"Ошибка инициализации Video Compiler: {}\", e);\n        // Возвращаем состояние по умолчанию, если FFmpeg недоступен\n        VideoCompilerState::default()\n      }\n    }\n  });\n  \n  // Инициализация Video Server\n  let video_server_state = VideoServerState::new();\n  let video_server_state_clone = video_server_state.clone();\n  \n  // Запускаем video server в отдельной задаче\n  runtime.spawn(async move {\n    video_server::start_video_server(video_server_state_clone).await;\n  });\n\n  tauri::Builder::default()\n    .plugin(tauri_plugin_log::Builder::new().build())\n    .plugin(tauri_plugin_notification::init())\n    .plugin(tauri_plugin_global_shortcut::Builder::new().build())\n    .plugin(tauri_plugin_fs::init())\n    .plugin(tauri_plugin_dialog::init())\n    .plugin(tauri_plugin_websocket::init())\n    .plugin(tauri_plugin_opener::init())\n    .plugin(tauri_plugin_store::Builder::default().build())\n    .manage(video_compiler_state)\n    .manage(video_server_state)\n    .invoke_handler(tauri::generate_handler![\n      greet,\n      get_app_language,\n      set_app_language,\n      get_media_metadata,\n      get_media_files,\n      filesystem::file_exists,\n      filesystem::get_file_stats,\n      filesystem::get_platform,\n      filesystem::search_files_by_name,\n      filesystem::get_absolute_path,\n      // Video Server command\n      register_video,\n      // Video Compiler commands\n      compile_video,\n      get_render_progress,\n      generate_preview,\n      prerender_segment,\n      get_prerender_cache_info,\n      clear_prerender_cache,\n      cancel_render,\n      get_active_jobs,\n      get_video_info,\n      clear_preview_cache,\n      get_cache_stats,\n      clear_all_cache,\n      // GPU команды\n      get_gpu_capabilities,\n      get_current_gpu_info,\n      check_hardware_acceleration,\n      get_compiler_settings,\n      update_compiler_settings,\n      set_ffmpeg_path,\n      get_system_info,\n      check_ffmpeg_capabilities,\n      // Frame extraction команды\n      extract_timeline_frames,\n      extract_recognition_frames,\n      extract_subtitle_frames,\n      clear_frame_cache\n    ])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    use std::sync::Arc;\n\n    #[test]\n    fn test_greet() {\n        let result = greet();\n        assert!(result.contains(\"Hello world from Rust!\"));\n        assert!(result.contains(\"Current epoch:\"));\n        \n        // Проверяем, что epoch - это число\n        let parts: Vec\u003c\u0026str\u003e = result.split(\"Current epoch: \").collect();\n        assert_eq!(parts.len(), 2);\n        let epoch_str = parts[1];\n        assert!(epoch_str.parse::\u003cu128\u003e().is_ok());\n    }\n\n    #[test]\n    fn test_epoch_calculation() {\n        let now = SystemTime::now();\n        let epoch_ms = now.duration_since(UNIX_EPOCH).unwrap().as_millis();\n        \n        // Проверяем, что epoch в разумных пределах (после 2020 года)\n        assert!(epoch_ms \u003e 1577836800000); // 1 января 2020\n        assert!(epoch_ms \u003c 2000000000000); // где-то в 2033 году\n    }\n\n    #[test]\n    fn test_imports() {\n        // Проверяем, что все импорты работают\n        // Это в основном проверка компиляции\n        // Просто проверяем, что типы существуют\n        let _ = std::any::type_name::\u003cVideoCompilerState\u003e();\n        let _ = std::any::type_name::\u003cVideoServerState\u003e();\n    }\n\n    #[tokio::test]\n    async fn test_video_compiler_state_creation() {\n        // Тестируем создание VideoCompilerState через команды\n        use video_compiler::commands::VideoCompilerState;\n        \n        let state = VideoCompilerState::new();\n        \n        // Проверяем, что состояние создано корректно\n        assert!(Arc::strong_count(\u0026state.active_jobs) \u003e 0);\n        assert!(Arc::strong_count(\u0026state.cache_manager) \u003e 0);\n        assert!(!state.ffmpeg_path.is_empty());\n        assert!(Arc::strong_count(\u0026state.settings) \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_cache_functionality() {\n        use tokio::sync::RwLock;\n        \n        // Создаем RenderCache\n        let cache = Arc::new(RwLock::new(video_compiler::cache::RenderCache::new()));\n        \n        // Добавляем некоторые данные в кэш\n        {\n            let mut cache_guard = cache.write().await;\n            let _ = cache_guard.store_metadata(\n                \"test_path\".to_string(),\n                video_compiler::cache::MediaMetadata {\n                    file_path: \"test_path\".to_string(),\n                    file_size: 1000000,\n                    modified_time: std::time::SystemTime::now(),\n                    duration: 10.0,\n                    resolution: Some((1920, 1080)),\n                    fps: Some(30.0),\n                    bitrate: Some(5000),\n                    video_codec: Some(\"h264\".to_string()),\n                    audio_codec: Some(\"aac\".to_string()),\n                    cached_at: std::time::SystemTime::now(),\n                }\n            ).await;\n        }\n\n        // Очищаем кэш\n        {\n            let mut cache_guard = cache.write().await;\n            cache_guard.clear_all().await;\n        }\n\n        // Проверяем, что кэш пустой\n        let cache_guard = cache.read().await;\n        let memory_usage = cache_guard.get_memory_usage();\n        // После очистки кэша память должна быть почти полностью освобождена (небольшие структуры могут остаться)\n        assert!(memory_usage.total_mb() \u003c 0.01); // Меньше 10KB\n    }\n\n    #[tokio::test]\n    async fn test_register_video_functionality() {\n        \n        // Создаем временный видео файл\n        let temp_dir = TempDir::new().unwrap();\n        let video_path = temp_dir.path().join(\"test_video.mp4\");\n        std::fs::write(\u0026video_path, b\"fake video content\").unwrap();\n\n        // Создаем VideoServerState и регистрируем видео напрямую\n        let state = VideoServerState::new();\n        let id = state.register_video(video_path.clone()).await;\n        \n        assert!(!id.is_empty());\n        \n        // Проверяем, что файл действительно зарегистрирован\n        let videos = state.video_registry.lock().await;\n        assert!(videos.contains_key(\u0026id));\n        assert_eq!(videos.get(\u0026id).unwrap(), \u0026video_path);\n    }\n\n    #[test]\n    fn test_video_compiler_state_default() {\n        // Проверяем, что VideoCompilerState::default() создается корректно\n        let state = VideoCompilerState::default();\n        \n        // Проверяем, что все поля инициализированы\n        assert!(Arc::strong_count(\u0026state.active_jobs) \u003e 0);\n        assert!(Arc::strong_count(\u0026state.cache_manager) \u003e 0);\n        assert!(!state.ffmpeg_path.is_empty());\n        assert!(Arc::strong_count(\u0026state.settings) \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_initialize_success() {\n        // Тестируем инициализацию video compiler\n        let result = video_compiler::initialize().await;\n        \n        // Результат зависит от наличия FFmpeg в системе\n        // Но функция должна вернуть либо Ok, либо Err, но не паниковать\n        match result {\n            Ok(state) =\u003e {\n                // Проверяем, что состояние создано корректно\n                assert!(Arc::strong_count(\u0026state.cache_manager) \u003e 0);\n                assert!(Arc::strong_count(\u0026state.settings) \u003e 0);\n            }\n            Err(e) =\u003e {\n                // Ошибка ожидается, если FFmpeg не установлен\n                assert!(e.to_string().contains(\"FFmpeg\") || e.to_string().contains(\"ffmpeg\"));\n            }\n        }\n    }\n\n    #[test]\n    fn test_video_server_state_new() {\n        // Проверяем создание VideoServerState\n        let state = VideoServerState::new();\n        \n        // State должен быть создан успешно\n        // Проверяем, что он может быть клонирован\n        let _cloned = state.clone();\n    }\n\n    #[tokio::test]\n    async fn test_start_video_server() {\n        use std::time::Duration;\n        \n        // Создаем VideoServerState\n        let state = VideoServerState::new();\n        \n        // Запускаем сервер в отдельной задаче\n        let server_handle = tokio::spawn(async move {\n            video_server::start_video_server(state).await;\n        });\n        \n        // Даем серверу время запуститься\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        \n        // Проверяем, что сервер доступен\n        let client = reqwest::Client::new();\n        let response = client.get(\"http://localhost:4567/health\")\n            .timeout(Duration::from_secs(1))\n            .send()\n            .await;\n        \n        // Проверяем ответ или timeout (сервер может не запуститься в тестовом окружении)\n        match response {\n            Ok(resp) =\u003e {\n                assert_eq!(resp.status(), 200);\n            }\n            Err(_) =\u003e {\n                // Сервер может не запуститься в тестовом окружении, это нормально\n            }\n        }\n        \n        // Останавливаем сервер\n        server_handle.abort();\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":87},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","main.rs"],"content":"// Prevents additional console window on Windows in release, DO NOT REMOVE!!\r\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\r\n\r\nfn main() {\r\n  timeline_studio_lib::run()\r\n}\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","ffmpeg.rs"],"content":"// Модуль для работы с FFmpeg\n\nuse std::process::Command;\n\n/// Проверка наличия FFmpeg в системе\npub fn check_ffmpeg() -\u003e Result\u003c(), String\u003e {\n  let output = Command::new(\"ffprobe\").arg(\"-version\").output();\n\n  match output {\n    Ok(_) =\u003e Ok(()),\n    Err(_) =\u003e Err(\"FFmpeg не установлен или не найден в системном пути\".to_string()),\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_check_ffmpeg() {\n    // Тест проверки наличия FFmpeg\n    // Примечание: этот тест может не пройти, если FFmpeg не установлен\n    match check_ffmpeg() {\n      Ok(_) =\u003e println!(\"FFmpeg найден\"),\n      Err(e) =\u003e println!(\"FFmpeg не найден: {}\", e),\n    }\n    // Не делаем assert, так как FFmpeg может быть не установлен в CI\n  }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":5},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","files.rs"],"content":"// Модуль для работы с файлами\n\nuse super::types::SUPPORTED_EXTENSIONS;\nuse std::path::Path;\nuse tauri::command;\n\n/// Получение списка медиафайлов в директории\n#[command]\npub fn get_media_files(directory: String) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n  let path = Path::new(\u0026directory);\n\n  if !path.exists() || !path.is_dir() {\n    return Err(format!(\"Директория не найдена: {}\", directory));\n  }\n\n  let entries = std::fs::read_dir(path).map_err(|e| format!(\"Ошибка чтения директории: {}\", e))?;\n\n  let mut media_files = Vec::new();\n\n  for entry in entries.flatten() {\n    let path = entry.path();\n\n    // Проверяем только файлы\n    if path.is_file() {\n      if let Some(extension) = path.extension().and_then(|e| e.to_str()) {\n        // Проверяем расширение файла\n        let ext = extension.to_lowercase();\n        if SUPPORTED_EXTENSIONS.contains(\u0026ext.as_str()) {\n          if let Some(path_str) = path.to_str() {\n            media_files.push(path_str.to_string());\n          }\n        }\n      }\n    }\n  }\n\n  Ok(media_files)\n}\n\n/// Проверяет, является ли файл медиафайлом по расширению\n#[allow(dead_code)]\npub fn is_media_file(file_path: \u0026str) -\u003e bool {\n  if let Some(extension) = Path::new(file_path).extension().and_then(|e| e.to_str()) {\n    let ext = extension.to_lowercase();\n    SUPPORTED_EXTENSIONS.contains(\u0026ext.as_str())\n  } else {\n    false\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use std::fs;\n  use tempfile::TempDir;\n\n  /// Создает временный тестовый файл\n  fn create_test_file(dir: \u0026TempDir, name: \u0026str, content: \u0026[u8]) -\u003e String {\n    let file_path = dir.path().join(name);\n    fs::write(\u0026file_path, content).expect(\"Failed to write test file\");\n    file_path.to_string_lossy().to_string()\n  }\n\n  /// Создает временную директорию с тестовыми файлами\n  fn create_test_directory() -\u003e TempDir {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp directory\");\n\n    // Создаем тестовые файлы разных типов\n    create_test_file(\u0026temp_dir, \"video.mp4\", b\"fake video content\");\n    create_test_file(\u0026temp_dir, \"audio.mp3\", b\"fake audio content\");\n    create_test_file(\u0026temp_dir, \"image.jpg\", b\"fake image content\");\n    create_test_file(\u0026temp_dir, \"document.txt\", b\"not a media file\");\n\n    temp_dir\n  }\n\n  #[test]\n  fn test_get_media_files_with_valid_directory() {\n    let temp_dir = create_test_directory();\n    let dir_path = temp_dir.path().to_string_lossy().to_string();\n\n    let result = get_media_files(dir_path);\n    assert!(result.is_ok());\n\n    let files = result.unwrap();\n    assert_eq!(files.len(), 3); // video.mp4, audio.mp3, image.jpg\n\n    // Проверяем, что все файлы имеют правильные расширения\n    let extensions: Vec\u003cString\u003e = files\n      .iter()\n      .filter_map(|f| {\n        std::path::Path::new(f)\n          .extension()\n          .and_then(|e| e.to_str())\n          .map(|s| s.to_lowercase())\n      })\n      .collect();\n\n    assert!(extensions.contains(\u0026\"mp4\".to_string()));\n    assert!(extensions.contains(\u0026\"mp3\".to_string()));\n    assert!(extensions.contains(\u0026\"jpg\".to_string()));\n    assert!(!extensions.contains(\u0026\"txt\".to_string()));\n  }\n\n  #[test]\n  fn test_get_media_files_with_invalid_directory() {\n    let result = get_media_files(\"/nonexistent/directory\".to_string());\n    assert!(result.is_err());\n    assert!(result.unwrap_err().contains(\"Директория не найдена\"));\n  }\n\n  #[test]\n  fn test_get_media_files_with_empty_directory() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp directory\");\n    let dir_path = temp_dir.path().to_string_lossy().to_string();\n\n    let result = get_media_files(dir_path);\n    assert!(result.is_ok());\n\n    let files = result.unwrap();\n    assert_eq!(files.len(), 0);\n  }\n\n  #[test]\n  fn test_supported_media_extensions() {\n    // Тестируем, что поддерживаются правильные расширения файлов\n    let temp_dir = TempDir::new().expect(\"Failed to create temp directory\");\n\n    // Создаем файлы с разными расширениями\n    let supported_extensions = [\n      \"mp4\", \"avi\", \"mkv\", \"mov\", \"webm\", // видео\n      \"mp3\", \"wav\", \"ogg\", \"flac\", // аудио\n      \"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", // изображения\n    ];\n\n    let unsupported_extensions = [\"txt\", \"doc\", \"pdf\", \"exe\"];\n\n    // Создаем поддерживаемые файлы\n    for ext in \u0026supported_extensions {\n      create_test_file(\u0026temp_dir, \u0026format!(\"test.{}\", ext), b\"test content\");\n    }\n\n    // Создаем неподдерживаемые файлы\n    for ext in \u0026unsupported_extensions {\n      create_test_file(\u0026temp_dir, \u0026format!(\"test.{}\", ext), b\"test content\");\n    }\n\n    let dir_path = temp_dir.path().to_string_lossy().to_string();\n    let result = get_media_files(dir_path);\n    assert!(result.is_ok());\n\n    let files = result.unwrap();\n    assert_eq!(files.len(), supported_extensions.len());\n\n    // Проверяем, что все найденные файлы имеют поддерживаемые расширения\n    for file in \u0026files {\n      let extension = std::path::Path::new(file)\n        .extension()\n        .and_then(|e| e.to_str())\n        .map(|s| s.to_lowercase())\n        .unwrap_or_default();\n\n      assert!(\n        supported_extensions.contains(\u0026extension.as_str()),\n        \"Неподдерживаемое расширение найдено: {}\",\n        extension\n      );\n    }\n  }\n\n  #[test]\n  fn test_is_media_file() {\n    // Тестируем функцию проверки медиафайлов\n    assert!(is_media_file(\"video.mp4\"));\n    assert!(is_media_file(\"audio.mp3\"));\n    assert!(is_media_file(\"image.jpg\"));\n    assert!(is_media_file(\"VIDEO.MP4\")); // Проверяем регистронезависимость\n\n    assert!(!is_media_file(\"document.txt\"));\n    assert!(!is_media_file(\"archive.zip\"));\n    assert!(!is_media_file(\"no_extension\"));\n  }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":7}},{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":12}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":15}},{"line":20,"address":[],"length":0,"stats":{"Line":27}},{"line":25,"address":[],"length":0,"stats":{"Line":108}},{"line":29,"address":[],"length":0,"stats":{"Line":42}},{"line":42,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":26}},{"line":47,"address":[],"length":0,"stats":{"Line":1}}],"covered":11,"coverable":11},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","metadata","tests.rs"],"content":"use super::*;\nuse tempfile::NamedTempFile;\nuse std::io::Write;\n\n#[test]\nfn test_parse_format_data() {\n    let mut format_data = serde_json::Map::new();\n    format_data.insert(\"duration\".to_string(), serde_json::json!(\"120.5\"));\n    format_data.insert(\"size\".to_string(), serde_json::json!(\"1048576\"));\n    format_data.insert(\"bit_rate\".to_string(), serde_json::json!(\"128000\"));\n    format_data.insert(\"format_name\".to_string(), serde_json::json!(\"mp4\"));\n    \n    let mut ffprobe_format = FfprobeFormat {\n        duration: None,\n        size: None,\n        bit_rate: None,\n        format_name: None,\n    };\n    \n    parse_format_data(\u0026format_data, \u0026mut ffprobe_format);\n    \n    assert_eq!(ffprobe_format.duration, Some(120.5));\n    assert_eq!(ffprobe_format.size, Some(1048576));\n    assert_eq!(ffprobe_format.bit_rate, Some(\"128000\".to_string()));\n    assert_eq!(ffprobe_format.format_name, Some(\"mp4\".to_string()));\n}\n\n#[test]\nfn test_parse_format_data_with_invalid_values() {\n    let mut format_data = serde_json::Map::new();\n    format_data.insert(\"duration\".to_string(), serde_json::json!(\"invalid\"));\n    format_data.insert(\"size\".to_string(), serde_json::json!(\"not a number\"));\n    \n    let mut ffprobe_format = FfprobeFormat {\n        duration: None,\n        size: None,\n        bit_rate: None,\n        format_name: None,\n    };\n    \n    parse_format_data(\u0026format_data, \u0026mut ffprobe_format);\n    \n    // Invalid values should result in None\n    assert_eq!(ffprobe_format.duration, None);\n    assert_eq!(ffprobe_format.size, None);\n}\n\n#[test]\nfn test_parse_stream_data_video() {\n    let stream_json = serde_json::json!({\n        \"index\": 0,\n        \"codec_type\": \"video\",\n        \"codec_name\": \"h264\",\n        \"width\": 1920,\n        \"height\": 1080,\n        \"bit_rate\": \"5000000\",\n        \"r_frame_rate\": \"30/1\",\n        \"display_aspect_ratio\": \"16:9\"\n    });\n\n    let parsed_stream = parse_stream_data(\u0026stream_json, 0);\n\n    assert_eq!(parsed_stream.index, 0);\n    assert_eq!(parsed_stream.codec_type, \"video\");\n    assert_eq!(parsed_stream.codec_name, Some(\"h264\".to_string()));\n    assert_eq!(parsed_stream.width, Some(1920));\n    assert_eq!(parsed_stream.height, Some(1080));\n    assert_eq!(parsed_stream.bit_rate, Some(\"5000000\".to_string()));\n    assert_eq!(parsed_stream.r_frame_rate, Some(\"30/1\".to_string()));\n    assert_eq!(parsed_stream.display_aspect_ratio, Some(\"16:9\".to_string()));\n}\n\n#[test]\nfn test_parse_stream_data_audio() {\n    let stream_json = serde_json::json!({\n        \"index\": 1,\n        \"codec_type\": \"audio\",\n        \"codec_name\": \"aac\",\n        \"sample_rate\": \"48000\",\n        \"channels\": 2,\n        \"bit_rate\": \"128000\"\n    });\n\n    let parsed_stream = parse_stream_data(\u0026stream_json, 1);\n\n    assert_eq!(parsed_stream.index, 1);\n    assert_eq!(parsed_stream.codec_type, \"audio\");\n    assert_eq!(parsed_stream.codec_name, Some(\"aac\".to_string()));\n    assert_eq!(parsed_stream.sample_rate, Some(\"48000\".to_string()));\n    assert_eq!(parsed_stream.channels, Some(2));\n    assert_eq!(parsed_stream.bit_rate, Some(\"128000\".to_string()));\n    assert_eq!(parsed_stream.width, None);\n    assert_eq!(parsed_stream.height, None);\n}\n\n#[test]\nfn test_parse_stream_data_missing_fields() {\n    let stream_json = serde_json::json!({});\n    let parsed_stream = parse_stream_data(\u0026stream_json, 5);\n\n    assert_eq!(parsed_stream.index, 5); // Should use the provided index\n    assert_eq!(parsed_stream.codec_type, \"unknown\");\n    assert_eq!(parsed_stream.codec_name, None);\n    assert_eq!(parsed_stream.width, None);\n    assert_eq!(parsed_stream.height, None);\n}\n\n#[test]\nfn test_extract_creation_time_with_tags() {\n    // Test with creation time\n    let format_with_time = serde_json::json!({\n        \"tags\": {\n            \"creation_time\": \"2023-01-01T00:00:00Z\"\n        }\n    });\n\n    let format_map = format_with_time.as_object();\n    let creation_time = extract_creation_time(format_map);\n    assert_eq!(creation_time, Some(\"2023-01-01T00:00:00Z\".to_string()));\n}\n\n#[test]\nfn test_extract_creation_time_without_tags() {\n    // Test without creation time\n    let format_without_time = serde_json::json!({\n        \"duration\": \"120.5\"\n    });\n\n    let format_map = format_without_time.as_object();\n    let creation_time = extract_creation_time(format_map);\n    assert_eq!(creation_time, None);\n}\n\n#[test]\nfn test_extract_creation_time_none() {\n    let creation_time = extract_creation_time(None);\n    assert_eq!(creation_time, None);\n}\n\n#[test]\nfn test_generate_iso8601_timestamp_format() {\n    let timestamp = generate_iso8601_timestamp();\n\n    // Check format: should be seconds.nanoseconds + Z\n    assert!(timestamp.ends_with('Z'));\n    assert!(timestamp.contains('.'));\n\n    let parts: Vec\u003c\u0026str\u003e = timestamp.split('.').collect();\n    assert_eq!(parts.len(), 2);\n\n    // Check seconds part is a valid number\n    assert!(parts[0].parse::\u003cu64\u003e().is_ok());\n    \n    // Check nanoseconds part (minus the Z) has 9 digits\n    let nanos_part = parts[1].trim_end_matches('Z');\n    assert_eq!(nanos_part.len(), 9);\n    assert!(nanos_part.parse::\u003cu32\u003e().is_ok());\n}\n\n#[test]\nfn test_get_media_metadata_nonexistent_file() {\n    let result = get_media_metadata(\"/nonexistent/file.mp4\".to_string());\n    assert!(result.is_err());\n    assert!(result.unwrap_err().contains(\"Файл не найден\"));\n}\n\n#[test]\nfn test_ffprobe_format_struct() {\n    let format = FfprobeFormat {\n        duration: Some(120.5),\n        size: Some(1024),\n        bit_rate: Some(\"128000\".to_string()),\n        format_name: Some(\"mp4\".to_string()),\n    };\n\n    // Test serialization\n    let json = serde_json::to_string(\u0026format).unwrap();\n    assert!(json.contains(\"120.5\"));\n    assert!(json.contains(\"1024\"));\n    assert!(json.contains(\"128000\"));\n    assert!(json.contains(\"mp4\"));\n\n    // Test deserialization\n    let deserialized: FfprobeFormat = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.duration, format.duration);\n    assert_eq!(deserialized.size, format.size);\n    assert_eq!(deserialized.bit_rate, format.bit_rate);\n    assert_eq!(deserialized.format_name, format.format_name);\n}\n\n#[test]\nfn test_ffprobe_stream_struct() {\n    let stream = FfprobeStream {\n        index: 0,\n        codec_type: \"video\".to_string(),\n        codec_name: Some(\"h264\".to_string()),\n        width: Some(1920),\n        height: Some(1080),\n        bit_rate: Some(\"5000000\".to_string()),\n        r_frame_rate: Some(\"30/1\".to_string()),\n        sample_rate: None,\n        channels: None,\n        display_aspect_ratio: Some(\"16:9\".to_string()),\n    };\n\n    // Test serialization\n    let json = serde_json::to_string(\u0026stream).unwrap();\n    assert!(json.contains(\"\\\"index\\\":0\"));\n    assert!(json.contains(\"\\\"codec_type\\\":\\\"video\\\"\"));\n    assert!(json.contains(\"\\\"width\\\":1920\"));\n\n    // Test deserialization\n    let deserialized: FfprobeStream = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.index, stream.index);\n    assert_eq!(deserialized.codec_type, stream.codec_type);\n    assert_eq!(deserialized.width, stream.width);\n}\n\n#[test]\nfn test_probe_data_struct() {\n    let probe_data = ProbeData {\n        streams: vec![\n            FfprobeStream {\n                index: 0,\n                codec_type: \"video\".to_string(),\n                codec_name: Some(\"h264\".to_string()),\n                width: Some(1920),\n                height: Some(1080),\n                bit_rate: None,\n                r_frame_rate: None,\n                sample_rate: None,\n                channels: None,\n                display_aspect_ratio: None,\n            },\n        ],\n        format: FfprobeFormat {\n            duration: Some(60.0),\n            size: Some(1048576),\n            bit_rate: None,\n            format_name: Some(\"mp4\".to_string()),\n        },\n    };\n\n    let json = serde_json::to_string(\u0026probe_data).unwrap();\n    assert!(json.contains(\"streams\"));\n    assert!(json.contains(\"format\"));\n\n    let deserialized: ProbeData = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.streams.len(), 1);\n    assert_eq!(deserialized.format.duration, Some(60.0));\n}\n\n#[test]\nfn test_media_file_struct() {\n    let media_file = MediaFile {\n        id: \"test-id\".to_string(),\n        name: \"test.mp4\".to_string(),\n        path: \"/path/to/test.mp4\".to_string(),\n        is_video: true,\n        is_audio: false,\n        is_image: false,\n        size: 1048576,\n        duration: Some(60.0),\n        start_time: 1234567890,\n        creation_time: \"2023-01-01T00:00:00Z\".to_string(),\n        probe_data: ProbeData {\n            streams: vec![],\n            format: FfprobeFormat {\n                duration: Some(60.0),\n                size: Some(1048576),\n                bit_rate: None,\n                format_name: None,\n            },\n        },\n    };\n\n    let json = serde_json::to_string(\u0026media_file).unwrap();\n    assert!(json.contains(\"test-id\"));\n    assert!(json.contains(\"test.mp4\"));\n    assert!(json.contains(\"is_video\"));\n\n    let deserialized: MediaFile = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.id, media_file.id);\n    assert_eq!(deserialized.is_video, true);\n    assert_eq!(deserialized.is_audio, false);\n}\n\n#[test]\nfn test_media_type_detection_video() {\n    // Test video file detection\n    let streams_array = vec![\n        serde_json::json!({\n            \"codec_type\": \"video\",\n            \"codec_name\": \"h264\"\n        })\n    ];\n    \n    let mut is_video = false;\n    let mut is_audio = false;\n    let mut is_image = false;\n\n    for stream in \u0026streams_array {\n        let codec_type = stream.get(\"codec_type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        \n        if codec_type == \"video\" \u0026\u0026 \n           stream.get(\"disposition\")\n                 .and_then(|d| d.get(\"attached_pic\"))\n                 .and_then(|v| v.as_i64()) != Some(1) {\n            is_video = true;\n        } else if codec_type == \"audio\" {\n            is_audio = true;\n        }\n    }\n\n    assert!(is_video);\n    assert!(!is_audio);\n    assert!(!is_image);\n}\n\n#[test]\nfn test_media_type_detection_audio() {\n    let streams_array = vec![\n        serde_json::json!({\n            \"codec_type\": \"audio\",\n            \"codec_name\": \"aac\"\n        })\n    ];\n    \n    let mut is_video = false;\n    let mut is_audio = false;\n\n    for stream in \u0026streams_array {\n        let codec_type = stream.get(\"codec_type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        \n        if codec_type == \"audio\" {\n            is_audio = true;\n        }\n    }\n\n    assert!(!is_video);\n    assert!(is_audio);\n}\n\n#[test]\nfn test_media_type_detection_image() {\n    // Image detection: no video/audio streams but has width/height\n    let streams_array = vec![\n        serde_json::json!({\n            \"codec_type\": \"video\",\n            \"codec_name\": \"mjpeg\",\n            \"width\": 1920,\n            \"height\": 1080,\n            \"disposition\": {\n                \"attached_pic\": 1\n            }\n        })\n    ];\n    \n    let mut is_video = false;\n    let mut is_audio = false;\n    let mut is_image = false;\n\n    for stream in \u0026streams_array {\n        let codec_type = stream.get(\"codec_type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        \n        if codec_type == \"video\" \u0026\u0026 \n           stream.get(\"disposition\")\n                 .and_then(|d| d.get(\"attached_pic\"))\n                 .and_then(|v| v.as_i64()) == Some(1) {\n            // This is an attached picture, not a video stream\n            is_image = true;\n        }\n    }\n\n    assert!(!is_video);\n    assert!(!is_audio);\n    assert!(is_image);\n}\n\n#[test]\nfn test_parse_format_data_empty() {\n    let format_data = serde_json::Map::new();\n    let mut ffprobe_format = FfprobeFormat {\n        duration: None,\n        size: None,\n        bit_rate: None,\n        format_name: None,\n    };\n    \n    parse_format_data(\u0026format_data, \u0026mut ffprobe_format);\n    \n    assert_eq!(ffprobe_format.duration, None);\n    assert_eq!(ffprobe_format.size, None);\n    assert_eq!(ffprobe_format.bit_rate, None);\n    assert_eq!(ffprobe_format.format_name, None);\n}\n\n#[test]\nfn test_parse_stream_data_with_index_override() {\n    let stream_json = serde_json::json!({\n        \"index\": 10,\n        \"codec_type\": \"video\"\n    });\n\n    let parsed_stream = parse_stream_data(\u0026stream_json, 99);\n\n    // Should use the index from JSON, not the parameter\n    assert_eq!(parsed_stream.index, 10);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","metadata.rs"],"content":"// Модуль для получения метаданных медиафайлов\n\nuse std::path::Path;\nuse std::process::Command;\nuse std::str;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse tauri::command;\n\nuse super::ffmpeg::check_ffmpeg;\nuse super::types::{FfprobeFormat, FfprobeStream, MediaFile, ProbeData};\n\n/// Получение метаданных медиафайла с помощью FFmpeg\n#[command]\npub fn get_media_metadata(file_path: String) -\u003e Result\u003cMediaFile, String\u003e {\n  // Проверяем наличие FFmpeg\n  check_ffmpeg()?;\n\n  // Проверяем существование файла\n  if !Path::new(\u0026file_path).exists() {\n    return Err(format!(\"Файл не найден: {}\", file_path));\n  }\n\n  // Получаем информацию о файле в формате JSON\n  let output = Command::new(\"ffprobe\")\n    .args([\n      \"-v\",\n      \"quiet\",\n      \"-print_format\",\n      \"json\",\n      \"-show_format\",\n      \"-show_streams\",\n      \u0026file_path,\n    ])\n    .output()\n    .map_err(|e| format!(\"Ошибка выполнения ffprobe: {}\", e))?;\n\n  let output_str =\n    str::from_utf8(\u0026output.stdout).map_err(|e| format!(\"Ошибка декодирования вывода: {}\", e))?;\n\n  // Парсим JSON\n  let probe_data: serde_json::Value =\n    serde_json::from_str(output_str).map_err(|e| format!(\"Ошибка парсинга JSON: {}\", e))?;\n\n  // Получаем имя файла из пути\n  let file_name = Path::new(\u0026file_path)\n    .file_name()\n    .and_then(|name| name.to_str())\n    .unwrap_or(\"unknown\")\n    .to_string();\n\n  // Определяем тип медиафайла\n  let streams = probe_data[\"streams\"].as_array();\n  let format = probe_data[\"format\"].as_object();\n\n  // Флаги для типа файла\n  let mut is_video = false;\n  let mut is_audio = false;\n  let mut is_image = false;\n\n  // Создаем структуры для потоков и формата\n  let mut ffprobe_streams: Vec\u003cFfprobeStream\u003e = Vec::new();\n  let mut ffprobe_format = FfprobeFormat {\n    duration: None,\n    size: None,\n    bit_rate: None,\n    format_name: None,\n  };\n\n  if let (Some(streams_array), Some(format_obj)) = (streams, format) {\n    // Заполняем информацию о формате\n    parse_format_data(format_obj, \u0026mut ffprobe_format);\n\n    // Обрабатываем потоки\n    for (i, stream) in streams_array.iter().enumerate() {\n      let parsed_stream = parse_stream_data(stream, i);\n\n      // Определяем тип файла\n      if parsed_stream.codec_type == \"video\"\n        \u0026\u0026 stream\n          .get(\"disposition\")\n          .and_then(|d| d.get(\"attached_pic\"))\n          .and_then(|v| v.as_i64())\n          != Some(1)\n      {\n        is_video = true;\n      } else if parsed_stream.codec_type == \"audio\" {\n        is_audio = true;\n      }\n\n      ffprobe_streams.push(parsed_stream);\n    }\n\n    // Если нет видео и аудио, но есть размеры, считаем изображением\n    if !is_video \u0026\u0026 !is_audio \u0026\u0026 !ffprobe_streams.is_empty() {\n      if let (Some(_width), Some(_height)) = (ffprobe_streams[0].width, ffprobe_streams[0].height) {\n        is_image = true;\n      }\n    }\n  }\n\n  // Определяем время создания\n  let creation_time = extract_creation_time(format);\n\n  // Получаем текущее время в формате ISO 8601\n  let now = SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap_or_default()\n    .as_secs();\n\n  // Создаем структуру MediaFile\n  let media_file = MediaFile {\n    id: file_path.clone(),\n    name: file_name,\n    path: file_path,\n    is_video,\n    is_audio,\n    is_image,\n    size: ffprobe_format.size.unwrap_or(0),\n    duration: ffprobe_format.duration,\n    start_time: now,\n    creation_time: creation_time.unwrap_or_else(generate_iso8601_timestamp),\n    probe_data: ProbeData {\n      streams: ffprobe_streams,\n      format: ffprobe_format,\n    },\n  };\n\n  Ok(media_file)\n}\n\n/// Парсит данные формата из JSON\nfn parse_format_data(\n  format_obj: \u0026serde_json::Map\u003cString, serde_json::Value\u003e,\n  ffprobe_format: \u0026mut FfprobeFormat,\n) {\n  ffprobe_format.duration = format_obj\n    .get(\"duration\")\n    .and_then(|v| v.as_str())\n    .and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n  ffprobe_format.size = format_obj\n    .get(\"size\")\n    .and_then(|v| v.as_str())\n    .and_then(|s| s.parse::\u003cu64\u003e().ok());\n\n  ffprobe_format.bit_rate = format_obj\n    .get(\"bit_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  ffprobe_format.format_name = format_obj\n    .get(\"format_name\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n}\n\n/// Парсит данные потока из JSON\nfn parse_stream_data(stream: \u0026serde_json::Value, index: usize) -\u003e FfprobeStream {\n  let stream_index = stream\n    .get(\"index\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u32)\n    .unwrap_or(index as u32);\n\n  let codec_type = stream\n    .get(\"codec_type\")\n    .and_then(|v| v.as_str())\n    .unwrap_or(\"unknown\")\n    .to_string();\n\n  let codec_name = stream\n    .get(\"codec_name\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let width = stream\n    .get(\"width\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u32);\n\n  let height = stream\n    .get(\"height\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u32);\n\n  let bit_rate = stream\n    .get(\"bit_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let r_frame_rate = stream\n    .get(\"r_frame_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let sample_rate = stream\n    .get(\"sample_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let channels = stream\n    .get(\"channels\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u8);\n\n  let display_aspect_ratio = stream\n    .get(\"display_aspect_ratio\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  FfprobeStream {\n    index: stream_index,\n    codec_type,\n    codec_name,\n    width,\n    height,\n    bit_rate,\n    r_frame_rate,\n    sample_rate,\n    channels,\n    display_aspect_ratio,\n  }\n}\n\n/// Извлекает время создания из метаданных формата\nfn extract_creation_time(\n  format: Option\u003c\u0026serde_json::Map\u003cString, serde_json::Value\u003e\u003e,\n) -\u003e Option\u003cString\u003e {\n  format?\n    .get(\"tags\")\n    .and_then(|tags| tags.get(\"creation_time\"))\n    .and_then(|v| v.as_str())\n    .map(String::from)\n}\n\n/// Генерирует текущее время в формате ISO 8601\nfn generate_iso8601_timestamp() -\u003e String {\n  let now = SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap_or_default();\n\n  let secs = now.as_secs();\n  let nanos = now.subsec_nanos();\n\n  format!(\"{}.{:09}Z\", secs, nanos)\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":8}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":7}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":11}},{"line":162,"address":[],"length":0,"stats":{"Line":11}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":9}},{"line":179,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":9}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":9}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":9}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":9}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":3}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}}],"covered":62,"coverable":89},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","mod.rs"],"content":"// Модуль для работы с медиафайлами\n// Экспортируем публичные типы и функции\n\npub mod ffmpeg;\npub mod files;\npub mod metadata;\npub mod types;\n\n// Реэкспортируем основные типы для удобства использования\npub use files::get_media_files;\npub use metadata::get_media_metadata;\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::{get_media_files, get_media_metadata};\n    use crate::media::types::{MediaFile, ProbeData};\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_get_media_metadata_mp4() {\n        // This test requires FFprobe to be installed\n        if std::process::Command::new(\"ffprobe\")\n            .arg(\"-version\")\n            .output()\n            .is_err()\n        {\n            eprintln!(\"Skipping test: ffprobe not found\");\n            return;\n        }\n\n        // Create a mock video file path\n        let result = get_media_metadata(\"/nonexistent/video.mp4\".to_string());\n        \n        // Should handle non-existent file gracefully\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Файл не найден\"));\n    }\n\n    #[test]\n    fn test_get_media_files_empty_directory() {\n        let temp_dir = TempDir::new().unwrap();\n        let result = get_media_files(temp_dir.path().to_str().unwrap().to_string());\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 0);\n    }\n\n    #[test]\n    fn test_get_media_files_with_video_files() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create some test files\n        let video_extensions = vec![\"mp4\", \"avi\", \"mkv\", \"mov\"];\n        for ext in \u0026video_extensions {\n            let file_path = temp_dir.path().join(format!(\"test.{}\", ext));\n            std::fs::write(\u0026file_path, b\"dummy content\").unwrap();\n        }\n        \n        // Create a non-video file that should be ignored\n        let txt_file = temp_dir.path().join(\"readme.txt\");\n        std::fs::write(\u0026txt_file, b\"text content\").unwrap();\n        \n        let result = get_media_files(temp_dir.path().to_str().unwrap().to_string());\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), video_extensions.len());\n        \n        // Check that all files have video extensions\n        for file in \u0026files {\n            let has_video_ext = video_extensions.iter().any(|ext| file.ends_with(ext));\n            assert!(has_video_ext);\n        }\n    }\n\n    #[test]\n    fn test_get_media_files_nonexistent_directory() {\n        let result = get_media_files(\"/nonexistent/directory\".to_string());\n        \n        // Should return error\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Директория не найдена\"));\n    }\n\n    #[test]\n    fn test_media_file_structure() {\n        use crate::media::types::{FfprobeFormat, FfprobeStream};\n        \n        // Test the MediaFile structure serialization  \n        let media_file = MediaFile {\n            id: \"test-id\".to_string(),\n            path: \"/test/video.mp4\".to_string(),\n            name: \"video.mp4\".to_string(),\n            size: 1024,\n            duration: Some(60.0),\n            is_video: true,\n            is_audio: false,\n            is_image: false,\n            start_time: 0,\n            creation_time: \"2023-01-01T00:00:00Z\".to_string(),\n            probe_data: ProbeData {\n                streams: vec![\n                    FfprobeStream {\n                        index: 0,\n                        codec_type: \"video\".to_string(),\n                        codec_name: Some(\"h264\".to_string()),\n                        width: Some(1920),\n                        height: Some(1080),\n                        bit_rate: Some(\"5000000\".to_string()),\n                        r_frame_rate: Some(\"30/1\".to_string()),\n                        sample_rate: None,\n                        channels: None,\n                        display_aspect_ratio: Some(\"16:9\".to_string()),\n                    }\n                ],\n                format: FfprobeFormat {\n                    duration: Some(60.0),\n                    size: Some(1024),\n                    bit_rate: Some(\"5000000\".to_string()),\n                    format_name: Some(\"mov,mp4,m4a,3gp,3g2,mj2\".to_string()),\n                },\n            },\n        };\n        \n        let json = serde_json::to_string(\u0026media_file).unwrap();\n        assert!(json.contains(\"\\\"path\\\"\"));\n        assert!(json.contains(\"\\\"probe_data\\\"\"));\n        assert!(json.contains(\"\\\"is_video\\\":true\"));\n    }\n\n    #[test]\n    fn test_supported_extensions() {\n        use crate::media::types::SUPPORTED_EXTENSIONS;\n        \n        // Test that common video extensions are supported\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mp4\"));\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"avi\"));\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mkv\"));\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mov\"));\n        \n        // Test that non-video extensions are not supported\n        assert!(!SUPPORTED_EXTENSIONS.contains(\u0026\"txt\"));\n        assert!(!SUPPORTED_EXTENSIONS.contains(\u0026\"doc\"));\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","types.rs"],"content":"// Типы данных для работы с медиафайлами\n\nuse serde::{Deserialize, Serialize};\n\n/// Структура для хранения метаданных видео\n#[derive(Debug, Serialize, Deserialize)]\npub struct VideoMetadata {\n  pub duration: Option\u003cf64\u003e,\n  pub width: Option\u003cu32\u003e,\n  pub height: Option\u003cu32\u003e,\n  pub fps: Option\u003cf64\u003e,\n  pub codec: Option\u003cString\u003e,\n  pub bitrate: Option\u003cu64\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub creation_time: Option\u003cString\u003e,\n}\n\n/// Структура для хранения метаданных аудио\n#[derive(Debug, Serialize, Deserialize)]\npub struct AudioMetadata {\n  pub duration: Option\u003cf64\u003e,\n  pub codec: Option\u003cString\u003e,\n  pub bitrate: Option\u003cu64\u003e,\n  pub sample_rate: Option\u003cu32\u003e,\n  pub channels: Option\u003cu8\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub creation_time: Option\u003cString\u003e,\n}\n\n/// Структура для хранения метаданных изображения\n#[derive(Debug, Serialize, Deserialize)]\npub struct ImageMetadata {\n  pub width: Option\u003cu32\u003e,\n  pub height: Option\u003cu32\u003e,\n  pub format: Option\u003cString\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub creation_time: Option\u003cString\u003e,\n}\n\n/// Перечисление для типов медиафайлов\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum MediaMetadata {\n  Video(VideoMetadata),\n  Audio(AudioMetadata),\n  Image(ImageMetadata),\n  Unknown,\n}\n\n/// Структура для потока в формате FFprobe\n#[derive(Debug, Serialize, Deserialize)]\npub struct FfprobeStream {\n  pub index: u32,\n  pub codec_type: String,\n  pub codec_name: Option\u003cString\u003e,\n  pub width: Option\u003cu32\u003e,\n  pub height: Option\u003cu32\u003e,\n  pub bit_rate: Option\u003cString\u003e,\n  pub r_frame_rate: Option\u003cString\u003e,\n  pub sample_rate: Option\u003cString\u003e,\n  pub channels: Option\u003cu8\u003e,\n  pub display_aspect_ratio: Option\u003cString\u003e,\n}\n\n/// Структура для формата в формате FFprobe\n#[derive(Debug, Serialize, Deserialize)]\npub struct FfprobeFormat {\n  pub duration: Option\u003cf64\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub bit_rate: Option\u003cString\u003e,\n  pub format_name: Option\u003cString\u003e,\n}\n\n/// Структура для хранения данных FFprobe\n#[derive(Debug, Serialize, Deserialize)]\npub struct ProbeData {\n  pub streams: Vec\u003cFfprobeStream\u003e,\n  pub format: FfprobeFormat,\n}\n\n/// Структура для медиафайла\n#[derive(Debug, Serialize, Deserialize)]\npub struct MediaFile {\n  pub id: String,\n  pub name: String,\n  pub path: String,\n  pub is_video: bool,\n  pub is_audio: bool,\n  pub is_image: bool,\n  pub size: u64,\n  pub duration: Option\u003cf64\u003e,\n  pub start_time: u64,\n  pub creation_time: String,\n  pub probe_data: ProbeData,\n}\n\n/// Поддерживаемые расширения медиафайлов\npub const SUPPORTED_EXTENSIONS: \u0026[\u0026str] = \u0026[\n  // Видео\n  \"mp4\", \"avi\", \"mkv\", \"mov\", \"webm\", // Аудио\n  \"mp3\", \"wav\", \"ogg\", \"flac\", // Изображения\n  \"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\",\n];\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_media_file_structure_serialization() {\n    // Тестируем сериализацию/десериализацию структур\n    let stream = FfprobeStream {\n      index: 0,\n      codec_type: \"video\".to_string(),\n      codec_name: Some(\"h264\".to_string()),\n      width: Some(1920),\n      height: Some(1080),\n      bit_rate: Some(\"5000000\".to_string()),\n      r_frame_rate: Some(\"30/1\".to_string()),\n      sample_rate: None,\n      channels: None,\n      display_aspect_ratio: Some(\"16:9\".to_string()),\n    };\n\n    let format = FfprobeFormat {\n      duration: Some(120.5),\n      size: Some(1024000),\n      bit_rate: Some(\"5000000\".to_string()),\n      format_name: Some(\"mov,mp4,m4a,3gp,3g2,mj2\".to_string()),\n    };\n\n    let probe_data = ProbeData {\n      streams: vec![stream],\n      format,\n    };\n\n    let media_file = MediaFile {\n      id: \"test_id\".to_string(),\n      name: \"test.mp4\".to_string(),\n      path: \"/path/to/test.mp4\".to_string(),\n      is_video: true,\n      is_audio: false,\n      is_image: false,\n      size: 1024000,\n      duration: Some(120.5),\n      start_time: 1234567890,\n      creation_time: \"2023-01-01T00:00:00Z\".to_string(),\n      probe_data,\n    };\n\n    // Тестируем сериализацию в JSON\n    let json = serde_json::to_string(\u0026media_file);\n    assert!(json.is_ok());\n\n    // Тестируем десериализацию из JSON\n    let json_str = json.unwrap();\n    let deserialized: Result\u003cMediaFile, _\u003e = serde_json::from_str(\u0026json_str);\n    assert!(deserialized.is_ok());\n\n    let deserialized_file = deserialized.unwrap();\n    assert_eq!(deserialized_file.name, \"test.mp4\");\n    assert!(deserialized_file.is_video);\n    assert_eq!(deserialized_file.probe_data.streams.len(), 1);\n    assert_eq!(deserialized_file.probe_data.streams[0].codec_type, \"video\");\n  }\n\n  #[test]\n  fn test_media_metadata_enum() {\n    // Тестируем перечисление MediaMetadata\n    let video_metadata = VideoMetadata {\n      duration: Some(120.0),\n      width: Some(1920),\n      height: Some(1080),\n      fps: Some(30.0),\n      codec: Some(\"h264\".to_string()),\n      bitrate: Some(5000000),\n      size: Some(1024000),\n      creation_time: Some(\"2023-01-01T00:00:00Z\".to_string()),\n    };\n\n    let media_metadata = MediaMetadata::Video(video_metadata);\n\n    // Тестируем сериализацию\n    let json = serde_json::to_string(\u0026media_metadata);\n    assert!(json.is_ok());\n\n    // Проверяем, что JSON содержит тег типа\n    let json_str = json.unwrap();\n    assert!(json_str.contains(\"\\\"type\\\":\\\"Video\\\"\"));\n  }\n\n  #[test]\n  fn test_supported_extensions() {\n    // Проверяем, что константа содержит ожидаемые расширения\n    assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mp4\"));\n    assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mp3\"));\n    assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"jpg\"));\n    assert!(!SUPPORTED_EXTENSIONS.contains(\u0026\"txt\"));\n  }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","cache","tests.rs"],"content":"//! Тесты для модуля кэширования Video Compiler\n\nuse super::*;\nuse std::time::Duration;\n\n#[tokio::test]\nasync fn test_cache_creation() {\n  let cache = RenderCache::new();\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 0);\n  assert_eq!(stats.metadata_requests, 0);\n  assert_eq!(stats.render_requests, 0);\n}\n\n#[tokio::test]\nasync fn test_cache_with_custom_settings() {\n  let settings = CacheSettings {\n    max_preview_entries: 50,\n    max_metadata_entries: 25,\n    max_render_entries: 10,\n    max_memory_mb: 256,\n    preview_ttl: Duration::from_secs(1800),\n    metadata_ttl: Duration::from_secs(900),\n    render_ttl: Duration::from_secs(3600),\n  };\n  let cache = RenderCache::with_settings(settings.clone());\n  assert_eq!(cache.settings.max_preview_entries, 50);\n  assert_eq!(cache.settings.max_memory_mb, 256);\n}\n\n#[tokio::test]\nasync fn test_preview_cache() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n  let image_data = vec![1, 2, 3, 4, 5];\n\n  // Сохраняем превью\n  cache\n    .store_preview(key.clone(), image_data.clone())\n    .await\n    .unwrap();\n\n  // Получаем превью\n  let cached_data = cache.get_preview(\u0026key).await;\n  assert!(cached_data.is_some());\n  assert_eq!(cached_data.unwrap().image_data, image_data);\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 1);\n  assert_eq!(stats.preview_hits, 1);\n  assert_eq!(stats.preview_misses, 0);\n}\n\n#[tokio::test]\nasync fn test_preview_cache_miss() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n\n  // Пытаемся получить несуществующее превью\n  let cached_data = cache.get_preview(\u0026key).await;\n  assert!(cached_data.is_none());\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 1);\n  assert_eq!(stats.preview_hits, 0);\n  assert_eq!(stats.preview_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_metadata_cache() {\n  let mut cache = RenderCache::new();\n  let file_path = \"/test/video.mp4\".to_string();\n  let metadata = MediaMetadata {\n    file_path: file_path.clone(),\n    file_size: 1024000,\n    modified_time: SystemTime::now(),\n    duration: 120.0,\n    resolution: Some((1920, 1080)),\n    fps: Some(30.0),\n    bitrate: Some(8000000),\n    video_codec: Some(\"h264\".to_string()),\n    audio_codec: Some(\"aac\".to_string()),\n    cached_at: SystemTime::now(),\n  };\n\n  // Сохраняем метаданные\n  cache\n    .store_metadata(file_path.clone(), metadata.clone())\n    .await\n    .unwrap();\n\n  // Получаем метаданные\n  let cached_metadata = cache.get_metadata(\u0026file_path).await;\n  assert!(cached_metadata.is_some());\n  assert_eq!(cached_metadata.unwrap().duration, 120.0);\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.metadata_requests, 1);\n  assert_eq!(stats.metadata_hits, 1);\n}\n\n#[tokio::test]\nasync fn test_metadata_cache_miss() {\n  let mut cache = RenderCache::new();\n  \n  // Пытаемся получить несуществующие метаданные\n  let cached_metadata = cache.get_metadata(\"/nonexistent.mp4\").await;\n  assert!(cached_metadata.is_none());\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.metadata_requests, 1);\n  assert_eq!(stats.metadata_hits, 0);\n  assert_eq!(stats.metadata_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_render_cache() {\n  let mut cache = RenderCache::new();\n  let cache_key = \"render_job_123\".to_string();\n  let render_data = RenderCacheData {\n    cache_key: cache_key.clone(),\n    output_path: PathBuf::from(\"/output/render.mp4\"),\n    render_hash: \"abc123def456\".to_string(),\n    created_at: SystemTime::now(),\n    file_size: 5000000,\n  };\n\n  // Сохраняем данные рендеринга\n  cache\n    .store_render_data(cache_key.clone(), render_data.clone())\n    .await\n    .unwrap();\n\n  // Получаем данные рендеринга\n  let cached_render = cache.get_render_data(\u0026cache_key).await;\n  assert!(cached_render.is_some());\n  assert_eq!(cached_render.unwrap().render_hash, \"abc123def456\");\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.render_requests, 1);\n  assert_eq!(stats.render_hits, 1);\n}\n\n#[tokio::test]\nasync fn test_render_cache_miss() {\n  let mut cache = RenderCache::new();\n  \n  // Пытаемся получить несуществующие данные рендеринга\n  let cached_render = cache.get_render_data(\"nonexistent_job\").await;\n  assert!(cached_render.is_none());\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.render_requests, 1);\n  assert_eq!(stats.render_hits, 0);\n  assert_eq!(stats.render_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_cache_expiration() {\n  let settings = CacheSettings {\n    preview_ttl: Duration::from_millis(10), // Очень короткий TTL для теста\n    metadata_ttl: Duration::from_millis(10),\n    render_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 5.0, (320, 180), 50);\n  let image_data = vec![10, 20, 30];\n\n  // Сохраняем превью\n  cache.store_preview(key.clone(), image_data).await.unwrap();\n\n  // Сразу должно быть доступно\n  assert!(cache.get_preview(\u0026key).await.is_some());\n\n  // Ждем истечения TTL\n  tokio::time::sleep(Duration::from_millis(20)).await;\n\n  // Теперь должно быть недоступно\n  assert!(cache.get_preview(\u0026key).await.is_none());\n}\n\n#[tokio::test]\nasync fn test_metadata_expiration() {\n  let settings = CacheSettings {\n    metadata_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  let metadata = MediaMetadata {\n    file_path: \"/test/video.mp4\".to_string(),\n    file_size: 1024,\n    modified_time: SystemTime::now(),\n    duration: 60.0,\n    resolution: None,\n    fps: None,\n    bitrate: None,\n    video_codec: None,\n    audio_codec: None,\n    cached_at: SystemTime::now(),\n  };\n\n  cache.store_metadata(\"/test/video.mp4\".to_string(), metadata).await.unwrap();\n  assert!(cache.get_metadata(\"/test/video.mp4\").await.is_some());\n\n  tokio::time::sleep(Duration::from_millis(20)).await;\n  assert!(cache.get_metadata(\"/test/video.mp4\").await.is_none());\n}\n\n#[tokio::test]\nasync fn test_render_data_expiration() {\n  let settings = CacheSettings {\n    render_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  let render_data = RenderCacheData {\n    cache_key: \"job_123\".to_string(),\n    output_path: PathBuf::from(\"/output.mp4\"),\n    render_hash: \"hash123\".to_string(),\n    created_at: SystemTime::now(),\n    file_size: 1000,\n  };\n\n  cache.store_render_data(\"job_123\".to_string(), render_data).await.unwrap();\n  assert!(cache.get_render_data(\"job_123\").await.is_some());\n\n  tokio::time::sleep(Duration::from_millis(20)).await;\n  assert!(cache.get_render_data(\"job_123\").await.is_none());\n}\n\n#[tokio::test]\nasync fn test_cache_stats() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 1.0, (640, 360), 75);\n\n  // Промах\n  cache.get_preview(\u0026key).await;\n\n  // Сохраняем и попадание\n  cache\n    .store_preview(key.clone(), vec![1, 2, 3])\n    .await\n    .unwrap();\n  cache.get_preview(\u0026key).await;\n\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 2);\n  assert_eq!(stats.preview_hits, 1);\n  assert_eq!(stats.preview_misses, 1);\n  assert_eq!(stats.preview_hit_ratio(), 0.5);\n}\n\n#[tokio::test]\nasync fn test_cache_stats_hit_ratios() {\n  let cache = RenderCache::new();\n  let stats = cache.get_stats();\n\n  // При нулевых запросах hit ratio должен быть 0\n  assert_eq!(stats.hit_ratio(), 0.0);\n  assert_eq!(stats.preview_hit_ratio(), 0.0);\n}\n\n#[tokio::test]\nasync fn test_memory_usage() {\n  let cache = RenderCache::new();\n  let usage = cache.get_memory_usage();\n\n  assert_eq!(\n    usage.total_bytes,\n    usage.preview_bytes + usage.metadata_bytes + usage.render_bytes\n  );\n  assert!(usage.total_mb() \u003e= 0.0);\n}\n\n#[tokio::test]\nasync fn test_cache_clear() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 2.0, (640, 360), 75);\n\n  // Добавляем данные\n  cache\n    .store_preview(key.clone(), vec![1, 2, 3])\n    .await\n    .unwrap();\n  assert!(cache.get_preview(\u0026key).await.is_some());\n\n  // Очищаем превью\n  cache.clear_previews().await;\n  assert!(cache.get_preview(\u0026key).await.is_none());\n}\n\n#[tokio::test]\nasync fn test_cache_clear_all() {\n  let mut cache = RenderCache::new();\n  \n  // Добавляем различные данные\n  let preview_key = PreviewKey::new(\"/test1.mp4\".to_string(), 1.0, (640, 360), 75);\n  cache.store_preview(preview_key.clone(), vec![1, 2, 3]).await.unwrap();\n  \n  let metadata = MediaMetadata {\n    file_path: \"/test2.mp4\".to_string(),\n    file_size: 1024,\n    modified_time: SystemTime::now(),\n    duration: 60.0,\n    resolution: None,\n    fps: None,\n    bitrate: None,\n    video_codec: None,\n    audio_codec: None,\n    cached_at: SystemTime::now(),\n  };\n  cache.store_metadata(\"/test2.mp4\".to_string(), metadata).await.unwrap();\n  \n  let render_data = RenderCacheData {\n    cache_key: \"job_456\".to_string(),\n    output_path: PathBuf::from(\"/output.mp4\"),\n    render_hash: \"hash456\".to_string(),\n    created_at: SystemTime::now(),\n    file_size: 2000,\n  };\n  cache.store_render_data(\"job_456\".to_string(), render_data).await.unwrap();\n  \n  // Проверяем что все данные есть\n  assert!(cache.get_preview(\u0026preview_key).await.is_some());\n  assert!(cache.get_metadata(\"/test2.mp4\").await.is_some());\n  assert!(cache.get_render_data(\"job_456\").await.is_some());\n  \n  // Очищаем весь кэш\n  cache.clear_all().await;\n  \n  // Проверяем что все данные удалены\n  assert!(cache.get_preview(\u0026preview_key).await.is_none());\n  assert!(cache.get_metadata(\"/test2.mp4\").await.is_none());\n  assert!(cache.get_render_data(\"job_456\").await.is_none());\n  \n  // Статистика должна быть сброшена\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 1); // один после clear_all\n  assert_eq!(stats.preview_hits, 0);\n  assert_eq!(stats.preview_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_cleanup_old_entries() {\n  let settings = CacheSettings {\n    preview_ttl: Duration::from_millis(10),\n    metadata_ttl: Duration::from_millis(10),\n    render_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  // Добавляем данные\n  let key1 = PreviewKey::new(\"/test1.mp4\".to_string(), 1.0, (640, 360), 75);\n  let key2 = PreviewKey::new(\"/test2.mp4\".to_string(), 2.0, (640, 360), 75);\n  cache.store_preview(key1.clone(), vec![1, 2, 3]).await.unwrap();\n  \n  // Ждем истечения TTL для первого элемента\n  tokio::time::sleep(Duration::from_millis(15)).await;\n  \n  // Добавляем второй элемент\n  cache.store_preview(key2.clone(), vec![4, 5, 6]).await.unwrap();\n  \n  // Вызываем очистку\n  cache.cleanup_old_entries().await.unwrap();\n  \n  // Первый должен быть удален, второй остаться\n  assert!(cache.get_preview(\u0026key1).await.is_none());\n  assert!(cache.get_preview(\u0026key2).await.is_some());\n}\n\n#[tokio::test]\nasync fn test_cleanup_if_needed_with_memory_limit() {\n  let settings = CacheSettings {\n    max_memory_mb: 1, // Очень маленький лимит памяти для теста\n    max_preview_entries: 10000,\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  // Добавляем много больших превью чтобы превысить лимит памяти\n  for i in 0..100 {\n    let key = PreviewKey::new(format!(\"/test{}.mp4\", i), i as f64, (1920, 1080), 90);\n    let large_data = vec![0u8; 100000]; // 100KB на превью\n    cache.store_preview(key, large_data).await.unwrap();\n  }\n\n  // cleanup_if_needed должен был быть вызван автоматически\n  let usage = cache.get_memory_usage();\n  // Проверяем что память не превышает сильно установленный лимит\n  assert!(usage.total_mb() \u003c 10.0); // Даем запас на накладные расходы\n}\n\n#[test]\nfn test_preview_key_creation() {\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (1920, 1080), 90);\n  assert_eq!(key.file_path, \"/test/video.mp4\");\n  assert_eq!(key.timestamp, 10500); // 10.5 * 1000\n  assert_eq!(key.resolution, (1920, 1080));\n  assert_eq!(key.quality, 90);\n}\n\n#[test]\nfn test_preview_key_equality_and_hash() {\n  let key1 = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (1920, 1080), 90);\n  let key2 = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (1920, 1080), 90);\n  let key3 = PreviewKey::new(\"/test/video.mp4\".to_string(), 11.0, (1920, 1080), 90);\n  \n  assert_eq!(key1, key2);\n  assert_ne!(key1, key3);\n  \n  // Проверяем что ключи можно использовать в HashMap\n  let mut map = std::collections::HashMap::new();\n  map.insert(key1.clone(), \"value1\");\n  assert_eq!(map.get(\u0026key2), Some(\u0026\"value1\"));\n}\n\n#[test]\nfn test_preview_data_is_expired() {\n  let data = PreviewData {\n    image_data: vec![1, 2, 3],\n    timestamp: SystemTime::now() - Duration::from_secs(3600),\n    access_count: 5,\n  };\n\n  assert!(data.is_expired(Duration::from_secs(1800))); // 30 минут - истек\n  assert!(!data.is_expired(Duration::from_secs(7200))); // 2 часа - не истек\n}\n\n#[test]\nfn test_media_metadata_is_expired() {\n  let metadata = MediaMetadata {\n    file_path: \"/test.mp4\".to_string(),\n    file_size: 1024,\n    modified_time: SystemTime::now(),\n    duration: 60.0,\n    resolution: None,\n    fps: None,\n    bitrate: None,\n    video_codec: None,\n    audio_codec: None,\n    cached_at: SystemTime::now() - Duration::from_secs(1800),\n  };\n\n  assert!(metadata.is_expired(Duration::from_secs(900))); // 15 минут - истек\n  assert!(!metadata.is_expired(Duration::from_secs(3600))); // 1 час - не истек\n}\n\n#[test]\nfn test_render_cache_data_is_expired() {\n  let data = RenderCacheData {\n    cache_key: \"job_123\".to_string(),\n    output_path: PathBuf::from(\"/output.mp4\"),\n    render_hash: \"hash123\".to_string(),\n    created_at: SystemTime::now() - Duration::from_secs(7200),\n    file_size: 1000,\n  };\n\n  assert!(data.is_expired(Duration::from_secs(3600))); // 1 час - истек\n  assert!(!data.is_expired(Duration::from_secs(14400))); // 4 часа - не истек\n}\n\n#[test]\nfn test_cache_settings_default() {\n  let settings = CacheSettings::default();\n  assert_eq!(settings.max_preview_entries, 1000);\n  assert_eq!(settings.max_metadata_entries, 500);\n  assert_eq!(settings.max_render_entries, 100);\n  assert_eq!(settings.max_memory_mb, 512);\n  assert_eq!(settings.preview_ttl, Duration::from_secs(3600));\n  assert_eq!(settings.metadata_ttl, Duration::from_secs(1800));\n  assert_eq!(settings.render_ttl, Duration::from_secs(7200));\n}\n\n#[test]\nfn test_render_cache_default() {\n  let cache = RenderCache::default();\n  assert_eq!(cache.settings.max_preview_entries, 1000);\n}\n\n#[test]\nfn test_cache_memory_usage_total_mb() {\n  let usage = CacheMemoryUsage {\n    preview_bytes: 1024 * 1024 * 10, // 10 MB\n    metadata_bytes: 1024 * 1024 * 5, // 5 MB\n    render_bytes: 1024 * 1024 * 15,  // 15 MB\n    total_bytes: 1024 * 1024 * 30,   // 30 MB\n  };\n  \n  assert_eq!(usage.total_mb(), 30.0);\n}\n\n#[test]\nfn test_lru_cache() {\n  let mut lru = LruCache::new(2);\n\n  lru.insert(\"key1\".to_string(), \"value1\".to_string());\n  lru.insert(\"key2\".to_string(), \"value2\".to_string());\n\n  assert_eq!(lru.get(\u0026\"key1\".to_string()), Some(\"value1\".to_string()));\n\n  // Добавляем третий элемент, должен вытеснить самый старый\n  lru.insert(\"key3\".to_string(), \"value3\".to_string());\n\n  // key3 должен быть доступен\n  assert!(lru.get(\u0026\"key3\".to_string()).is_some());\n}\n\n#[test]\nfn test_lru_cache_remove() {\n  let mut lru = LruCache::new(5);\n  \n  lru.insert(\"key1\".to_string(), \"value1\".to_string());\n  lru.insert(\"key2\".to_string(), \"value2\".to_string());\n  \n  // Удаляем элемент\n  let removed = lru.remove(\u0026\"key1\".to_string());\n  assert_eq!(removed, Some(\"value1\".to_string()));\n  \n  // Проверяем что элемент удален\n  assert_eq!(lru.get(\u0026\"key1\".to_string()), None);\n  assert_eq!(lru.get(\u0026\"key2\".to_string()), Some(\"value2\".to_string()));\n}\n\n#[test]\nfn test_lru_cache_clear() {\n  let mut lru = LruCache::new(5);\n  \n  lru.insert(\"key1\".to_string(), \"value1\".to_string());\n  lru.insert(\"key2\".to_string(), \"value2\".to_string());\n  lru.insert(\"key3\".to_string(), \"value3\".to_string());\n  \n  lru.clear();\n  \n  assert_eq!(lru.get(\u0026\"key1\".to_string()), None);\n  assert_eq!(lru.get(\u0026\"key2\".to_string()), None);\n  assert_eq!(lru.get(\u0026\"key3\".to_string()), None);\n}\n\n#[test]\nfn test_lru_cache_retain() {\n  let mut lru = LruCache::new(5);\n  \n  lru.insert(1, 10);\n  lru.insert(2, 20);\n  lru.insert(3, 30);\n  lru.insert(4, 40);\n  \n  // Оставляем только четные значения\n  lru.retain(|_k, v| v % 20 == 0);\n  \n  assert_eq!(lru.get(\u00261), None);\n  assert_eq!(lru.get(\u00262), Some(20));\n  assert_eq!(lru.get(\u00263), None);\n  assert_eq!(lru.get(\u00264), Some(40));\n}\n\n#[test]\nfn test_lru_cache_memory_estimate() {\n  let lru: LruCache\u003cString, String\u003e = LruCache::new(100);\n  let memory = lru.estimate_memory_usage();\n  assert!(memory \u003e 0);\n}\n\n#[test]\nfn test_lru_cache_capacity_enforcement() {\n  let mut lru = LruCache::new(3);\n  \n  lru.insert(1, \"one\");\n  lru.insert(2, \"two\");\n  lru.insert(3, \"three\");\n  \n  // Все три должны быть доступны\n  assert_eq!(lru.get(\u00261), Some(\"one\"));\n  assert_eq!(lru.get(\u00262), Some(\"two\"));\n  assert_eq!(lru.get(\u00263), Some(\"three\"));\n  \n  // Добавляем четвертый элемент\n  lru.insert(4, \"four\");\n  \n  // Один из старых должен быть удален\n  assert_eq!(lru.get(\u00264), Some(\"four\"));\n  \n  // Проверяем что осталось только 3 элемента\n  let mut count = 0;\n  for i in 1..=4 {\n    if lru.get(\u0026i).is_some() {\n      count += 1;\n    }\n  }\n  assert_eq!(count, 3);\n}\n\n#[test] \nfn test_cache_stats_serialization() {\n  let stats = CacheStats {\n    preview_requests: 100,\n    preview_hits: 80,\n    preview_misses: 20,\n    metadata_requests: 50,\n    metadata_hits: 45,\n    metadata_misses: 5,\n    render_requests: 10,\n    render_hits: 8,\n    render_misses: 2,\n  };\n  \n  let json = serde_json::to_string(\u0026stats).unwrap();\n  assert!(json.contains(\"\\\"preview_requests\\\":100\"));\n  \n  let deserialized: CacheStats = serde_json::from_str(\u0026json).unwrap();\n  assert_eq!(deserialized.preview_hits, 80);\n  assert_eq!(deserialized.metadata_hits, 45);\n}\n\n#[test]\nfn test_media_metadata_serialization() {\n  let metadata = MediaMetadata {\n    file_path: \"/test/video.mp4\".to_string(),\n    file_size: 1024000,\n    modified_time: SystemTime::now(),\n    duration: 120.5,\n    resolution: Some((1920, 1080)),\n    fps: Some(30.0),\n    bitrate: Some(8000000),\n    video_codec: Some(\"h264\".to_string()),\n    audio_codec: Some(\"aac\".to_string()),\n    cached_at: SystemTime::now(),\n  };\n  \n  let json = serde_json::to_string(\u0026metadata).unwrap();\n  assert!(json.contains(\"1024000\"));\n  assert!(json.contains(\"120.5\"));\n  assert!(json.contains(\"1920\"));\n  assert!(json.contains(\"h264\"));\n  \n  let deserialized: MediaMetadata = serde_json::from_str(\u0026json).unwrap();\n  assert_eq!(deserialized.file_path, metadata.file_path);\n  assert_eq!(deserialized.duration, metadata.duration);\n  assert_eq!(deserialized.resolution, metadata.resolution);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","cache.rs"],"content":"//! Cache - Модуль кэширования для Video Compiler\n//!\n//! Этот модуль реализует LRU кэш для превью кадров, промежуточных результатов\n//! рендеринга и метаданных медиа файлов для улучшения производительности.\n\nuse crate::video_compiler::error::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::time::{Duration, SystemTime};\n\n/// Основной кэш Video Compiler\n#[derive(Debug)]\npub struct RenderCache {\n  /// Кэш превью кадров\n  preview_cache: LruCache\u003cPreviewKey, PreviewData\u003e,\n  /// Кэш метаданных файлов\n  metadata_cache: LruCache\u003cString, MediaMetadata\u003e,\n  /// Кэш промежуточных результатов рендеринга\n  render_cache: LruCache\u003cString, RenderCacheData\u003e,\n  /// Настройки кэша\n  settings: CacheSettings,\n  /// Статистика использования\n  stats: CacheStats,\n}\n\nimpl RenderCache {\n  /// Создать новый кэш с настройками по умолчанию\n  pub fn new() -\u003e Self {\n    Self::with_settings(CacheSettings::default())\n  }\n\n  /// Создать новый кэш с указанными настройками\n  pub fn with_settings(settings: CacheSettings) -\u003e Self {\n    Self {\n      preview_cache: LruCache::new(settings.max_preview_entries),\n      metadata_cache: LruCache::new(settings.max_metadata_entries),\n      render_cache: LruCache::new(settings.max_render_entries),\n      settings,\n      stats: CacheStats::default(),\n    }\n  }\n\n  /// Получить превью кадр из кэша\n  pub async fn get_preview(\u0026mut self, key: \u0026PreviewKey) -\u003e Option\u003cPreviewData\u003e {\n    self.stats.preview_requests += 1;\n\n    if let Some(data) = self.preview_cache.get(key) {\n      // Проверяем, не истек ли кэш\n      if !data.is_expired(self.settings.preview_ttl) {\n        self.stats.preview_hits += 1;\n        return Some(data.clone());\n      } else {\n        // Удаляем истекший элемент\n        self.preview_cache.remove(key);\n      }\n    }\n\n    self.stats.preview_misses += 1;\n    None\n  }\n\n  /// Сохранить превью кадр в кэш\n  pub async fn store_preview(\u0026mut self, key: PreviewKey, data: Vec\u003cu8\u003e) -\u003e Result\u003c()\u003e {\n    let preview_data = PreviewData {\n      image_data: data,\n      timestamp: SystemTime::now(),\n      access_count: 0,\n    };\n\n    self.preview_cache.insert(key, preview_data);\n    self.cleanup_if_needed().await?;\n    Ok(())\n  }\n\n  /// Получить метаданные файла из кэша\n  pub async fn get_metadata(\u0026mut self, file_path: \u0026str) -\u003e Option\u003cMediaMetadata\u003e {\n    self.stats.metadata_requests += 1;\n\n    if let Some(metadata) = self.metadata_cache.get(\u0026file_path.to_string()) {\n      if !metadata.is_expired(self.settings.metadata_ttl) {\n        self.stats.metadata_hits += 1;\n        return Some(metadata.clone());\n      } else {\n        self.metadata_cache.remove(\u0026file_path.to_string());\n      }\n    }\n\n    self.stats.metadata_misses += 1;\n    None\n  }\n\n  /// Сохранить метаданные файла в кэш\n  pub async fn store_metadata(\u0026mut self, file_path: String, metadata: MediaMetadata) -\u003e Result\u003c()\u003e {\n    self.metadata_cache.insert(file_path, metadata);\n    self.cleanup_if_needed().await?;\n    Ok(())\n  }\n\n  /// Получить данные рендеринга из кэша\n  pub async fn get_render_data(\u0026mut self, cache_key: \u0026str) -\u003e Option\u003cRenderCacheData\u003e {\n    self.stats.render_requests += 1;\n\n    if let Some(data) = self.render_cache.get(\u0026cache_key.to_string()) {\n      if !data.is_expired(self.settings.render_ttl) {\n        self.stats.render_hits += 1;\n        return Some(data.clone());\n      } else {\n        self.render_cache.remove(\u0026cache_key.to_string());\n      }\n    }\n\n    self.stats.render_misses += 1;\n    None\n  }\n\n  /// Сохранить данные рендеринга в кэш\n  pub async fn store_render_data(\n    \u0026mut self,\n    cache_key: String,\n    data: RenderCacheData,\n  ) -\u003e Result\u003c()\u003e {\n    self.render_cache.insert(cache_key, data);\n    self.cleanup_if_needed().await?;\n    Ok(())\n  }\n\n  /// Очистить весь кэш\n  pub async fn clear_all(\u0026mut self) {\n    self.preview_cache.clear();\n    self.metadata_cache.clear();\n    self.render_cache.clear();\n    self.stats = CacheStats::default();\n  }\n\n  /// Очистить только превью кэш\n  pub async fn clear_previews(\u0026mut self) {\n    self.preview_cache.clear();\n  }\n\n  /// Получить статистику кэша\n  pub fn get_stats(\u0026self) -\u003e \u0026CacheStats {\n    \u0026self.stats\n  }\n\n  /// Получить использование памяти кэшем (приблизительно)\n  pub fn get_memory_usage(\u0026self) -\u003e CacheMemoryUsage {\n    let preview_memory = self.preview_cache.estimate_memory_usage();\n    let metadata_memory = self.metadata_cache.estimate_memory_usage();\n    let render_memory = self.render_cache.estimate_memory_usage();\n\n    CacheMemoryUsage {\n      preview_bytes: preview_memory,\n      metadata_bytes: metadata_memory,\n      render_bytes: render_memory,\n      total_bytes: preview_memory + metadata_memory + render_memory,\n    }\n  }\n\n  /// Очистка кэша при необходимости\n  async fn cleanup_if_needed(\u0026mut self) -\u003e Result\u003c()\u003e {\n    let memory_usage = self.get_memory_usage();\n    let max_memory = self.settings.max_memory_mb * 1024 * 1024;\n\n    if memory_usage.total_bytes \u003e max_memory {\n      log::info!(\"Превышен лимит памяти кэша, выполняется очистка\");\n      self.cleanup_old_entries().await?;\n    }\n\n    Ok(())\n  }\n\n  /// Очистка старых записей\n  async fn cleanup_old_entries(\u0026mut self) -\u003e Result\u003c()\u003e {\n    let _now = SystemTime::now();\n\n    // Очищаем истекшие превью\n    self\n      .preview_cache\n      .retain(|_, data| !data.is_expired(self.settings.preview_ttl));\n\n    // Очищаем истекшие метаданные\n    self\n      .metadata_cache\n      .retain(|_, metadata| !metadata.is_expired(self.settings.metadata_ttl));\n\n    // Очищаем истекшие данные рендеринга\n    self\n      .render_cache\n      .retain(|_, data| !data.is_expired(self.settings.render_ttl));\n\n    Ok(())\n  }\n}\n\nimpl Default for RenderCache {\n  fn default() -\u003e Self {\n    Self::new()\n  }\n}\n\n/// Ключ для кэша превью\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\npub struct PreviewKey {\n  /// Путь к файлу\n  pub file_path: String,\n  /// Временная метка (секунды)\n  pub timestamp: u64,\n  /// Разрешение превью\n  pub resolution: (u32, u32),\n  /// Качество превью\n  pub quality: u8,\n}\n\nimpl PreviewKey {\n  pub fn new(file_path: String, timestamp: f64, resolution: (u32, u32), quality: u8) -\u003e Self {\n    Self {\n      file_path,\n      timestamp: (timestamp * 1000.0) as u64, // Конвертируем в миллисекунды\n      resolution,\n      quality,\n    }\n  }\n}\n\n/// Данные превью кадра\n#[derive(Debug, Clone)]\npub struct PreviewData {\n  /// Данные изображения (JPEG/PNG)\n  pub image_data: Vec\u003cu8\u003e,\n  /// Время создания\n  pub timestamp: SystemTime,\n  /// Количество обращений\n  pub access_count: u64,\n}\n\nimpl PreviewData {\n  /// Проверить, истек ли кэш\n  pub fn is_expired(\u0026self, ttl: Duration) -\u003e bool {\n    self.timestamp.elapsed().unwrap_or(Duration::ZERO) \u003e ttl\n  }\n}\n\n/// Метаданные медиа файла\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MediaMetadata {\n  /// Путь к файлу\n  pub file_path: String,\n  /// Размер файла в байтах\n  pub file_size: u64,\n  /// Время модификации файла\n  pub modified_time: SystemTime,\n  /// Длительность в секундах\n  pub duration: f64,\n  /// Разрешение видео (если есть)\n  pub resolution: Option\u003c(u32, u32)\u003e,\n  /// FPS (если есть)\n  pub fps: Option\u003cf32\u003e,\n  /// Битрейт (bps)\n  pub bitrate: Option\u003cu32\u003e,\n  /// Кодек видео\n  pub video_codec: Option\u003cString\u003e,\n  /// Кодек аудио\n  pub audio_codec: Option\u003cString\u003e,\n  /// Время кэширования\n  pub cached_at: SystemTime,\n}\n\nimpl MediaMetadata {\n  /// Проверить, истек ли кэш\n  pub fn is_expired(\u0026self, ttl: Duration) -\u003e bool {\n    self.cached_at.elapsed().unwrap_or(Duration::ZERO) \u003e ttl\n  }\n}\n\n/// Данные кэша рендеринга\n#[derive(Debug, Clone)]\npub struct RenderCacheData {\n  /// Ключ кэша\n  pub cache_key: String,\n  /// Путь к результирующему файлу\n  pub output_path: PathBuf,\n  /// Параметры рендеринга (хеш)\n  pub render_hash: String,\n  /// Время создания\n  pub created_at: SystemTime,\n  /// Размер результирующего файла\n  pub file_size: u64,\n}\n\nimpl RenderCacheData {\n  /// Проверить, истек ли кэш\n  pub fn is_expired(\u0026self, ttl: Duration) -\u003e bool {\n    self.created_at.elapsed().unwrap_or(Duration::ZERO) \u003e ttl\n  }\n}\n\n/// Настройки кэша\n#[derive(Debug, Clone)]\npub struct CacheSettings {\n  /// Максимальное количество превью в кэше\n  pub max_preview_entries: usize,\n  /// Максимальное количество метаданных в кэше\n  pub max_metadata_entries: usize,\n  /// Максимальное количество данных рендеринга в кэше\n  pub max_render_entries: usize,\n  /// Максимальное использование памяти в MB\n  pub max_memory_mb: usize,\n  /// TTL для превью\n  pub preview_ttl: Duration,\n  /// TTL для метаданных\n  pub metadata_ttl: Duration,\n  /// TTL для данных рендеринга\n  pub render_ttl: Duration,\n}\n\nimpl Default for CacheSettings {\n  fn default() -\u003e Self {\n    Self {\n      max_preview_entries: 1000,\n      max_metadata_entries: 500,\n      max_render_entries: 100,\n      max_memory_mb: 512,\n      preview_ttl: Duration::from_secs(3600),  // 1 час\n      metadata_ttl: Duration::from_secs(1800), // 30 минут\n      render_ttl: Duration::from_secs(7200),   // 2 часа\n    }\n  }\n}\n\n/// Статистика использования кэша\n#[derive(Debug, Default, Clone, serde::Serialize, serde::Deserialize)]\npub struct CacheStats {\n  /// Запросы превью\n  pub preview_requests: u64,\n  /// Попадания превью\n  pub preview_hits: u64,\n  /// Промахи превью\n  pub preview_misses: u64,\n  /// Запросы метаданных\n  pub metadata_requests: u64,\n  /// Попадания метаданных\n  pub metadata_hits: u64,\n  /// Промахи метаданных\n  pub metadata_misses: u64,\n  /// Запросы рендеринга\n  pub render_requests: u64,\n  /// Попадания рендеринга\n  pub render_hits: u64,\n  /// Промахи рендеринга\n  pub render_misses: u64,\n}\n\nimpl CacheStats {\n  /// Получить общий процент попаданий\n  pub fn hit_ratio(\u0026self) -\u003e f32 {\n    let total_requests = self.preview_requests + self.metadata_requests + self.render_requests;\n    let total_hits = self.preview_hits + self.metadata_hits + self.render_hits;\n\n    if total_requests == 0 {\n      0.0\n    } else {\n      total_hits as f32 / total_requests as f32\n    }\n  }\n\n  /// Получить процент попаданий превью\n  pub fn preview_hit_ratio(\u0026self) -\u003e f32 {\n    if self.preview_requests == 0 {\n      0.0\n    } else {\n      self.preview_hits as f32 / self.preview_requests as f32\n    }\n  }\n}\n\n/// Использование памяти кэшем\n#[derive(Debug, Clone)]\npub struct CacheMemoryUsage {\n  /// Память, используемая превью (байты)\n  pub preview_bytes: usize,\n  /// Память, используемая метаданными (байты)\n  pub metadata_bytes: usize,\n  /// Память, используемая данными рендеринга (байты)\n  pub render_bytes: usize,\n  /// Общее использование памяти (байты)\n  pub total_bytes: usize,\n}\n\nimpl CacheMemoryUsage {\n  /// Получить использование в мегабайтах\n  pub fn total_mb(\u0026self) -\u003e f32 {\n    self.total_bytes as f32 / (1024.0 * 1024.0)\n  }\n}\n\n/// Простая реализация LRU кэша\n#[derive(Debug)]\nstruct LruCache\u003cK, V\u003e {\n  map: HashMap\u003cK, LruNode\u003cV\u003e\u003e,\n  capacity: usize,\n  head: Option\u003cK\u003e,\n  tail: Option\u003cK\u003e,\n}\n\n#[derive(Debug, Clone)]\nstruct LruNode\u003cV\u003e {\n  value: V,\n  prev: Option\u003cString\u003e,\n  next: Option\u003cString\u003e,\n}\n\nimpl\u003cK, V\u003e LruCache\u003cK, V\u003e\nwhere\n  K: Clone + std::hash::Hash + Eq + std::fmt::Debug,\n  V: Clone,\n{\n  fn new(capacity: usize) -\u003e Self {\n    Self {\n      map: HashMap::new(),\n      capacity,\n      head: None,\n      tail: None,\n    }\n  }\n\n  fn get(\u0026mut self, key: \u0026K) -\u003e Option\u003cV\u003e {\n    if let Some(node) = self.map.get(key) {\n      let value = node.value.clone();\n      // В реальной реализации здесь бы мы перемещали элемент в начало\n      Some(value)\n    } else {\n      None\n    }\n  }\n\n  fn insert(\u0026mut self, key: K, value: V) {\n    if self.map.len() \u003e= self.capacity {\n      // Удаляем самый старый элемент\n      if let Some(oldest_key) = self.get_oldest_key() {\n        self.map.remove(\u0026oldest_key);\n      }\n    }\n\n    let node = LruNode {\n      value,\n      prev: None,\n      next: None,\n    };\n\n    self.map.insert(key, node);\n  }\n\n  fn remove(\u0026mut self, key: \u0026K) -\u003e Option\u003cV\u003e {\n    self.map.remove(key).map(|node| node.value)\n  }\n\n  fn clear(\u0026mut self) {\n    self.map.clear();\n    self.head = None;\n    self.tail = None;\n  }\n\n  fn retain\u003cF\u003e(\u0026mut self, mut f: F)\n  where\n    F: FnMut(\u0026K, \u0026V) -\u003e bool,\n  {\n    self.map.retain(|k, v| f(k, \u0026v.value));\n  }\n\n  fn estimate_memory_usage(\u0026self) -\u003e usize {\n    // Простая оценка использования памяти\n    std::mem::size_of::\u003cSelf\u003e()\n      + self.map.capacity() * (std::mem::size_of::\u003cK\u003e() + std::mem::size_of::\u003cV\u003e())\n  }\n\n  fn get_oldest_key(\u0026self) -\u003e Option\u003cK\u003e {\n    // Упрощенная реализация - возвращаем первый ключ\n    self.map.keys().next().cloned()\n  }\n}\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(test)]\nmod inline_tests {\n  use super::*;\n  use std::time::Duration;\n\n  #[tokio::test]\n  async fn test_cache_creation() {\n    let cache = RenderCache::new();\n    let stats = cache.get_stats();\n    assert_eq!(stats.preview_requests, 0);\n    assert_eq!(stats.metadata_requests, 0);\n  }\n\n  #[tokio::test]\n  async fn test_preview_cache() {\n    let mut cache = RenderCache::new();\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n    let image_data = vec![1, 2, 3, 4, 5];\n\n    // Сохраняем превью\n    cache\n      .store_preview(key.clone(), image_data.clone())\n      .await\n      .unwrap();\n\n    // Получаем превью\n    let cached_data = cache.get_preview(\u0026key).await;\n    assert!(cached_data.is_some());\n    assert_eq!(cached_data.unwrap().image_data, image_data);\n\n    // Проверяем статистику\n    let stats = cache.get_stats();\n    assert_eq!(stats.preview_requests, 1);\n    assert_eq!(stats.preview_hits, 1);\n    assert_eq!(stats.preview_misses, 0);\n  }\n\n  #[tokio::test]\n  async fn test_metadata_cache() {\n    let mut cache = RenderCache::new();\n    let file_path = \"/test/video.mp4\".to_string();\n    let metadata = MediaMetadata {\n      file_path: file_path.clone(),\n      file_size: 1024000,\n      modified_time: SystemTime::now(),\n      duration: 120.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n      cached_at: SystemTime::now(),\n    };\n\n    // Сохраняем метаданные\n    cache\n      .store_metadata(file_path.clone(), metadata.clone())\n      .await\n      .unwrap();\n\n    // Получаем метаданные\n    let cached_metadata = cache.get_metadata(\u0026file_path).await;\n    assert!(cached_metadata.is_some());\n    assert_eq!(cached_metadata.unwrap().duration, 120.0);\n  }\n\n  #[tokio::test]\n  async fn test_cache_expiration() {\n    let settings = CacheSettings {\n      preview_ttl: Duration::from_millis(10), // Очень короткий TTL для теста\n      ..Default::default()\n    };\n    let mut cache = RenderCache::with_settings(settings);\n\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 5.0, (320, 180), 50);\n    let image_data = vec![10, 20, 30];\n\n    // Сохраняем превью\n    cache.store_preview(key.clone(), image_data).await.unwrap();\n\n    // Сразу должно быть доступно\n    assert!(cache.get_preview(\u0026key).await.is_some());\n\n    // Ждем истечения TTL\n    tokio::time::sleep(Duration::from_millis(20)).await;\n\n    // Теперь должно быть недоступно\n    assert!(cache.get_preview(\u0026key).await.is_none());\n  }\n\n  #[tokio::test]\n  async fn test_cache_stats() {\n    let mut cache = RenderCache::new();\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 1.0, (640, 360), 75);\n\n    // Промах\n    cache.get_preview(\u0026key).await;\n\n    // Сохраняем и попадание\n    cache\n      .store_preview(key.clone(), vec![1, 2, 3])\n      .await\n      .unwrap();\n    cache.get_preview(\u0026key).await;\n\n    let stats = cache.get_stats();\n    assert_eq!(stats.preview_requests, 2);\n    assert_eq!(stats.preview_hits, 1);\n    assert_eq!(stats.preview_misses, 1);\n    assert_eq!(stats.preview_hit_ratio(), 0.5);\n  }\n\n  #[tokio::test]\n  async fn test_memory_usage() {\n    let cache = RenderCache::new();\n    let usage = cache.get_memory_usage();\n\n    assert_eq!(\n      usage.total_bytes,\n      usage.preview_bytes + usage.metadata_bytes + usage.render_bytes\n    );\n    assert!(usage.total_mb() \u003e= 0.0);\n  }\n\n  #[tokio::test]\n  async fn test_cache_clear() {\n    let mut cache = RenderCache::new();\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 2.0, (640, 360), 75);\n\n    // Добавляем данные\n    cache\n      .store_preview(key.clone(), vec![1, 2, 3])\n      .await\n      .unwrap();\n    assert!(cache.get_preview(\u0026key).await.is_some());\n\n    // Очищаем превью\n    cache.clear_previews().await;\n    assert!(cache.get_preview(\u0026key).await.is_none());\n  }\n\n  #[test]\n  fn test_lru_cache() {\n    let mut lru = LruCache::new(2);\n\n    lru.insert(\"key1\".to_string(), \"value1\".to_string());\n    lru.insert(\"key2\".to_string(), \"value2\".to_string());\n\n    assert_eq!(lru.get(\u0026\"key1\".to_string()), Some(\"value1\".to_string()));\n\n    // Добавляем третий элемент, должен вытеснить самый старый\n    lru.insert(\"key3\".to_string(), \"value3\".to_string());\n\n    // key1 или key2 должен быть удален (в зависимости от реализации)\n    assert!(lru.get(\u0026\"key3\".to_string()).is_some());\n  }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":61}},{"line":30,"address":[],"length":0,"stats":{"Line":61}},{"line":34,"address":[],"length":0,"stats":{"Line":68}},{"line":36,"address":[],"length":0,"stats":{"Line":68}},{"line":37,"address":[],"length":0,"stats":{"Line":68}},{"line":38,"address":[],"length":0,"stats":{"Line":68}},{"line":40,"address":[],"length":0,"stats":{"Line":68}},{"line":45,"address":[],"length":0,"stats":{"Line":50}},{"line":46,"address":[],"length":0,"stats":{"Line":25}},{"line":48,"address":[],"length":0,"stats":{"Line":37}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":15}},{"line":60,"address":[],"length":0,"stats":{"Line":15}},{"line":64,"address":[],"length":0,"stats":{"Line":222}},{"line":67,"address":[],"length":0,"stats":{"Line":111}},{"line":71,"address":[],"length":0,"stats":{"Line":111}},{"line":72,"address":[],"length":0,"stats":{"Line":111}},{"line":73,"address":[],"length":0,"stats":{"Line":111}},{"line":77,"address":[],"length":0,"stats":{"Line":14}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":80,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":10}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":147,"address":[],"length":0,"stats":{"Line":124}},{"line":148,"address":[],"length":0,"stats":{"Line":124}},{"line":149,"address":[],"length":0,"stats":{"Line":124}},{"line":150,"address":[],"length":0,"stats":{"Line":124}},{"line":156,"address":[],"length":0,"stats":{"Line":124}},{"line":161,"address":[],"length":0,"stats":{"Line":238}},{"line":162,"address":[],"length":0,"stats":{"Line":119}},{"line":163,"address":[],"length":0,"stats":{"Line":119}},{"line":165,"address":[],"length":0,"stats":{"Line":119}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":119}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":124}},{"line":219,"address":[],"length":0,"stats":{"Line":124}},{"line":239,"address":[],"length":0,"stats":{"Line":18}},{"line":240,"address":[],"length":0,"stats":{"Line":18}},{"line":271,"address":[],"length":0,"stats":{"Line":7}},{"line":272,"address":[],"length":0,"stats":{"Line":7}},{"line":293,"address":[],"length":0,"stats":{"Line":6}},{"line":294,"address":[],"length":0,"stats":{"Line":6}},{"line":318,"address":[],"length":0,"stats":{"Line":68}},{"line":324,"address":[],"length":0,"stats":{"Line":68}},{"line":325,"address":[],"length":0,"stats":{"Line":68}},{"line":326,"address":[],"length":0,"stats":{"Line":68}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":3}},{"line":370,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":2}},{"line":392,"address":[],"length":0,"stats":{"Line":6}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":418,"address":[],"length":0,"stats":{"Line":211}},{"line":420,"address":[],"length":0,"stats":{"Line":211}},{"line":427,"address":[],"length":0,"stats":{"Line":59}},{"line":428,"address":[],"length":0,"stats":{"Line":94}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":24}},{"line":437,"address":[],"length":0,"stats":{"Line":138}},{"line":438,"address":[],"length":0,"stats":{"Line":138}},{"line":440,"address":[],"length":0,"stats":{"Line":6}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":138}},{"line":454,"address":[],"length":0,"stats":{"Line":5}},{"line":455,"address":[],"length":0,"stats":{"Line":15}},{"line":458,"address":[],"length":0,"stats":{"Line":13}},{"line":459,"address":[],"length":0,"stats":{"Line":13}},{"line":460,"address":[],"length":0,"stats":{"Line":13}},{"line":461,"address":[],"length":0,"stats":{"Line":13}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":468,"address":[],"length":0,"stats":{"Line":14}},{"line":471,"address":[],"length":0,"stats":{"Line":373}},{"line":473,"address":[],"length":0,"stats":{"Line":373}},{"line":474,"address":[],"length":0,"stats":{"Line":373}},{"line":477,"address":[],"length":0,"stats":{"Line":3}},{"line":479,"address":[],"length":0,"stats":{"Line":3}}],"covered":122,"coverable":128},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","commands","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::video_compiler::{\n        commands::*,\n        progress::{RenderStatus, RenderProgress},\n        schema::{AspectRatio, ProjectSchema, Timeline, Track, TrackType},\n        CompilerSettings,\n    };\n    use tempfile::TempDir;\n\n    fn create_test_state() -\u003e VideoCompilerState {\n        VideoCompilerState::new()\n    }\n\n    fn create_test_project() -\u003e ProjectSchema {\n        let mut project = ProjectSchema::new(\"Test Project\".to_string());\n        \n        // Set up timeline\n        project.timeline = Timeline {\n            duration: 60.0,\n            fps: 30,\n            resolution: (1920, 1080),\n            sample_rate: 48000,\n            aspect_ratio: AspectRatio::Ratio16x9,\n        };\n        \n        // Add a video track\n        let track = Track::new(TrackType::Video, \"Video Track\".to_string());\n        project.tracks.push(track);\n        \n        project\n    }\n\n    #[test]\n    fn test_video_compiler_state_new() {\n        let state = VideoCompilerState::new();\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n    }\n\n    #[test]\n    fn test_video_compiler_state_default() {\n        let state = VideoCompilerState::default();\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n    }\n\n    #[test]\n    fn test_render_job_serialization() {\n        let job = RenderJob {\n            id: \"test-id\".to_string(),\n            project_name: \"Test Project\".to_string(),\n            output_path: \"/tmp/output.mp4\".to_string(),\n            status: RenderStatus::Processing,\n            created_at: chrono::Utc::now().to_rfc3339(),\n            progress: None,\n            error_message: None,\n        };\n\n        let json = serde_json::to_string(\u0026job).unwrap();\n        assert!(json.contains(\"test-id\"));\n        assert!(json.contains(\"Test Project\"));\n        \n        let deserialized: RenderJob = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.id, job.id);\n        assert_eq!(deserialized.project_name, job.project_name);\n    }\n\n    #[tokio::test]\n    async fn test_compiler_settings_serialization() {\n        let settings = CompilerSettings::default();\n        let json = serde_json::to_string(\u0026settings).unwrap();\n        assert!(json.contains(\"max_concurrent_jobs\"));\n        assert!(json.contains(\"cache_size_mb\"));\n        \n        let deserialized: CompilerSettings = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.max_concurrent_jobs, settings.max_concurrent_jobs);\n    }\n\n    #[test]\n    fn test_ffmpeg_capabilities_serialization() {\n        let capabilities = FfmpegCapabilities {\n            version: \"5.0.0\".to_string(),\n            available_codecs: vec![\"h264\".to_string(), \"aac\".to_string()],\n            hardware_encoders: vec![\"h264_nvenc\".to_string()],\n            path: \"/usr/bin/ffmpeg\".to_string(),\n        };\n\n        let json = serde_json::to_string(\u0026capabilities).unwrap();\n        assert!(json.contains(\"5.0.0\"));\n        assert!(json.contains(\"h264\"));\n        \n        // FfmpegCapabilities doesn't have Deserialize, so skip deserialization test\n    }\n\n    #[test]\n    fn test_system_info_serialization() {\n        let system_info = SystemInfo {\n            os: \"linux\".to_string(),\n            arch: \"x86_64\".to_string(),\n            ffmpeg_path: \"ffmpeg\".to_string(),\n            temp_directory: \"/tmp\".to_string(),\n            gpu_capabilities: None,\n            available_memory: Some(8_000_000_000),\n            cpu_cores: 8,\n        };\n\n        let json = serde_json::to_string(\u0026system_info).unwrap();\n        assert!(json.contains(\"linux\"));\n        assert!(json.contains(\"x86_64\"));\n        \n        // SystemInfo doesn't have Deserialize, so skip deserialization test\n    }\n\n    #[test]\n    fn test_prerender_request_serialization() {\n        let request = PrerenderRequest {\n            project_schema: create_test_project(),\n            start_time: 0.0,\n            end_time: 10.0,\n            apply_effects: true,\n            quality: Some(80),\n        };\n\n        let json = serde_json::to_string(\u0026request).unwrap();\n        assert!(json.contains(\"project_schema\"));\n        assert!(json.contains(\"start_time\"));\n        \n        let deserialized: PrerenderRequest = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.start_time, request.start_time);\n    }\n\n    #[tokio::test]\n    async fn test_get_prerender_cache_info() {\n        let result = get_prerender_cache_info().await;\n        assert!(result.is_ok());\n        \n        let info = result.unwrap();\n        assert_eq!(info.file_count, info.files.len());\n        assert!(info.total_size \u003e= 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_prerender_cache() {\n        let result = clear_prerender_cache().await;\n        assert!(result.is_ok());\n        \n        let deleted_size = result.unwrap();\n        assert!(deleted_size \u003e= 0);\n    }\n\n    #[test]\n    fn test_extract_ffmpeg_version() {\n        let output = \"ffmpeg version 5.1.2 Copyright (c) 2000-2022 the FFmpeg developers\";\n        let version = extract_ffmpeg_version(output);\n        assert_eq!(version, \"ffmpeg version 5.1.2 Copyright (c) 2000-2022 the FFmpeg developers\");\n\n        let output_no_version = \"Some other output\";\n        let version = extract_ffmpeg_version(output_no_version);\n        assert_eq!(version, \"Unknown\");\n    }\n\n    #[test]\n    fn test_extract_available_codecs() {\n        let output = \"Codecs:\\nD..... = Decoding supported\\n.E.... = Encoding supported\\n..V... = Video codec\\n..A... = Audio codec\\n D.V... h264         H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\\n DEA... aac          AAC (Advanced Audio Coding)\";\n        let codecs = extract_available_codecs(output);\n        assert!(codecs.contains(\u0026\"h264\".to_string()));\n        assert!(codecs.contains(\u0026\"aac\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_hardware_encoders() {\n        let output = \"Encoders:\\n V..... h264_nvenc   NVIDIA NVENC H.264 encoder\\n V..... h264_qsv     Intel Quick Sync Video H.264 encoder\";\n        let encoders = extract_hardware_encoders(output);\n        assert!(encoders.contains(\u0026\"h264_nvenc\".to_string()));\n        assert!(encoders.contains(\u0026\"h264_qsv\".to_string()));\n    }\n\n    #[test]\n    fn test_timeline_frame_extraction_request_serialization() {\n        let request = TimelineFrameExtractionRequest {\n            video_path: \"/path/to/video.mp4\".to_string(),\n            duration: 120.0,\n            interval: 5.0,\n            max_frames: Some(20),\n        };\n\n        let json = serde_json::to_string(\u0026request).unwrap();\n        assert!(json.contains(\"video_path\"));\n        assert!(json.contains(\"120.0\"));\n        \n        let deserialized: TimelineFrameExtractionRequest = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.video_path, request.video_path);\n    }\n\n    #[test] \n    fn test_prerender_result_serialization() {\n        let result = PrerenderResult {\n            file_path: \"/tmp/prerender.mp4\".to_string(),\n            duration: 10.0,\n            file_size: 1024 * 1024,\n            render_time_ms: 5000,\n        };\n\n        let json = serde_json::to_string(\u0026result).unwrap();\n        assert!(json.contains(\"/tmp/prerender.mp4\"));\n        assert!(json.contains(\"10.0\"));\n        \n        let deserialized: PrerenderResult = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.file_path, result.file_path);\n    }\n\n    #[test]\n    fn test_prerender_cache_file_serialization() {\n        let file = PrerenderCacheFile {\n            path: \"/tmp/prerender_0_10_abc.mp4\".to_string(),\n            size: 2048,\n            created: 1234567890,\n            start_time: 0.0,\n            end_time: 10.0,\n        };\n\n        let json = serde_json::to_string(\u0026file).unwrap();\n        assert!(json.contains(\"prerender_0_10\"));\n        \n        let deserialized: PrerenderCacheFile = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.path, file.path);\n    }\n\n    #[test]\n    fn test_prerender_cache_info_serialization() {\n        let info = PrerenderCacheInfo {\n            file_count: 2,\n            total_size: 4096,\n            files: vec![\n                PrerenderCacheFile {\n                    path: \"/tmp/prerender_0_10_abc.mp4\".to_string(),\n                    size: 2048,\n                    created: 1234567890,\n                    start_time: 0.0,\n                    end_time: 10.0,\n                },\n                PrerenderCacheFile {\n                    path: \"/tmp/prerender_10_20_def.mp4\".to_string(),\n                    size: 2048,\n                    created: 1234567891,\n                    start_time: 10.0,\n                    end_time: 20.0,\n                },\n            ],\n        };\n\n        let json = serde_json::to_string(\u0026info).unwrap();\n        assert!(json.contains(\"file_count\"));\n        assert!(json.contains(\"total_size\"));\n        \n        let deserialized: PrerenderCacheInfo = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.file_count, info.file_count);\n        assert_eq!(deserialized.total_size, info.total_size);\n    }\n\n    #[test]\n    fn test_timeline_frame_serialization() {\n        let frame = TimelineFrame {\n            timestamp: 5.0,\n            frame_data: \"base64encodeddata\".to_string(),\n            is_keyframe: true,\n        };\n\n        let json = serde_json::to_string(\u0026frame).unwrap();\n        assert!(json.contains(\"timestamp\"));\n        assert!(json.contains(\"frame_data\"));\n        assert!(json.contains(\"is_keyframe\"));\n        \n        let deserialized: TimelineFrame = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.timestamp, frame.timestamp);\n        assert_eq!(deserialized.is_keyframe, frame.is_keyframe);\n    }\n\n    #[test]\n    fn test_recognition_frame_result_serialization() {\n        let result = RecognitionFrameResult {\n            timestamp: 10.0,\n            frame_data: vec![1, 2, 3, 4],\n            resolution: [1920, 1080],\n            scene_change_score: Some(0.85),\n            is_keyframe: false,\n        };\n\n        let json = serde_json::to_string(\u0026result).unwrap();\n        assert!(json.contains(\"timestamp\"));\n        assert!(json.contains(\"resolution\"));\n        assert!(json.contains(\"scene_change_score\"));\n        \n        let deserialized: RecognitionFrameResult = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.timestamp, result.timestamp);\n        assert_eq!(deserialized.resolution, result.resolution);\n    }\n\n    #[test]\n    fn test_subtitle_frame_result_serialization() {\n        let result = SubtitleFrameResult {\n            subtitle_id: \"subtitle-1\".to_string(),\n            subtitle_text: \"Hello World\".to_string(),\n            timestamp: 15.0,\n            frame_data: vec![5, 6, 7, 8],\n            start_time: 14.5,\n            end_time: 16.5,\n        };\n\n        let json = serde_json::to_string(\u0026result).unwrap();\n        assert!(json.contains(\"subtitle_id\"));\n        assert!(json.contains(\"subtitle_text\"));\n        \n        let deserialized: SubtitleFrameResult = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.subtitle_id, result.subtitle_id);\n        assert_eq!(deserialized.subtitle_text, result.subtitle_text);\n    }\n\n    #[test]\n    fn test_get_available_memory() {\n        // Test the function directly\n        let memory = get_available_memory();\n        // Just check it doesn't panic\n        assert!(memory.is_some() || memory.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_cache_stats_structure() {\n        let state = create_test_state();\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        \n        // Check all required fields exist\n        assert_eq!(stats.preview_requests, 0);\n        assert_eq!(stats.preview_hits, 0);\n        assert_eq!(stats.preview_misses, 0);\n        assert_eq!(stats.metadata_requests, 0);\n        assert_eq!(stats.metadata_hits, 0);\n        assert_eq!(stats.metadata_misses, 0);\n        assert_eq!(stats.render_requests, 0);\n        assert_eq!(stats.render_hits, 0);\n        assert_eq!(stats.render_misses, 0);\n    }\n\n    #[tokio::test]\n    async fn test_video_compiler_state_structure() {\n        let state = create_test_state();\n        \n        // Check active_jobs\n        {\n            let jobs = state.active_jobs.read().await;\n            assert!(jobs.is_empty());\n        }\n        \n        // Check cache_manager\n        {\n            let _cache = state.cache_manager.read().await;\n            // Cache exists\n        }\n        \n        // Check settings\n        {\n            let settings = state.settings.read().await;\n            assert!(settings.max_concurrent_jobs \u003e 0);\n        }\n        \n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n    }\n\n    #[tokio::test]\n    async fn test_compile_video_state() {\n        let state = create_test_state();\n        let project = create_test_project();\n        \n        // Test that we can create the state and access its components\n        assert!(state.active_jobs.read().await.is_empty());\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n        \n        // Validate project schema\n        assert_eq!(project.metadata.name, \"Test Project\");\n        assert_eq!(project.timeline.fps, 30);\n        assert_eq!(project.timeline.resolution, (1920, 1080));\n    }\n\n    #[tokio::test] \n    async fn test_render_job_management() {\n        let state = create_test_state();\n        \n        // Test that active jobs starts empty\n        {\n            let jobs = state.active_jobs.read().await;\n            assert!(jobs.is_empty());\n        }\n        \n        // Test RenderJob structure (command version)\n        let job = RenderJob {\n            id: \"test-123\".to_string(),\n            project_name: \"Test Project\".to_string(),\n            output_path: \"/tmp/output.mp4\".to_string(),\n            status: RenderStatus::Processing,\n            created_at: chrono::Utc::now().to_rfc3339(),\n            progress: Some(RenderProgress {\n                job_id: \"test-123\".to_string(),\n                stage: \"Encoding\".to_string(),\n                percentage: 50.0,\n                current_frame: 1500,\n                total_frames: 3000,\n                elapsed_time: std::time::Duration::from_secs(60),\n                estimated_remaining: Some(std::time::Duration::from_secs(60)),\n                status: RenderStatus::Processing,\n                message: Some(\"Processing video\".to_string()),\n            }),\n            error_message: None,\n        };\n        \n        assert_eq!(job.id, \"test-123\");\n        assert_eq!(job.status, RenderStatus::Processing);\n    }\n\n    #[tokio::test]\n    async fn test_get_active_jobs() {\n        let state = create_test_state();\n        \n        // Test that active jobs starts empty\n        let jobs = state.active_jobs.read().await;\n        assert!(jobs.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_cancel_render() {\n        let state = create_test_state();\n        let job_id = \"test-job-123\".to_string();\n        \n        // Verify no jobs exist\n        {\n            let jobs = state.active_jobs.read().await;\n            assert!(!jobs.contains_key(\u0026job_id));\n        }\n    }\n\n    #[tokio::test]\n    async fn test_generate_preview() {\n        let state = create_test_state();\n        let temp_dir = TempDir::new().unwrap();\n        let video_path = temp_dir.path().join(\"test.mp4\").to_str().unwrap().to_string();\n        \n        // Create a fake video file\n        std::fs::write(\u0026video_path, b\"fake video content\").unwrap();\n        \n        // Test cache manager exists\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        assert_eq!(stats.preview_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_gpu_capabilities() {\n        // Test GPU capabilities structure\n        use crate::video_compiler::gpu::GpuCapabilities;\n        \n        let capabilities = GpuCapabilities {\n            available_encoders: vec![crate::video_compiler::gpu::GpuEncoder::Nvenc],\n            recommended_encoder: Some(crate::video_compiler::gpu::GpuEncoder::Nvenc),\n            current_gpu: None,\n            hardware_acceleration_supported: true,\n        };\n        \n        assert!(capabilities.hardware_acceleration_supported);\n    }\n\n    #[tokio::test]\n    async fn test_get_current_gpu_info() {\n        // Test GPU info structure\n        use crate::video_compiler::gpu::GpuInfo;\n        \n        let info = GpuInfo {\n            name: \"Test GPU\".to_string(),\n            driver_version: Some(\"1.0.0\".to_string()),\n            memory_total: Some(8192 * 1024 * 1024),\n            memory_used: Some(1024 * 1024 * 1024),\n            utilization: Some(50.0),\n            encoder_type: crate::video_compiler::gpu::GpuEncoder::Nvenc,\n            supported_codecs: vec![\"h264\".to_string(), \"hevc\".to_string()],\n        };\n        \n        assert_eq!(info.name, \"Test GPU\");\n        assert!(info.memory_total.unwrap() \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_check_hardware_acceleration() {\n        let state = create_test_state();\n        \n        // Test settings have hardware acceleration flag\n        let settings = state.settings.read().await;\n        let hw_enabled = settings.hardware_acceleration;\n        assert!(hw_enabled == true || hw_enabled == false); // Either value is valid\n    }\n\n    #[tokio::test]\n    async fn test_get_cache_stats() {\n        let state = create_test_state();\n        \n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        \n        // New cache should have zero requests\n        assert_eq!(stats.preview_requests, 0);\n        assert_eq!(stats.metadata_requests, 0);\n        assert_eq!(stats.render_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_cache() {\n        let state = create_test_state();\n        \n        // Clear cache\n        {\n            let mut cache = state.cache_manager.write().await;\n            cache.clear_all().await;\n        }\n        \n        // Verify cache is empty\n        let cache = state.cache_manager.read().await;\n        let usage = cache.get_memory_usage();\n        assert!(usage.total_mb() \u003c 0.01);\n    }\n\n    #[tokio::test]\n    async fn test_clear_preview_cache() {\n        let state = create_test_state();\n        \n        // Clear preview cache\n        {\n            let mut cache = state.cache_manager.write().await;\n            cache.clear_previews().await;\n        }\n        \n        // Verify preview cache is empty\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        // Stats should be zero after clearing\n    }\n\n    #[tokio::test]\n    async fn test_get_compiler_settings() {\n        let state = create_test_state();\n        \n        let settings = state.settings.read().await;\n        assert!(settings.max_concurrent_jobs \u003e 0);\n        assert!(settings.cache_size_mb \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_update_compiler_settings() {\n        let state = create_test_state();\n        \n        // Update settings\n        {\n            let mut settings = state.settings.write().await;\n            settings.max_concurrent_jobs = 8;\n            settings.hardware_acceleration = false;\n        }\n        \n        // Verify settings were updated\n        let settings = state.settings.read().await;\n        assert_eq!(settings.max_concurrent_jobs, 8);\n        assert_eq!(settings.hardware_acceleration, false);\n    }\n\n    #[tokio::test]\n    async fn test_set_ffmpeg_path() {\n        let state = create_test_state();\n        let new_path = \"/usr/local/bin/ffmpeg\".to_string();\n        \n        // Verify original path\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n        \n        // Would update via state in real command\n        // For test, just verify structure\n        assert!(!new_path.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_get_system_info() {\n        // Test system info structure\n        let info = SystemInfo {\n            os: \"linux\".to_string(),\n            arch: \"x86_64\".to_string(),\n            ffmpeg_path: \"ffmpeg\".to_string(),\n            temp_directory: \"/tmp\".to_string(),\n            gpu_capabilities: None,\n            available_memory: Some(8_000_000_000),\n            cpu_cores: 8,\n        };\n        \n        assert_eq!(info.cpu_cores, 8);\n        assert!(info.available_memory.unwrap() \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_check_ffmpeg_capabilities() {\n        // Test FFmpeg capabilities structure\n        let capabilities = FfmpegCapabilities {\n            version: \"5.0.0\".to_string(),\n            available_codecs: vec![\"h264\".to_string(), \"aac\".to_string()],\n            hardware_encoders: vec![\"h264_nvenc\".to_string()],\n            path: \"/usr/bin/ffmpeg\".to_string(),\n        };\n        \n        assert!(!capabilities.version.is_empty());\n        assert!(!capabilities.available_codecs.is_empty());\n        assert!(capabilities.available_codecs.contains(\u0026\"h264\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_extract_timeline_frames() {\n        let temp_dir = TempDir::new().unwrap();\n        let video_path = temp_dir.path().join(\"test.mp4\").to_str().unwrap().to_string();\n        std::fs::write(\u0026video_path, b\"fake video\").unwrap();\n        \n        // Test request structure with correct fields\n        let request = TimelineFrameExtractionRequest {\n            video_path: video_path.clone(),\n            duration: 30.0,\n            interval: 5.0,\n            max_frames: Some(6),\n        };\n        \n        assert_eq!(request.duration, 30.0);\n        assert_eq!(request.interval, 5.0);\n        assert_eq!(request.max_frames, Some(6));\n    }\n\n    #[tokio::test]\n    async fn test_clear_frame_cache() {\n        let state = create_test_state();\n        \n        // Test that cache manager exists and can be accessed\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        \n        // Frame cache should be part of overall cache\n        assert_eq!(stats.preview_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_prerender_segment() {\n        let project = create_test_project();\n        \n        // Test request structure with correct fields\n        let request = PrerenderRequest {\n            project_schema: project,\n            start_time: 0.0,\n            end_time: 10.0,\n            apply_effects: true,\n            quality: Some(80),\n        };\n        \n        assert_eq!(request.start_time, 0.0);\n        assert_eq!(request.end_time, 10.0);\n        assert_eq!(request.apply_effects, true);\n        assert_eq!(request.quality, Some(80));\n    }\n\n    #[tokio::test]\n    async fn test_get_prerender_cache_info_standalone() {\n        // Test the standalone function\n        let result = get_prerender_cache_info().await;\n        assert!(result.is_ok());\n        \n        let info = result.unwrap();\n        assert_eq!(info.file_count, info.files.len());\n        assert!(info.total_size \u003e= 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_prerender_cache_standalone() {\n        // Test the standalone function\n        let result = clear_prerender_cache().await;\n        assert!(result.is_ok());\n        \n        let deleted_size = result.unwrap();\n        assert!(deleted_size \u003e= 0);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","commands.rs"],"content":"/*!\n * Tauri команды для Video Compiler\n *\n * Этот модуль определяет все Tauri команды для работы с video compiler\n * из фронтенда, включая компиляцию видео, управление GPU и мониторинг.\n */\n\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tauri::State;\nuse tokio::sync::{mpsc, RwLock};\nuse uuid::Uuid;\n\nuse crate::video_compiler::cache::{CacheStats, RenderCache};\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::frame_extraction::{\n  ExtractionPurpose, ExtractionSettings, ExtractionStrategy, FrameExtractionManager,\n};\nuse crate::video_compiler::gpu::{GpuCapabilities, GpuDetector, GpuInfo};\nuse crate::video_compiler::progress::{RenderProgress, RenderStatus};\nuse crate::video_compiler::renderer::VideoRenderer;\nuse crate::video_compiler::schema::{Clip, ProjectSchema, Subtitle};\nuse crate::video_compiler::CompilerSettings;\n\n/// Состояние Video Compiler для Tauri\n#[derive(Debug)]\npub struct VideoCompilerState {\n  /// Активные задачи рендеринга\n  pub active_jobs: Arc\u003cRwLock\u003cHashMap\u003cString, VideoRenderer\u003e\u003e\u003e,\n\n  /// Менеджер кэша\n  pub cache_manager: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n\n  /// Путь к FFmpeg\n  pub ffmpeg_path: String,\n\n  /// Настройки компилятора\n  pub settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n}\n\nimpl VideoCompilerState {\n  pub fn new() -\u003e Self {\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let cache_manager = Arc::new(RwLock::new(RenderCache::new()));\n\n    Self {\n      active_jobs: Arc::new(RwLock::new(HashMap::new())),\n      cache_manager,\n      ffmpeg_path: \"ffmpeg\".to_string(), // Предполагаем, что ffmpeg в PATH\n      settings,\n    }\n  }\n}\n\nimpl Default for VideoCompilerState {\n  fn default() -\u003e Self {\n    Self::new()\n  }\n}\n\n/// Информация о задаче рендеринга для фронтенда\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct RenderJob {\n  pub id: String,\n  pub project_name: String,\n  pub output_path: String,\n  pub status: RenderStatus,\n  pub created_at: String,\n  pub progress: Option\u003cRenderProgress\u003e,\n  pub error_message: Option\u003cString\u003e,\n}\n\n// ==================== ОСНОВНЫЕ КОМАНДЫ ====================\n\n/// Запуск компиляции видео\n#[tauri::command]\npub async fn compile_video(\n  project_schema: ProjectSchema,\n  output_path: String,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cString\u003e {\n  let job_id = uuid::Uuid::new_v4().to_string();\n\n  // Создаем канал для прогресса\n  let (progress_sender, _progress_receiver) = mpsc::unbounded_channel();\n\n  // Создаем рендерер\n  let renderer = VideoRenderer::new(\n    project_schema,\n    state.settings.clone(),\n    state.cache_manager.clone(),\n    progress_sender,\n  )\n  .await\n  .map_err(|e| VideoCompilerError::InternalError(format!(\"Failed to create renderer: {}\", e)))?;\n\n  // Сохраняем в активных задачах\n  {\n    let mut jobs = state.active_jobs.write().await;\n    jobs.insert(job_id.clone(), renderer);\n  }\n\n  // Запускаем рендеринг в фоне\n  let active_jobs = state.active_jobs.clone();\n  let job_id_clone = job_id.clone();\n  let output_path_clone = output_path.clone();\n\n  tokio::spawn(async move {\n    let result = {\n      let mut jobs = active_jobs.write().await;\n      if let Some(renderer) = jobs.get_mut(\u0026job_id_clone) {\n        renderer.render(Path::new(\u0026output_path_clone)).await\n      } else {\n        Err(VideoCompilerError::InternalError(\n          \"Job not found\".to_string(),\n        ))\n      }\n    };\n\n    // Логируем результат\n    match result {\n      Ok(_) =\u003e log::info!(\"Рендеринг завершен успешно: {}\", job_id_clone),\n      Err(e) =\u003e log::error!(\"Ошибка рендеринга {}: {}\", job_id_clone, e),\n    }\n\n    // Удаляем из активных задач\n    {\n      let mut jobs = active_jobs.write().await;\n      jobs.remove(\u0026job_id_clone);\n    }\n  });\n\n  Ok(job_id)\n}\n\n/// Получить прогресс рендеринга\n#[tauri::command]\npub async fn get_render_progress(\n  job_id: String,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cOption\u003cRenderProgress\u003e\u003e {\n  let jobs = state.active_jobs.read().await;\n\n  if let Some(renderer) = jobs.get(\u0026job_id) {\n    Ok(renderer.get_progress().await)\n  } else {\n    Ok(None)\n  }\n}\n\n/// Отменить рендеринг\n#[tauri::command]\npub async fn cancel_render(job_id: String, state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cbool\u003e {\n  let mut jobs = state.active_jobs.write().await;\n\n  if let Some(renderer) = jobs.get_mut(\u0026job_id) {\n    renderer.cancel().await?;\n    jobs.remove(\u0026job_id);\n    Ok(true)\n  } else {\n    Ok(false)\n  }\n}\n\n/// Получить список активных задач\n#[tauri::command]\npub async fn get_active_jobs(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cVec\u003cRenderJob\u003e\u003e {\n  let jobs = state.active_jobs.read().await;\n  let mut result = Vec::new();\n\n  for (job_id, renderer) in jobs.iter() {\n    let progress = renderer.get_progress().await;\n    let status = match \u0026progress {\n      Some(p) =\u003e p.status.clone(),\n      None =\u003e RenderStatus::Processing,\n    };\n\n    result.push(RenderJob {\n      id: job_id.clone(),\n      project_name: \"Unknown Project\".to_string(), // TODO: получать из ProjectSchema\n      output_path: \"Unknown Path\".to_string(),     // TODO: сохранять путь\n      status,\n      created_at: chrono::Utc::now().to_rfc3339(),\n      progress,\n      error_message: None,\n    });\n  }\n\n  Ok(result)\n}\n\n/// Генерация превью кадра\n#[tauri::command]\npub async fn generate_preview(\n  video_path: String,\n  timestamp: f64,\n  resolution: Option\u003c(u32, u32)\u003e,\n  quality: Option\u003cu8\u003e,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n  use crate::video_compiler::preview::PreviewGenerator;\n\n  let preview_gen = PreviewGenerator::new(state.cache_manager.clone());\n\n  // Генерируем превью\n  preview_gen\n    .generate_preview(Path::new(\u0026video_path), timestamp, resolution, quality)\n    .await\n    .map_err(|e| VideoCompilerError::PreviewError {\n      timestamp,\n      reason: e.to_string(),\n    })\n}\n\n/// Параметры для пререндера сегмента\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderRequest {\n  /// Схема проекта\n  pub project_schema: ProjectSchema,\n  /// Время начала сегмента в секундах\n  pub start_time: f64,\n  /// Время окончания сегмента в секундах\n  pub end_time: f64,\n  /// Применять ли эффекты и фильтры\n  pub apply_effects: bool,\n  /// Качество пререндера (1-100)\n  pub quality: Option\u003cu8\u003e,\n}\n\n/// Результат пререндера\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderResult {\n  /// Путь к файлу пререндера\n  pub file_path: String,\n  /// Длительность сегмента\n  pub duration: f64,\n  /// Размер файла в байтах\n  pub file_size: u64,\n  /// Время рендеринга в миллисекундах\n  pub render_time_ms: u64,\n}\n\n/// Пререндер сегмента видео для быстрого предпросмотра\n#[tauri::command]\npub async fn prerender_segment(\n  request: PrerenderRequest,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cPrerenderResult\u003e {\n  use crate::video_compiler::ffmpeg_builder::{FFmpegBuilder, FFmpegBuilderSettings};\n  use std::time::Instant;\n  use tokio::fs;\n\n  let start_instant = Instant::now();\n\n  // Валидация параметров\n  if request.start_time \u003e= request.end_time {\n    return Err(VideoCompilerError::validation(\n      \"Start time must be before end time\",\n    ));\n  }\n\n  let duration = request.end_time - request.start_time;\n  if duration \u003e 60.0 {\n    return Err(VideoCompilerError::validation(\n      \"Prerender segment cannot be longer than 60 seconds\",\n    ));\n  }\n\n  // Создаем временный файл для пререндера с уникальным именем\n  let temp_dir = std::env::temp_dir();\n\n  // Создаем хеш из параметров проекта для уникальности\n  use std::collections::hash_map::DefaultHasher;\n  use std::hash::{Hash, Hasher};\n\n  let mut hasher = DefaultHasher::new();\n  request.project_schema.tracks.len().hash(\u0026mut hasher);\n  request.project_schema.effects.len().hash(\u0026mut hasher);\n  request.apply_effects.hash(\u0026mut hasher);\n  request.quality.hash(\u0026mut hasher);\n  let hash = hasher.finish();\n\n  let file_name = format!(\n    \"prerender_{}_{}_{:x}.mp4\",\n    request.start_time.round() as i64,\n    request.end_time.round() as i64,\n    hash \u0026 0xFFFFFF // Используем только последние 6 цифр хеша\n  );\n  let output_path = temp_dir.join(file_name);\n\n  // Настройки FFmpeg\n  let ffmpeg_settings = FFmpegBuilderSettings {\n    ffmpeg_path: state.ffmpeg_path.clone(),\n    ..Default::default()\n  };\n\n  // Создаем билдер\n  let builder = FFmpegBuilder::with_settings(request.project_schema, ffmpeg_settings);\n\n  // Строим команду пререндера\n  let mut cmd = builder\n    .build_prerender_segment_command(\n      request.start_time,\n      request.end_time,\n      \u0026output_path,\n      request.apply_effects,\n    )\n    .await?;\n\n  // Запускаем FFmpeg\n  let output = cmd\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  if !output.status.success() {\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n    let exit_code = output.status.code();\n    return Err(VideoCompilerError::ffmpeg(\n      exit_code,\n      stderr.to_string(),\n      \"prerender_segment\",\n    ));\n  }\n\n  // Получаем размер файла\n  let metadata = fs::metadata(\u0026output_path)\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  let render_time_ms = start_instant.elapsed().as_millis() as u64;\n\n  Ok(PrerenderResult {\n    file_path: output_path.to_string_lossy().to_string(),\n    duration,\n    file_size: metadata.len(),\n    render_time_ms,\n  })\n}\n\n/// Информация о кеше пререндеров\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderCacheInfo {\n  /// Количество файлов в кеше\n  pub file_count: usize,\n  /// Общий размер кеша в байтах\n  pub total_size: u64,\n  /// Список файлов в кеше\n  pub files: Vec\u003cPrerenderCacheFile\u003e,\n}\n\n/// Информация о файле в кеше\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderCacheFile {\n  /// Путь к файлу\n  pub path: String,\n  /// Размер файла в байтах\n  pub size: u64,\n  /// Время создания\n  pub created: u64,\n  /// Параметры сегмента\n  pub start_time: f64,\n  pub end_time: f64,\n}\n\n/// Получить информацию о кеше пререндеров\n#[tauri::command]\npub async fn get_prerender_cache_info() -\u003e Result\u003cPrerenderCacheInfo\u003e {\n  use std::time::SystemTime;\n  use tokio::fs;\n\n  let temp_dir = std::env::temp_dir();\n  let mut files = Vec::new();\n  let mut total_size = 0u64;\n\n  // Читаем содержимое временной директории\n  let mut entries = fs::read_dir(\u0026temp_dir)\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  while let Some(entry) = entries\n    .next_entry()\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?\n  {\n    let path = entry.path();\n    let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n    // Проверяем, является ли это файлом пререндера\n    if file_name.starts_with(\"prerender_\") \u0026\u0026 file_name.ends_with(\".mp4\") {\n      let metadata = entry\n        .metadata()\n        .await\n        .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n      if metadata.is_file() {\n        let size = metadata.len();\n        total_size += size;\n\n        // Парсим время из имени файла\n        let parts: Vec\u003c\u0026str\u003e = file_name\n          .trim_start_matches(\"prerender_\")\n          .trim_end_matches(\".mp4\")\n          .split('_')\n          .collect();\n\n        let (start_time, end_time) = if parts.len() \u003e= 2 {\n          (\n            parts[0].parse::\u003cf64\u003e().unwrap_or(0.0),\n            parts[1].parse::\u003cf64\u003e().unwrap_or(0.0),\n          )\n        } else {\n          (0.0, 0.0)\n        };\n\n        let created = metadata\n          .created()\n          .ok()\n          .and_then(|t| t.duration_since(SystemTime::UNIX_EPOCH).ok())\n          .map(|d| d.as_secs())\n          .unwrap_or(0);\n\n        files.push(PrerenderCacheFile {\n          path: path.to_string_lossy().to_string(),\n          size,\n          created,\n          start_time,\n          end_time,\n        });\n      }\n    }\n  }\n\n  // Сортируем файлы по времени создания (новые первыми)\n  files.sort_by(|a, b| b.created.cmp(\u0026a.created));\n\n  Ok(PrerenderCacheInfo {\n    file_count: files.len(),\n    total_size,\n    files,\n  })\n}\n\n/// Очистить кеш пререндеров\n#[tauri::command]\npub async fn clear_prerender_cache() -\u003e Result\u003cu64\u003e {\n  use tokio::fs;\n\n  let temp_dir = std::env::temp_dir();\n  let mut _deleted_count = 0u64;\n  let mut deleted_size = 0u64;\n\n  // Читаем содержимое временной директории\n  let mut entries = fs::read_dir(\u0026temp_dir)\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  while let Some(entry) = entries\n    .next_entry()\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?\n  {\n    let path = entry.path();\n    let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n    // Проверяем, является ли это файлом пререндера\n    if file_name.starts_with(\"prerender_\") \u0026\u0026 file_name.ends_with(\".mp4\") {\n      let metadata = entry\n        .metadata()\n        .await\n        .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n      if metadata.is_file() {\n        deleted_size += metadata.len();\n\n        // Удаляем файл\n        if let Ok(_) = fs::remove_file(\u0026path).await {\n          _deleted_count += 1;\n        }\n      }\n    }\n  }\n\n  Ok(deleted_size)\n}\n\n// ==================== GPU КОМАНДЫ ====================\n\n/// Получить возможности GPU\n#[tauri::command]\npub async fn get_gpu_capabilities(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cGpuCapabilities\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n\n  detector\n    .get_gpu_capabilities()\n    .await\n    .map_err(|e| VideoCompilerError::gpu(format!(\"Failed to get GPU capabilities: {}\", e)))\n}\n\n/// Получить информацию о текущем GPU\n#[tauri::command]\npub async fn get_current_gpu_info(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cOption\u003cGpuInfo\u003e\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n\n  match detector.get_gpu_capabilities().await {\n    Ok(capabilities) =\u003e Ok(capabilities.current_gpu),\n    Err(_) =\u003e Ok(None),\n  }\n}\n\n/// Проверить доступность аппаратного ускорения\n#[tauri::command]\npub async fn check_hardware_acceleration(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cbool\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n\n  match detector.detect_available_encoders().await {\n    Ok(encoders) =\u003e Ok(!encoders.is_empty()),\n    Err(_) =\u003e Ok(false),\n  }\n}\n\n// ==================== КЭШИРОВАНИЕ ====================\n\n/// Получить статистику кэша\n#[tauri::command]\npub async fn get_cache_stats(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cCacheStats\u003e {\n  let cache = state.cache_manager.read().await;\n  Ok(cache.get_stats().clone())\n}\n\n/// Очистить кэш\n#[tauri::command]\npub async fn clear_cache(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c()\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_all().await;\n  Ok(())\n}\n\n/// Очистить кэш превью\n#[tauri::command]\npub async fn clear_preview_cache(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c()\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_previews().await;\n  Ok(())\n}\n\n// ==================== НАСТРОЙКИ ====================\n\n/// Получить настройки компилятора\n#[tauri::command]\npub async fn get_compiler_settings(\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cCompilerSettings\u003e {\n  let settings = state.settings.read().await;\n  Ok(settings.clone())\n}\n\n/// Обновить настройки компилятора\n#[tauri::command]\npub async fn update_compiler_settings(\n  new_settings: CompilerSettings,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003c()\u003e {\n  let mut settings = state.settings.write().await;\n  *settings = new_settings;\n  Ok(())\n}\n\n/// Установить путь к FFmpeg\n#[tauri::command]\npub async fn set_ffmpeg_path(path: String, _state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cbool\u003e {\n  // Проверяем, что FFmpeg доступен по указанному пути\n  let output = tokio::process::Command::new(\u0026path)\n    .arg(\"-version\")\n    .output()\n    .await;\n\n  match output {\n    Ok(output) if output.status.success() =\u003e {\n      // TODO: Обновить путь в состоянии\n      Ok(true)\n    }\n    _ =\u003e Err(VideoCompilerError::DependencyMissing(format!(\n      \"FFmpeg not found at path: {}\",\n      path\n    ))),\n  }\n}\n\n// ==================== ДИАГНОСТИКА ====================\n\n/// Получить информацию о системе для диагностики\n#[tauri::command]\npub async fn get_system_info(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cSystemInfo\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n  let gpu_capabilities = detector.get_gpu_capabilities().await.ok();\n\n  Ok(SystemInfo {\n    os: std::env::consts::OS.to_string(),\n    arch: std::env::consts::ARCH.to_string(),\n    ffmpeg_path: state.ffmpeg_path.clone(),\n    temp_directory: std::env::temp_dir().to_string_lossy().to_string(),\n    gpu_capabilities,\n    available_memory: get_available_memory(),\n    cpu_cores: std::thread::available_parallelism()\n      .map(|n| n.get())\n      .unwrap_or(1),\n  })\n}\n\n/// Информация о системе\n#[derive(Debug, serde::Serialize)]\npub struct SystemInfo {\n  pub os: String,\n  pub arch: String,\n  pub ffmpeg_path: String,\n  pub temp_directory: String,\n  pub gpu_capabilities: Option\u003cGpuCapabilities\u003e,\n  pub available_memory: Option\u003cu64\u003e,\n  pub cpu_cores: usize,\n}\n\n/// Получить доступную память системы\nfn get_available_memory() -\u003e Option\u003cu64\u003e {\n  #[cfg(target_os = \"linux\")]\n  {\n    // Читаем /proc/meminfo\n    use std::fs;\n    if let Ok(content) = fs::read_to_string(\"/proc/meminfo\") {\n      for line in content.lines() {\n        if line.starts_with(\"MemAvailable:\") {\n          if let Some(kb) = line.split_whitespace().nth(1) {\n            if let Ok(kb_val) = kb.parse::\u003cu64\u003e() {\n              return Some(kb_val * 1024); // Конвертируем в байты\n            }\n          }\n        }\n      }\n    }\n  }\n\n  #[cfg(target_os = \"macos\")]\n  {\n    // Используем sysctl\n    use std::process::Command;\n    if let Ok(output) = Command::new(\"sysctl\").args([\"-n\", \"hw.memsize\"]).output() {\n      if let Ok(mem_str) = String::from_utf8(output.stdout) {\n        if let Ok(mem_bytes) = mem_str.trim().parse::\u003cu64\u003e() {\n          return Some(mem_bytes);\n        }\n      }\n    }\n  }\n\n  #[cfg(target_os = \"windows\")]\n  {\n    // Для Windows можно использовать WMI или другие системные API\n    // Пока возвращаем None\n  }\n\n  None\n}\n\n// ==================== ИЗВЛЕЧЕНИЕ КАДРОВ ====================\n\n/// Параметры для извлечения кадров для timeline\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct TimelineFrameExtractionRequest {\n  /// Путь к видео файлу\n  pub video_path: String,\n  /// Длительность видео\n  pub duration: f64,\n  /// Интервал между кадрами (секунды)\n  pub interval: f64,\n  /// Максимальное количество кадров\n  pub max_frames: Option\u003cusize\u003e,\n}\n\n/// Результат извлечения кадра для timeline\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct TimelineFrame {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные кадра (base64)\n  pub frame_data: String,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Извлечь кадры для timeline\n#[tauri::command]\npub async fn extract_timeline_frames(\n  request: TimelineFrameExtractionRequest,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cTimelineFrame\u003e\u003e {\n  use base64::engine::general_purpose::STANDARD as BASE64;\n  use base64::Engine as _;\n  use std::path::Path;\n\n  let manager = FrameExtractionManager::new(state.cache_manager.clone());\n\n  // Настройки для timeline превью\n  let settings = ExtractionSettings {\n    strategy: ExtractionStrategy::Combined {\n      min_interval: request.interval,\n      include_scene_changes: true,\n      include_keyframes: true,\n    },\n    purpose: ExtractionPurpose::TimelinePreview,\n    resolution: (160, 90), // Маленькое разрешение для timeline\n    quality: 60,\n    format: crate::video_compiler::schema::PreviewFormat::Jpeg,\n    max_frames: request.max_frames,\n    gpu_decode: true,\n    parallel_extraction: true,\n    thread_count: None,\n  };\n\n  let path = Path::new(\u0026request.video_path);\n  let _video_info = manager.preview_generator.get_video_info(path).await?;\n\n  // Создаем фейковый клип для использования существующей функции\n  let clip = Clip {\n    id: Uuid::new_v4().to_string(),\n    source_path: path.to_path_buf(),\n    start_time: 0.0,\n    end_time: request.duration,\n    source_start: 0.0,\n    source_end: request.duration,\n    speed: 1.0,\n    volume: 1.0,\n    locked: false,\n    effects: Vec::new(),\n    filters: Vec::new(),\n    template_id: None,\n    template_cell: None,\n    style_template_id: None,\n    properties: HashMap::new(),\n  };\n\n  let frames = manager\n    .extract_frames_for_clip(\u0026clip, Some(settings))\n    .await?;\n\n  // Преобразуем в формат для фронтенда\n  Ok(\n    frames\n      .into_iter()\n      .map(|frame| TimelineFrame {\n        timestamp: frame.timestamp,\n        frame_data: BASE64.encode(\u0026frame.data),\n        is_keyframe: frame.is_keyframe,\n      })\n      .collect(),\n  )\n}\n\n/// Результат распознавания кадра\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct RecognitionFrameResult {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные кадра\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Разрешение\n  pub resolution: [u32; 2],\n  /// Оценка изменения сцены\n  pub scene_change_score: Option\u003cf32\u003e,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Извлечь кадры для распознавания\n#[tauri::command]\npub async fn extract_recognition_frames(\n  video_path: String,\n  purpose: String,\n  _interval: f64,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cRecognitionFrameResult\u003e\u003e {\n  use std::path::Path;\n\n  let manager = FrameExtractionManager::new(state.cache_manager.clone());\n\n  // Парсим цель извлечения\n  let extraction_purpose = match purpose.as_str() {\n    \"object_detection\" =\u003e ExtractionPurpose::ObjectDetection,\n    \"scene_recognition\" =\u003e ExtractionPurpose::SceneRecognition,\n    \"text_recognition\" =\u003e ExtractionPurpose::TextRecognition,\n    _ =\u003e ExtractionPurpose::ObjectDetection,\n  };\n\n  let path = Path::new(\u0026video_path);\n  let video_info = manager.preview_generator.get_video_info(path).await?;\n\n  let frames = manager\n    .extract_frames_for_recognition(path, video_info.duration, extraction_purpose)\n    .await?;\n\n  // Преобразуем в формат для фронтенда\n  Ok(\n    frames\n      .into_iter()\n      .map(|frame| RecognitionFrameResult {\n        timestamp: frame.timestamp,\n        frame_data: frame.frame_data,\n        resolution: [frame.resolution.0, frame.resolution.1],\n        scene_change_score: frame.scene_change_score,\n        is_keyframe: frame.is_keyframe,\n      })\n      .collect(),\n  )\n}\n\n/// Параметры для извлечения кадров субтитров\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct SubtitleFrameResult {\n  /// ID субтитра\n  pub subtitle_id: String,\n  /// Текст субтитра\n  pub subtitle_text: String,\n  /// Временная метка кадра\n  pub timestamp: f64,\n  /// Данные кадра (base64)\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Время начала субтитра\n  pub start_time: f64,\n  /// Время окончания субтитра\n  pub end_time: f64,\n}\n\n/// Извлечь кадры для субтитров\n#[tauri::command]\npub async fn extract_subtitle_frames(\n  video_path: String,\n  subtitles: Vec\u003cSubtitle\u003e,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cSubtitleFrameResult\u003e\u003e {\n  use std::path::Path;\n\n  let manager = FrameExtractionManager::new(state.cache_manager.clone());\n  let path = Path::new(\u0026video_path);\n\n  let frames = manager\n    .extract_frames_for_subtitles(path, \u0026subtitles, None)\n    .await?;\n\n  // Преобразуем в формат для фронтенда\n  Ok(\n    frames\n      .into_iter()\n      .map(|frame| SubtitleFrameResult {\n        subtitle_id: frame.subtitle_id,\n        subtitle_text: frame.subtitle_text,\n        timestamp: frame.timestamp,\n        frame_data: frame.frame_data,\n        start_time: frame.start_time,\n        end_time: frame.end_time,\n      })\n      .collect(),\n  )\n}\n\n/// Очистить кэш кадров\n#[tauri::command]\npub async fn clear_frame_cache(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c()\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_previews().await;\n  Ok(())\n}\n\n/// Проверить доступность FFmpeg и его возможности\n#[tauri::command]\npub async fn check_ffmpeg_capabilities(\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cFfmpegCapabilities\u003e {\n  let ffmpeg_path = \u0026state.ffmpeg_path;\n\n  // Проверяем версию FFmpeg\n  let version_output = tokio::process::Command::new(ffmpeg_path)\n    .arg(\"-version\")\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::DependencyMissing(format!(\"FFmpeg not found: {}\", e)))?;\n\n  let version_str = String::from_utf8_lossy(\u0026version_output.stdout);\n  let version = extract_ffmpeg_version(\u0026version_str);\n\n  // Проверяем доступные кодеки\n  let codecs_output = tokio::process::Command::new(ffmpeg_path)\n    .arg(\"-codecs\")\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::io(format!(\"Failed to get codecs: {}\", e)))?;\n\n  let codecs_str = String::from_utf8_lossy(\u0026codecs_output.stdout);\n  let available_codecs = extract_available_codecs(\u0026codecs_str);\n\n  // Проверяем доступные энкодеры\n  let encoders_output = tokio::process::Command::new(ffmpeg_path)\n    .arg(\"-encoders\")\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::io(format!(\"Failed to get encoders: {}\", e)))?;\n\n  let encoders_str = String::from_utf8_lossy(\u0026encoders_output.stdout);\n  let hardware_encoders = extract_hardware_encoders(\u0026encoders_str);\n\n  Ok(FfmpegCapabilities {\n    version,\n    available_codecs,\n    hardware_encoders,\n    path: ffmpeg_path.clone(),\n  })\n}\n\n/// Возможности FFmpeg\n#[derive(Debug, serde::Serialize)]\npub struct FfmpegCapabilities {\n  pub version: String,\n  pub available_codecs: Vec\u003cString\u003e,\n  pub hardware_encoders: Vec\u003cString\u003e,\n  pub path: String,\n}\n\n/// Извлечь версию FFmpeg из вывода\nfn extract_ffmpeg_version(output: \u0026str) -\u003e String {\n  for line in output.lines() {\n    if line.starts_with(\"ffmpeg version\") {\n      return line.to_string();\n    }\n  }\n  \"Unknown\".to_string()\n}\n\n/// Извлечь доступные кодеки\nfn extract_available_codecs(output: \u0026str) -\u003e Vec\u003cString\u003e {\n  let mut codecs = Vec::new();\n  let important_codecs = [\"h264\", \"h265\", \"vp8\", \"vp9\", \"av1\", \"aac\", \"mp3\", \"opus\"];\n\n  for line in output.lines() {\n    for codec in \u0026important_codecs {\n      if line.contains(codec) \u0026\u0026 !codecs.contains(\u0026codec.to_string()) {\n        codecs.push(codec.to_string());\n      }\n    }\n  }\n\n  codecs\n}\n\n/// Извлечь аппаратные энкодеры\nfn extract_hardware_encoders(output: \u0026str) -\u003e Vec\u003cString\u003e {\n  let mut encoders = Vec::new();\n  let hw_encoders = [\n    \"h264_nvenc\",\n    \"hevc_nvenc\",\n    \"h264_qsv\",\n    \"hevc_qsv\",\n    \"h264_vaapi\",\n    \"hevc_vaapi\",\n    \"h264_videotoolbox\",\n    \"hevc_videotoolbox\",\n    \"h264_amf\",\n    \"hevc_amf\",\n  ];\n\n  for line in output.lines() {\n    for encoder in \u0026hw_encoders {\n      if line.contains(encoder) \u0026\u0026 !encoders.contains(\u0026encoder.to_string()) {\n        encoders.push(encoder.to_string());\n      }\n    }\n  }\n\n  encoders\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":23}},{"line":44,"address":[],"length":0,"stats":{"Line":23}},{"line":45,"address":[],"length":0,"stats":{"Line":23}},{"line":48,"address":[],"length":0,"stats":{"Line":23}},{"line":50,"address":[],"length":0,"stats":{"Line":23}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":4}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":4}},{"line":379,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":382,"address":[],"length":0,"stats":{"Line":4798}},{"line":383,"address":[],"length":0,"stats":{"Line":2400}},{"line":384,"address":[],"length":0,"stats":{"Line":2400}},{"line":385,"address":[],"length":0,"stats":{"Line":4800}},{"line":388,"address":[],"length":0,"stats":{"Line":2398}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":440,"address":[],"length":0,"stats":{"Line":2}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":4}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":451,"address":[],"length":0,"stats":{"Line":2}},{"line":452,"address":[],"length":0,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":4}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":4798}},{"line":460,"address":[],"length":0,"stats":{"Line":2400}},{"line":461,"address":[],"length":0,"stats":{"Line":2400}},{"line":462,"address":[],"length":0,"stats":{"Line":4800}},{"line":465,"address":[],"length":0,"stats":{"Line":2398}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":1}},{"line":647,"address":[],"length":0,"stats":{"Line":2}},{"line":648,"address":[],"length":0,"stats":{"Line":1}},{"line":649,"address":[],"length":0,"stats":{"Line":1}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":2}},{"line":929,"address":[],"length":0,"stats":{"Line":4}},{"line":930,"address":[],"length":0,"stats":{"Line":2}},{"line":931,"address":[],"length":0,"stats":{"Line":1}},{"line":934,"address":[],"length":0,"stats":{"Line":1}},{"line":938,"address":[],"length":0,"stats":{"Line":1}},{"line":939,"address":[],"length":0,"stats":{"Line":1}},{"line":940,"address":[],"length":0,"stats":{"Line":1}},{"line":942,"address":[],"length":0,"stats":{"Line":8}},{"line":943,"address":[],"length":0,"stats":{"Line":119}},{"line":944,"address":[],"length":0,"stats":{"Line":4}},{"line":945,"address":[],"length":0,"stats":{"Line":2}},{"line":950,"address":[],"length":0,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":1}},{"line":955,"address":[],"length":0,"stats":{"Line":1}},{"line":956,"address":[],"length":0,"stats":{"Line":1}},{"line":957,"address":[],"length":0,"stats":{"Line":1}},{"line":958,"address":[],"length":0,"stats":{"Line":1}},{"line":959,"address":[],"length":0,"stats":{"Line":1}},{"line":960,"address":[],"length":0,"stats":{"Line":1}},{"line":961,"address":[],"length":0,"stats":{"Line":1}},{"line":962,"address":[],"length":0,"stats":{"Line":1}},{"line":963,"address":[],"length":0,"stats":{"Line":1}},{"line":964,"address":[],"length":0,"stats":{"Line":1}},{"line":965,"address":[],"length":0,"stats":{"Line":1}},{"line":966,"address":[],"length":0,"stats":{"Line":1}},{"line":969,"address":[],"length":0,"stats":{"Line":4}},{"line":970,"address":[],"length":0,"stats":{"Line":63}},{"line":971,"address":[],"length":0,"stats":{"Line":4}},{"line":972,"address":[],"length":0,"stats":{"Line":2}},{"line":977,"address":[],"length":0,"stats":{"Line":1}}],"covered":72,"coverable":354},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","error.rs"],"content":"//! Error - Модуль обработки ошибок Video Compiler\n//!\n//! Этот модуль определяет типы ошибок, которые могут возникнуть при работе\n//! с Video Compiler модулем, включая ошибки FFmpeg, валидации и I/O операций.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Результат операции Video Compiler\npub type Result\u003cT\u003e = std::result::Result\u003cT, VideoCompilerError\u003e;\n\n/// Основные типы ошибок Video Compiler\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum VideoCompilerError {\n  /// Ошибка валидации схемы проекта\n  ValidationError(String),\n\n  /// Ошибка FFmpeg (код выхода, stderr)\n  FFmpegError {\n    exit_code: Option\u003ci32\u003e,\n    stderr: String,\n    command: String,\n  },\n\n  /// Отсутствующая зависимость (FFmpeg, библиотеки)\n  DependencyMissing(String),\n\n  /// Ошибка ввода/вывода\n  IoError(String),\n\n  /// Ошибка сериализации/десериализации\n  SerializationError(String),\n\n  /// Медиа файл не найден или недоступен\n  MediaFileError { path: String, reason: String },\n\n  /// Неподдерживаемый формат медиа\n  UnsupportedFormat { format: String, file_path: String },\n\n  /// Ошибка рендеринга\n  RenderError {\n    job_id: String,\n    stage: String,\n    message: String,\n  },\n\n  /// Ошибка генерации превью\n  PreviewError { timestamp: f64, reason: String },\n\n  /// Ошибка кэша\n  CacheError(String),\n\n  /// Ошибка конфигурации\n  ConfigError(String),\n\n  /// Нехватка ресурсов (память, диск)\n  ResourceError {\n    resource_type: String,\n    available: String,\n    required: String,\n  },\n\n  /// Тайм-аут операции\n  TimeoutError {\n    operation: String,\n    timeout_seconds: u64,\n  },\n\n  /// Операция была отменена пользователем\n  CancelledError(String),\n\n  /// Ошибка GPU ускорения\n  GpuError(String),\n\n  /// GPU недоступен или не поддерживается\n  GpuUnavailable(String),\n\n  /// Ошибка ввода/вывода (переименовано для ясности)\n  Io(String),\n\n  /// Внутренняя ошибка\n  InternalError(String),\n\n  /// Неизвестная ошибка\n  Unknown(String),\n}\n\nimpl fmt::Display for VideoCompilerError {\n  fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    match self {\n      VideoCompilerError::ValidationError(msg) =\u003e {\n        write!(f, \"Ошибка валидации: {}\", msg)\n      }\n      VideoCompilerError::FFmpegError {\n        exit_code,\n        stderr,\n        command,\n      } =\u003e {\n        write!(\n          f,\n          \"Ошибка FFmpeg (код выхода: {:?}): {}\\nКоманда: {}\",\n          exit_code, stderr, command\n        )\n      }\n      VideoCompilerError::DependencyMissing(dep) =\u003e {\n        write!(f, \"Отсутствует зависимость: {}\", dep)\n      }\n      VideoCompilerError::IoError(msg) =\u003e {\n        write!(f, \"Ошибка ввода/вывода: {}\", msg)\n      }\n      VideoCompilerError::SerializationError(msg) =\u003e {\n        write!(f, \"Ошибка сериализации: {}\", msg)\n      }\n      VideoCompilerError::MediaFileError { path, reason } =\u003e {\n        write!(f, \"Ошибка медиа файла '{}': {}\", path, reason)\n      }\n      VideoCompilerError::UnsupportedFormat { format, file_path } =\u003e {\n        write!(\n          f,\n          \"Неподдерживаемый формат '{}' для файла '{}'\",\n          format, file_path\n        )\n      }\n      VideoCompilerError::RenderError {\n        job_id,\n        stage,\n        message,\n      } =\u003e {\n        write!(\n          f,\n          \"Ошибка рендеринга [{}] на этапе '{}': {}\",\n          job_id, stage, message\n        )\n      }\n      VideoCompilerError::PreviewError { timestamp, reason } =\u003e {\n        write!(f, \"Ошибка генерации превью на {}с: {}\", timestamp, reason)\n      }\n      VideoCompilerError::CacheError(msg) =\u003e {\n        write!(f, \"Ошибка кэша: {}\", msg)\n      }\n      VideoCompilerError::ConfigError(msg) =\u003e {\n        write!(f, \"Ошибка конфигурации: {}\", msg)\n      }\n      VideoCompilerError::ResourceError {\n        resource_type,\n        available,\n        required,\n      } =\u003e {\n        write!(\n          f,\n          \"Нехватка ресурса '{}': доступно {}, требуется {}\",\n          resource_type, available, required\n        )\n      }\n      VideoCompilerError::TimeoutError {\n        operation,\n        timeout_seconds,\n      } =\u003e {\n        write!(\n          f,\n          \"Тайм-аут операции '{}' ({}с)\",\n          operation, timeout_seconds\n        )\n      }\n      VideoCompilerError::CancelledError(msg) =\u003e {\n        write!(f, \"Операция отменена: {}\", msg)\n      }\n      VideoCompilerError::GpuError(msg) =\u003e {\n        write!(f, \"Ошибка GPU: {}\", msg)\n      }\n      VideoCompilerError::GpuUnavailable(msg) =\u003e {\n        write!(f, \"GPU недоступен: {}\", msg)\n      }\n      VideoCompilerError::Io(msg) =\u003e {\n        write!(f, \"Ошибка ввода/вывода: {}\", msg)\n      }\n      VideoCompilerError::InternalError(msg) =\u003e {\n        write!(f, \"Внутренняя ошибка: {}\", msg)\n      }\n      VideoCompilerError::Unknown(msg) =\u003e {\n        write!(f, \"Неизвестная ошибка: {}\", msg)\n      }\n    }\n  }\n}\n\nimpl std::error::Error for VideoCompilerError {}\n\nimpl VideoCompilerError {\n  /// Создать ошибку GPU\n  pub fn gpu(message: impl Into\u003cString\u003e) -\u003e Self {\n    VideoCompilerError::GpuError(message.into())\n  }\n\n  /// Создать ошибку недоступности GPU\n  pub fn gpu_unavailable(message: impl Into\u003cString\u003e) -\u003e Self {\n    VideoCompilerError::GpuUnavailable(message.into())\n  }\n\n  /// Создать ошибку I/O\n  pub fn io(message: impl Into\u003cString\u003e) -\u003e Self {\n    VideoCompilerError::Io(message.into())\n  }\n\n  /// Проверить, является ли ошибка связанной с GPU\n  pub fn is_gpu_related(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::GpuError(_) | VideoCompilerError::GpuUnavailable(_)\n    )\n  }\n\n  /// Получить сообщение об ошибке\n  pub fn message(\u0026self) -\u003e String {\n    self.to_string()\n  }\n\n  /// Проверить, можно ли использовать fallback на CPU\n  pub fn should_fallback_to_cpu(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::GpuError(_) | VideoCompilerError::GpuUnavailable(_)\n    )\n  }\n}\n\n// Конверсии из стандартных ошибок\nimpl From\u003cstd::io::Error\u003e for VideoCompilerError {\n  fn from(error: std::io::Error) -\u003e Self {\n    VideoCompilerError::IoError(error.to_string())\n  }\n}\n\nimpl From\u003cserde_json::Error\u003e for VideoCompilerError {\n  fn from(error: serde_json::Error) -\u003e Self {\n    VideoCompilerError::SerializationError(error.to_string())\n  }\n}\n\nimpl From\u003cuuid::Error\u003e for VideoCompilerError {\n  fn from(error: uuid::Error) -\u003e Self {\n    VideoCompilerError::InternalError(format!(\"UUID error: {}\", error))\n  }\n}\n\nimpl From\u003ctokio::time::error::Elapsed\u003e for VideoCompilerError {\n  fn from(_error: tokio::time::error::Elapsed) -\u003e Self {\n    VideoCompilerError::TimeoutError {\n      operation: \"Unknown\".to_string(),\n      timeout_seconds: 0,\n    }\n  }\n}\n\n/// Вспомогательные функции для создания ошибок\nimpl VideoCompilerError {\n  /// Создать ошибку валидации\n  pub fn validation\u003cS: Into\u003cString\u003e\u003e(message: S) -\u003e Self {\n    VideoCompilerError::ValidationError(message.into())\n  }\n\n  /// Создать ошибку FFmpeg\n  pub fn ffmpeg\u003cS1: Into\u003cString\u003e, S2: Into\u003cString\u003e\u003e(\n    exit_code: Option\u003ci32\u003e,\n    stderr: S1,\n    command: S2,\n  ) -\u003e Self {\n    VideoCompilerError::FFmpegError {\n      exit_code,\n      stderr: stderr.into(),\n      command: command.into(),\n    }\n  }\n\n  /// Создать ошибку медиа файла\n  pub fn media_file\u003cP: Into\u003cString\u003e, R: Into\u003cString\u003e\u003e(path: P, reason: R) -\u003e Self {\n    VideoCompilerError::MediaFileError {\n      path: path.into(),\n      reason: reason.into(),\n    }\n  }\n\n  /// Создать ошибку неподдерживаемого формата\n  pub fn unsupported_format\u003cF: Into\u003cString\u003e, P: Into\u003cString\u003e\u003e(format: F, file_path: P) -\u003e Self {\n    VideoCompilerError::UnsupportedFormat {\n      format: format.into(),\n      file_path: file_path.into(),\n    }\n  }\n\n  /// Создать ошибку рендеринга\n  pub fn render\u003cJ: Into\u003cString\u003e, S: Into\u003cString\u003e, M: Into\u003cString\u003e\u003e(\n    job_id: J,\n    stage: S,\n    message: M,\n  ) -\u003e Self {\n    VideoCompilerError::RenderError {\n      job_id: job_id.into(),\n      stage: stage.into(),\n      message: message.into(),\n    }\n  }\n\n  /// Создать ошибку превью\n  pub fn preview(timestamp: f64, reason: String) -\u003e Self {\n    VideoCompilerError::PreviewError { timestamp, reason }\n  }\n\n  /// Создать ошибку ресурсов\n  pub fn resource\u003cS: Into\u003cString\u003e\u003e(resource_type: S, available: S, required: S) -\u003e Self {\n    VideoCompilerError::ResourceError {\n      resource_type: resource_type.into(),\n      available: available.into(),\n      required: required.into(),\n    }\n  }\n\n  /// Создать ошибку тайм-аута\n  pub fn timeout\u003cS: Into\u003cString\u003e\u003e(operation: S, timeout_seconds: u64) -\u003e Self {\n    VideoCompilerError::TimeoutError {\n      operation: operation.into(),\n      timeout_seconds,\n    }\n  }\n\n  /// Проверить, является ли ошибка критической (требует остановки процесса)\n  pub fn is_critical(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::DependencyMissing(_)\n        | VideoCompilerError::ResourceError { .. }\n        | VideoCompilerError::InternalError(_)\n    )\n  }\n\n  /// Проверить, можно ли повторить операцию\n  pub fn is_retryable(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::IoError(_)\n        | VideoCompilerError::TimeoutError { .. }\n        | VideoCompilerError::CacheError(_)\n    )\n  }\n\n  /// Получить код ошибки для логирования\n  pub fn error_code(\u0026self) -\u003e \u0026'static str {\n    match self {\n      VideoCompilerError::ValidationError(_) =\u003e \"VALIDATION_ERROR\",\n      VideoCompilerError::FFmpegError { .. } =\u003e \"FFMPEG_ERROR\",\n      VideoCompilerError::DependencyMissing(_) =\u003e \"DEPENDENCY_MISSING\",\n      VideoCompilerError::IoError(_) =\u003e \"IO_ERROR\",\n      VideoCompilerError::SerializationError(_) =\u003e \"SERIALIZATION_ERROR\",\n      VideoCompilerError::MediaFileError { .. } =\u003e \"MEDIA_FILE_ERROR\",\n      VideoCompilerError::UnsupportedFormat { .. } =\u003e \"UNSUPPORTED_FORMAT\",\n      VideoCompilerError::RenderError { .. } =\u003e \"RENDER_ERROR\",\n      VideoCompilerError::PreviewError { .. } =\u003e \"PREVIEW_ERROR\",\n      VideoCompilerError::CacheError(_) =\u003e \"CACHE_ERROR\",\n      VideoCompilerError::ConfigError(_) =\u003e \"CONFIG_ERROR\",\n      VideoCompilerError::ResourceError { .. } =\u003e \"RESOURCE_ERROR\",\n      VideoCompilerError::TimeoutError { .. } =\u003e \"TIMEOUT_ERROR\",\n      VideoCompilerError::CancelledError(_) =\u003e \"CANCELLED_ERROR\",\n      VideoCompilerError::GpuError(_) =\u003e \"GPU_ERROR\",\n      VideoCompilerError::GpuUnavailable(_) =\u003e \"GPU_UNAVAILABLE\",\n      VideoCompilerError::Io(_) =\u003e \"IO_ERROR\",\n      VideoCompilerError::InternalError(_) =\u003e \"INTERNAL_ERROR\",\n      VideoCompilerError::Unknown(_) =\u003e \"UNKNOWN_ERROR\",\n    }\n  }\n}\n\n/// Результат операции с дополнительной информацией\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DetailedResult\u003cT\u003e {\n  /// Результат операции\n  pub result: Result\u003cT\u003e,\n  /// Дополнительная информация (предупреждения, метрики)\n  pub metadata: OperationMetadata,\n}\n\n/// Метаданные операции\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OperationMetadata {\n  /// Время выполнения операции\n  pub duration_ms: u64,\n  /// Предупреждения\n  pub warnings: Vec\u003cString\u003e,\n  /// Использованные ресурсы\n  pub resources_used: ResourceUsage,\n  /// Дополнительная информация\n  pub extra: serde_json::Value,\n}\n\n/// Информация об использованных ресурсах\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct ResourceUsage {\n  /// Использовано памяти (байты)\n  pub memory_bytes: u64,\n  /// Использовано места на диске (байты)\n  pub disk_bytes: u64,\n  /// Время CPU (миллисекунды)\n  pub cpu_time_ms: u64,\n  /// Количество обработанных кадров\n  pub frames_processed: u64,\n}\n\nimpl Default for OperationMetadata {\n  fn default() -\u003e Self {\n    Self {\n      duration_ms: 0,\n      warnings: Vec::new(),\n      resources_used: ResourceUsage::default(),\n      extra: serde_json::Value::Null,\n    }\n  }\n}\n\n/// Макрос для удобного создания ошибок валидации\n#[macro_export]\nmacro_rules! validation_error {\n    ($msg:expr) =\u003e {\n        VideoCompilerError::ValidationError($msg.to_string())\n    };\n    ($fmt:expr, $($arg:tt)*) =\u003e {\n        VideoCompilerError::ValidationError(format!($fmt, $($arg)*))\n    };\n}\n\n/// Макрос для удобного создания ошибок рендеринга\n#[macro_export]\nmacro_rules! render_error {\n  ($job_id:expr, $stage:expr, $msg:expr) =\u003e {\n    VideoCompilerError::RenderError {\n      job_id: $job_id.to_string(),\n      stage: $stage.to_string(),\n      message: $msg.to_string(),\n    }\n  };\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  #[allow(unused_imports)]\n  use tokio::time::{timeout, Duration as TokioDuration};\n\n  #[test]\n  fn test_error_creation() {\n    let error = VideoCompilerError::validation(\"Test validation error\");\n    assert!(matches!(error, VideoCompilerError::ValidationError(_)));\n    assert_eq!(error.error_code(), \"VALIDATION_ERROR\");\n  }\n\n  #[test]\n  fn test_error_display() {\n    let error = VideoCompilerError::ffmpeg(\n      Some(1),\n      \"FFmpeg stderr output\",\n      \"ffmpeg -i input.mp4 output.mp4\",\n    );\n    let display_str = error.to_string();\n    assert!(display_str.contains(\"FFmpeg\"));\n    assert!(display_str.contains(\"stderr output\"));\n  }\n\n  #[test]\n  fn test_error_classification() {\n    let critical_error = VideoCompilerError::DependencyMissing(\"FFmpeg\".to_string());\n    assert!(critical_error.is_critical());\n    assert!(!critical_error.is_retryable());\n\n    let retryable_error = VideoCompilerError::IoError(\"Temporary file error\".to_string());\n    assert!(!retryable_error.is_critical());\n    assert!(retryable_error.is_retryable());\n  }\n\n  #[test]\n  fn test_error_codes() {\n    let errors = vec![\n      VideoCompilerError::ValidationError(\"test\".to_string()),\n      VideoCompilerError::FFmpegError {\n        exit_code: Some(1),\n        stderr: \"test\".to_string(),\n        command: \"test\".to_string(),\n      },\n      VideoCompilerError::DependencyMissing(\"test\".to_string()),\n      VideoCompilerError::IoError(\"test\".to_string()),\n    ];\n\n    let expected_codes = [\n      \"VALIDATION_ERROR\",\n      \"FFMPEG_ERROR\",\n      \"DEPENDENCY_MISSING\",\n      \"IO_ERROR\",\n    ];\n\n    for (error, expected_code) in errors.iter().zip(expected_codes.iter()) {\n      assert_eq!(error.error_code(), *expected_code);\n    }\n  }\n\n  #[test]\n  fn test_serialization() {\n    let error = VideoCompilerError::media_file(\"/path/to/video.mp4\", \"File not found\");\n\n    // Сериализация\n    let json = serde_json::to_string(\u0026error).unwrap();\n    assert!(json.contains(\"MediaFileError\"));\n\n    // Десериализация\n    let deserialized: VideoCompilerError = serde_json::from_str(\u0026json).unwrap();\n    match deserialized {\n      VideoCompilerError::MediaFileError { path, reason } =\u003e {\n        assert_eq!(path, \"/path/to/video.mp4\");\n        assert_eq!(reason, \"File not found\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки после десериализации\"),\n    }\n  }\n\n  #[test]\n  fn test_conversion_from_std_errors() {\n    let io_error = std::io::Error::new(std::io::ErrorKind::NotFound, \"File not found\");\n    let video_error: VideoCompilerError = io_error.into();\n    assert!(matches!(video_error, VideoCompilerError::IoError(_)));\n\n    let json_error = serde_json::from_str::\u003cserde_json::Value\u003e(\"invalid json\").unwrap_err();\n    let video_error: VideoCompilerError = json_error.into();\n    assert!(matches!(\n      video_error,\n      VideoCompilerError::SerializationError(_)\n    ));\n  }\n\n  #[test]\n  fn test_detailed_result() {\n    let metadata = OperationMetadata {\n      duration_ms: 1500,\n      warnings: vec![\"Low memory warning\".to_string()],\n      resources_used: ResourceUsage {\n        memory_bytes: 1024 * 1024 * 100, // 100 MB\n        disk_bytes: 1024 * 1024 * 50,    // 50 MB\n        cpu_time_ms: 1200,\n        frames_processed: 300,\n      },\n      extra: serde_json::json!({\"test\": \"value\"}),\n    };\n\n    let detailed_result = DetailedResult {\n      result: Ok(\"Success\".to_string()),\n      metadata,\n    };\n\n    assert!(detailed_result.result.is_ok());\n    assert_eq!(detailed_result.metadata.duration_ms, 1500);\n    assert_eq!(detailed_result.metadata.warnings.len(), 1);\n  }\n\n  #[test]\n  fn test_validation_error_macro() {\n    let error = validation_error!(\"Simple message\");\n    assert!(matches!(error, VideoCompilerError::ValidationError(_)));\n\n    let error = validation_error!(\"Formatted {} message {}\", \"test\", 42);\n    if let VideoCompilerError::ValidationError(msg) = error {\n      assert_eq!(msg, \"Formatted test message 42\");\n    } else {\n      panic!(\"Ожидалась ValidationError\");\n    }\n  }\n\n  #[test]\n  fn test_render_error_macro() {\n    let error = render_error!(\"job-123\", \"encoding\", \"FFmpeg failed\");\n    if let VideoCompilerError::RenderError {\n      job_id,\n      stage,\n      message,\n    } = error\n    {\n      assert_eq!(job_id, \"job-123\");\n      assert_eq!(stage, \"encoding\");\n      assert_eq!(message, \"FFmpeg failed\");\n    } else {\n      panic!(\"Ожидалась RenderError\");\n    }\n  }\n\n  #[test]\n  fn test_all_error_displays() {\n    // Тестируем Display для всех вариантов ошибок\n    let errors: Vec\u003c(VideoCompilerError, \u0026str)\u003e = vec![\n      (VideoCompilerError::DependencyMissing(\"FFmpeg\".to_string()), \"Отсутствует зависимость: FFmpeg\"),\n      (VideoCompilerError::IoError(\"Disk full\".to_string()), \"Ошибка ввода/вывода: Disk full\"),\n      (VideoCompilerError::SerializationError(\"Invalid JSON\".to_string()), \"Ошибка сериализации: Invalid JSON\"),\n      (VideoCompilerError::MediaFileError { path: \"/test.mp4\".to_string(), reason: \"Not found\".to_string() }, \"Ошибка медиа файла '/test.mp4': Not found\"),\n      (VideoCompilerError::UnsupportedFormat { format: \"AVI\".to_string(), file_path: \"/test.avi\".to_string() }, \"Неподдерживаемый формат 'AVI' для файла '/test.avi'\"),\n      (VideoCompilerError::RenderError { job_id: \"123\".to_string(), stage: \"encoding\".to_string(), message: \"Failed\".to_string() }, \"Ошибка рендеринга [123] на этапе 'encoding': Failed\"),\n      (VideoCompilerError::PreviewError { timestamp: 10.5, reason: \"Frame extraction failed\".to_string() }, \"Ошибка генерации превью на 10.5с: Frame extraction failed\"),\n      (VideoCompilerError::CacheError(\"Cache corrupted\".to_string()), \"Ошибка кэша: Cache corrupted\"),\n      (VideoCompilerError::ConfigError(\"Invalid settings\".to_string()), \"Ошибка конфигурации: Invalid settings\"),\n      (VideoCompilerError::ResourceError { resource_type: \"memory\".to_string(), available: \"1GB\".to_string(), required: \"2GB\".to_string() }, \"Нехватка ресурса 'memory': доступно 1GB, требуется 2GB\"),\n      (VideoCompilerError::TimeoutError { operation: \"rendering\".to_string(), timeout_seconds: 30 }, \"Тайм-аут операции 'rendering' (30с)\"),\n      (VideoCompilerError::CancelledError(\"User cancelled\".to_string()), \"Операция отменена: User cancelled\"),\n      (VideoCompilerError::GpuError(\"CUDA out of memory\".to_string()), \"Ошибка GPU: CUDA out of memory\"),\n      (VideoCompilerError::GpuUnavailable(\"No GPU found\".to_string()), \"GPU недоступен: No GPU found\"),\n      (VideoCompilerError::Io(\"Permission denied\".to_string()), \"Ошибка ввода/вывода: Permission denied\"),\n      (VideoCompilerError::InternalError(\"Unexpected state\".to_string()), \"Внутренняя ошибка: Unexpected state\"),\n      (VideoCompilerError::Unknown(\"Something went wrong\".to_string()), \"Неизвестная ошибка: Something went wrong\"),\n    ];\n\n    for (error, expected_display) in errors {\n      let display_str = error.to_string();\n      assert_eq!(display_str, expected_display);\n    }\n  }\n\n  #[test]\n  fn test_all_error_codes() {\n    // Тестируем error_code для всех вариантов\n    let test_cases = vec![\n      (VideoCompilerError::ValidationError(\"test\".to_string()), \"VALIDATION_ERROR\"),\n      (VideoCompilerError::FFmpegError { exit_code: None, stderr: \"test\".to_string(), command: \"test\".to_string() }, \"FFMPEG_ERROR\"),\n      (VideoCompilerError::DependencyMissing(\"test\".to_string()), \"DEPENDENCY_MISSING\"),\n      (VideoCompilerError::IoError(\"test\".to_string()), \"IO_ERROR\"),\n      (VideoCompilerError::SerializationError(\"test\".to_string()), \"SERIALIZATION_ERROR\"),\n      (VideoCompilerError::MediaFileError { path: \"test\".to_string(), reason: \"test\".to_string() }, \"MEDIA_FILE_ERROR\"),\n      (VideoCompilerError::UnsupportedFormat { format: \"test\".to_string(), file_path: \"test\".to_string() }, \"UNSUPPORTED_FORMAT\"),\n      (VideoCompilerError::RenderError { job_id: \"test\".to_string(), stage: \"test\".to_string(), message: \"test\".to_string() }, \"RENDER_ERROR\"),\n      (VideoCompilerError::PreviewError { timestamp: 0.0, reason: \"test\".to_string() }, \"PREVIEW_ERROR\"),\n      (VideoCompilerError::CacheError(\"test\".to_string()), \"CACHE_ERROR\"),\n      (VideoCompilerError::ConfigError(\"test\".to_string()), \"CONFIG_ERROR\"),\n      (VideoCompilerError::ResourceError { resource_type: \"test\".to_string(), available: \"test\".to_string(), required: \"test\".to_string() }, \"RESOURCE_ERROR\"),\n      (VideoCompilerError::TimeoutError { operation: \"test\".to_string(), timeout_seconds: 0 }, \"TIMEOUT_ERROR\"),\n      (VideoCompilerError::CancelledError(\"test\".to_string()), \"CANCELLED_ERROR\"),\n      (VideoCompilerError::GpuError(\"test\".to_string()), \"GPU_ERROR\"),\n      (VideoCompilerError::GpuUnavailable(\"test\".to_string()), \"GPU_UNAVAILABLE\"),\n      (VideoCompilerError::Io(\"test\".to_string()), \"IO_ERROR\"),\n      (VideoCompilerError::InternalError(\"test\".to_string()), \"INTERNAL_ERROR\"),\n      (VideoCompilerError::Unknown(\"test\".to_string()), \"UNKNOWN_ERROR\"),\n    ];\n\n    for (error, expected_code) in test_cases {\n      assert_eq!(error.error_code(), expected_code);\n    }\n  }\n\n  #[test]\n  fn test_gpu_related_errors() {\n    let gpu_error = VideoCompilerError::gpu(\"CUDA initialization failed\");\n    assert!(gpu_error.is_gpu_related());\n    assert!(gpu_error.should_fallback_to_cpu());\n\n    let gpu_unavailable = VideoCompilerError::gpu_unavailable(\"No compatible GPU\");\n    assert!(gpu_unavailable.is_gpu_related());\n    assert!(gpu_unavailable.should_fallback_to_cpu());\n\n    let non_gpu_error = VideoCompilerError::io(\"File not found\");\n    assert!(!non_gpu_error.is_gpu_related());\n    assert!(!non_gpu_error.should_fallback_to_cpu());\n  }\n\n  #[test]\n  fn test_error_message_method() {\n    let error = VideoCompilerError::validation(\"Test error\");\n    assert_eq!(error.message(), \"Ошибка валидации: Test error\");\n  }\n\n  #[test]\n  fn test_helper_constructors() {\n    // Тестируем все вспомогательные конструкторы\n    let unsupported = VideoCompilerError::unsupported_format(\"MOV\", \"/test.mov\");\n    match unsupported {\n      VideoCompilerError::UnsupportedFormat { format, file_path } =\u003e {\n        assert_eq!(format, \"MOV\");\n        assert_eq!(file_path, \"/test.mov\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let render = VideoCompilerError::render(\"job-456\", \"audio-mixing\", \"No audio tracks\");\n    match render {\n      VideoCompilerError::RenderError { job_id, stage, message } =\u003e {\n        assert_eq!(job_id, \"job-456\");\n        assert_eq!(stage, \"audio-mixing\");\n        assert_eq!(message, \"No audio tracks\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let preview = VideoCompilerError::preview(15.5, \"Invalid timestamp\".to_string());\n    match preview {\n      VideoCompilerError::PreviewError { timestamp, reason } =\u003e {\n        assert_eq!(timestamp, 15.5);\n        assert_eq!(reason, \"Invalid timestamp\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let resource = VideoCompilerError::resource(\"disk space\", \"100MB\", \"500MB\");\n    match resource {\n      VideoCompilerError::ResourceError { resource_type, available, required } =\u003e {\n        assert_eq!(resource_type, \"disk space\");\n        assert_eq!(available, \"100MB\");\n        assert_eq!(required, \"500MB\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let timeout = VideoCompilerError::timeout(\"video encoding\", 120);\n    match timeout {\n      VideoCompilerError::TimeoutError { operation, timeout_seconds } =\u003e {\n        assert_eq!(operation, \"video encoding\");\n        assert_eq!(timeout_seconds, 120);\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n  }\n\n  #[test]\n  fn test_is_critical_comprehensive() {\n    // Критические ошибки\n    assert!(VideoCompilerError::DependencyMissing(\"test\".to_string()).is_critical());\n    assert!(VideoCompilerError::ResourceError { resource_type: \"test\".to_string(), available: \"test\".to_string(), required: \"test\".to_string() }.is_critical());\n    assert!(VideoCompilerError::InternalError(\"test\".to_string()).is_critical());\n\n    // Некритические ошибки\n    assert!(!VideoCompilerError::ValidationError(\"test\".to_string()).is_critical());\n    assert!(!VideoCompilerError::IoError(\"test\".to_string()).is_critical());\n    assert!(!VideoCompilerError::TimeoutError { operation: \"test\".to_string(), timeout_seconds: 0 }.is_critical());\n  }\n\n  #[test]\n  fn test_is_retryable_comprehensive() {\n    // Повторяемые ошибки\n    assert!(VideoCompilerError::IoError(\"test\".to_string()).is_retryable());\n    assert!(VideoCompilerError::TimeoutError { operation: \"test\".to_string(), timeout_seconds: 0 }.is_retryable());\n    assert!(VideoCompilerError::CacheError(\"test\".to_string()).is_retryable());\n\n    // Неповторяемые ошибки\n    assert!(!VideoCompilerError::ValidationError(\"test\".to_string()).is_retryable());\n    assert!(!VideoCompilerError::DependencyMissing(\"test\".to_string()).is_retryable());\n    assert!(!VideoCompilerError::UnsupportedFormat { format: \"test\".to_string(), file_path: \"test\".to_string() }.is_retryable());\n  }\n\n  #[test]\n  fn test_uuid_error_conversion() {\n    // Создаём UUID ошибку вручную\n    let uuid_error_str = \"invalid UUID\";\n    let error = VideoCompilerError::InternalError(format!(\"UUID error: {}\", uuid_error_str));\n    match error {\n      VideoCompilerError::InternalError(msg) =\u003e {\n        assert!(msg.contains(\"UUID error\"));\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n  }\n\n  #[tokio::test]\n  async fn test_tokio_elapsed_error_conversion() {\n    // Тестируем конверсию из tokio::time::error::Elapsed\n    // Создаём Elapsed ошибку через тайм-аут\n    let result = timeout(TokioDuration::from_millis(1), async {\n      tokio::time::sleep(TokioDuration::from_millis(10)).await;\n    }).await;\n    \n    if let Err(elapsed) = result {\n      let video_error: VideoCompilerError = elapsed.into();\n      match video_error {\n        VideoCompilerError::TimeoutError { operation, timeout_seconds } =\u003e {\n          assert_eq!(operation, \"Unknown\");\n          assert_eq!(timeout_seconds, 0);\n        }\n        _ =\u003e panic!(\"Ожидалась TimeoutError\"),\n      }\n    }\n  }\n\n  #[test]\n  fn test_operation_metadata_default() {\n    let metadata = OperationMetadata::default();\n    assert_eq!(metadata.duration_ms, 0);\n    assert!(metadata.warnings.is_empty());\n    assert_eq!(metadata.resources_used.memory_bytes, 0);\n    assert_eq!(metadata.resources_used.disk_bytes, 0);\n    assert_eq!(metadata.resources_used.cpu_time_ms, 0);\n    assert_eq!(metadata.resources_used.frames_processed, 0);\n    assert_eq!(metadata.extra, serde_json::Value::Null);\n  }\n\n  #[test]\n  fn test_resource_usage_default() {\n    let usage = ResourceUsage::default();\n    assert_eq!(usage.memory_bytes, 0);\n    assert_eq!(usage.disk_bytes, 0);\n    assert_eq!(usage.cpu_time_ms, 0);\n    assert_eq!(usage.frames_processed, 0);\n  }\n\n  #[test]\n  fn test_detailed_result_serialization() {\n    let metadata = OperationMetadata::default();\n    let detailed_result: DetailedResult\u003cString\u003e = DetailedResult {\n      result: Err(VideoCompilerError::validation(\"Test error\")),\n      metadata,\n    };\n\n    // Сериализация\n    let json = serde_json::to_string(\u0026detailed_result).unwrap();\n    assert!(json.contains(\"ValidationError\"));\n    assert!(json.contains(\"Test error\"));\n\n    // Десериализация\n    let deserialized: DetailedResult\u003cString\u003e = serde_json::from_str(\u0026json).unwrap();\n    assert!(deserialized.result.is_err());\n  }\n\n  #[test]\n  fn test_error_implements_error_trait() {\n    let error = VideoCompilerError::validation(\"Test\");\n    // Проверяем, что VideoCompilerError реализует std::error::Error\n    let _: \u0026dyn std::error::Error = \u0026error;\n  }\n}\n","traces":[{"line":89,"address":[],"length":0,"stats":{"Line":23}},{"line":90,"address":[],"length":0,"stats":{"Line":23}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":7}},{"line":259,"address":[],"length":0,"stats":{"Line":7}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":9}},{"line":278,"address":[],"length":0,"stats":{"Line":9}},{"line":279,"address":[],"length":0,"stats":{"Line":9}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":292,"address":[],"length":0,"stats":{"Line":5}},{"line":298,"address":[],"length":0,"stats":{"Line":5}},{"line":299,"address":[],"length":0,"stats":{"Line":5}},{"line":300,"address":[],"length":0,"stats":{"Line":5}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":8}},{"line":337,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":8}},{"line":347,"address":[],"length":0,"stats":{"Line":24}},{"line":348,"address":[],"length":0,"stats":{"Line":24}},{"line":349,"address":[],"length":0,"stats":{"Line":3}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":352,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":1}},{"line":365,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":2}}],"covered":133,"coverable":135},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","ffmpeg_builder.rs"],"content":"//! FFmpeg Builder - Модуль построения команд FFmpeg\n//!\n//! Этот модуль отвечает за построение команд FFmpeg на основе схемы проекта,\n//! включая обработку треков, клипов, эффектов и настроек экспорта.\n\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse tokio::process::Command;\n\nuse crate::video_compiler::error::Result;\nuse crate::video_compiler::schema::{\n  Clip, Effect, EffectParameter, EffectType, Filter, FilterType, OutputFormat, ProjectSchema,\n  StyleElementType, StyleTemplate, Subtitle, SubtitleAlignX, SubtitleAlignY, SubtitleAnimation,\n  SubtitleAnimationType, SubtitleDirection, SubtitleFontWeight, SubtitlePosition, Template, Track,\n  TrackType, Transition,\n};\n\n/// Построитель команд FFmpeg\n#[derive(Debug, Clone)]\npub struct FFmpegBuilder {\n  /// Схема проекта\n  project: ProjectSchema,\n  /// Настройки построения\n  settings: FFmpegBuilderSettings,\n}\n\nimpl FFmpegBuilder {\n  /// Создать новый построитель\n  pub fn new(project: ProjectSchema) -\u003e Self {\n    Self {\n      project,\n      settings: FFmpegBuilderSettings::default(),\n    }\n  }\n\n  /// Создать построитель с настройками\n  pub fn with_settings(project: ProjectSchema, settings: FFmpegBuilderSettings) -\u003e Self {\n    Self { project, settings }\n  }\n\n  /// Построить команду для рендеринга проекта\n  pub async fn build_render_command(\u0026self, output_path: \u0026Path) -\u003e Result\u003cCommand\u003e {\n    let mut cmd = Command::new(\u0026self.settings.ffmpeg_path);\n\n    // Добавляем входные файлы\n    self.add_input_sources(\u0026mut cmd).await?;\n\n    // Добавляем фильтры\n    self.add_filter_complex(\u0026mut cmd).await?;\n\n    // Добавляем настройки вывода\n    self.add_output_settings(\u0026mut cmd, output_path).await?;\n\n    // Добавляем глобальные параметры\n    self.add_global_options(\u0026mut cmd);\n\n    Ok(cmd)\n  }\n\n  /// Построить команду для генерации превью\n  pub async fn build_preview_command(\n    \u0026self,\n    input_path: \u0026Path,\n    timestamp: f64,\n    output_path: \u0026Path,\n    resolution: (u32, u32),\n  ) -\u003e Result\u003cCommand\u003e {\n    let mut cmd = Command::new(\u0026self.settings.ffmpeg_path);\n\n    // Переход к временной метке\n    cmd.args([\"-ss\", \u0026timestamp.to_string()]);\n\n    // Входной файл\n    cmd.args([\"-i\", \u0026input_path.to_string_lossy()]);\n\n    // Один кадр\n    cmd.args([\"-vframes\", \"1\"]);\n\n    // Масштабирование\n    cmd.args([\"-vf\", \u0026format!(\"scale={}:{}\", resolution.0, resolution.1)]);\n\n    // Качество\n    cmd.args([\"-q:v\", \"2\"]);\n\n    // Перезапись\n    cmd.arg(\"-y\");\n\n    // Выходной файл\n    cmd.arg(output_path);\n\n    Ok(cmd)\n  }\n\n  /// Построить команду для пререндера сегмента видео\n  pub async fn build_prerender_segment_command(\n    \u0026self,\n    start_time: f64,\n    end_time: f64,\n    output_path: \u0026Path,\n    apply_effects: bool,\n  ) -\u003e Result\u003cCommand\u003e {\n    let mut cmd = Command::new(\u0026self.settings.ffmpeg_path);\n\n    // Глобальные опции\n    self.add_global_options(\u0026mut cmd);\n\n    // Добавляем входные источники\n    self.add_input_sources(\u0026mut cmd).await?;\n\n    // Временной диапазон\n    let duration = end_time - start_time;\n\n    // Построить граф фильтров только для указанного сегмента\n    if apply_effects {\n      let filter_complex = self\n        .build_segment_filter_complex(start_time, end_time)\n        .await?;\n      if !filter_complex.is_empty() {\n        cmd.args([\"-filter_complex\", \u0026filter_complex]);\n      }\n    }\n\n    // Обрезаем по времени\n    cmd.args([\"-ss\", \u0026start_time.to_string()]);\n    cmd.args([\"-t\", \u0026duration.to_string()]);\n\n    // Настройки качества для быстрого пререндера\n    cmd.args([\"-c:v\", \"libx264\"]);\n    cmd.args([\"-preset\", \"ultrafast\"]); // Быстрое кодирование\n    cmd.args([\"-crf\", \"23\"]); // Хорошее качество\n\n    // Настройки аудио\n    cmd.args([\"-c:a\", \"aac\"]);\n    cmd.args([\"-b:a\", \"192k\"]);\n\n    // Разрешение и FPS как в проекте\n    let resolution = \u0026self.project.timeline.resolution;\n    cmd.args([\"-s\", \u0026format!(\"{}x{}\", resolution.0, resolution.1)]);\n    cmd.args([\"-r\", \u0026self.project.timeline.fps.to_string()]);\n\n    // Перезапись файла\n    cmd.arg(\"-y\");\n\n    // Выходной файл\n    cmd.arg(output_path);\n\n    Ok(cmd)\n  }\n\n  /// Добавить входные источники\n  async fn add_input_sources(\u0026self, cmd: \u0026mut Command) -\u003e Result\u003c()\u003e {\n    let input_sources = self.collect_input_sources().await?;\n\n    // Проверяем, используется ли аппаратное ускорение\n    if self.project.settings.export.hardware_acceleration {\n      // Добавляем аппаратное декодирование для поддерживаемых кодировщиков\n      if let Some(preferred) = \u0026self.project.settings.export.preferred_gpu_encoder {\n        match preferred.as_str() {\n          \"nvenc\" =\u003e {\n            // NVIDIA CUDA декодирование\n            cmd.args([\"-hwaccel\", \"cuda\"]);\n            cmd.args([\"-hwaccel_output_format\", \"cuda\"]);\n          }\n          \"quicksync\" =\u003e {\n            // Intel QuickSync декодирование\n            cmd.args([\"-hwaccel\", \"qsv\"]);\n            cmd.args([\"-c:v\", \"h264_qsv\"]);\n          }\n          \"vaapi\" =\u003e {\n            // VAAPI декодирование (Linux)\n            cmd.args([\"-hwaccel\", \"vaapi\"]);\n            cmd.args([\"-hwaccel_device\", \"/dev/dri/renderD128\"]);\n            cmd.args([\"-hwaccel_output_format\", \"vaapi\"]);\n          }\n          \"videotoolbox\" =\u003e {\n            // VideoToolbox декодирование (macOS)\n            cmd.args([\"-hwaccel\", \"videotoolbox\"]);\n          }\n          \"amf\" =\u003e {\n            // AMD AMF обычно использует D3D11VA\n            cmd.args([\"-hwaccel\", \"d3d11va\"]);\n          }\n          _ =\u003e {\n            // Без аппаратного декодирования\n          }\n        }\n      }\n    }\n\n    for source in input_sources {\n      // Добавляем входной файл\n      cmd.args([\"-i\", \u0026source.path.to_string_lossy()]);\n    }\n\n    Ok(())\n  }\n\n  /// Собрать список входных источников\n  async fn collect_input_sources(\u0026self) -\u003e Result\u003cVec\u003cInputSource\u003e\u003e {\n    let mut sources = Vec::new();\n    let mut input_index = 0;\n\n    for track in \u0026self.project.tracks {\n      if !track.enabled {\n        continue;\n      }\n\n      for clip in \u0026track.clips {\n        sources.push(InputSource {\n          path: clip.source_path.clone(),\n          start_time: clip.source_start,\n          duration: clip.get_source_duration(),\n          input_index,\n          track_type: track.track_type.clone(),\n        });\n        input_index += 1;\n      }\n    }\n\n    Ok(sources)\n  }\n\n  /// Добавить комплексные фильтры\n  async fn add_filter_complex(\u0026self, cmd: \u0026mut Command) -\u003e Result\u003c()\u003e {\n    let filter_complex = self.build_filter_complex().await?;\n\n    if !filter_complex.is_empty() {\n      cmd.args([\"-filter_complex\", \u0026filter_complex]);\n\n      // Маппинг выходов\n      let has_video = !self.get_video_tracks().is_empty();\n      let has_audio = !self.get_audio_tracks().is_empty();\n      let has_subtitles = !self.project.subtitles.is_empty();\n\n      if has_video {\n        if has_subtitles {\n          cmd.args([\"-map\", \"[outv_with_subs]\"]);\n        } else {\n          cmd.args([\"-map\", \"[outv]\"]);\n        }\n      }\n\n      if has_audio {\n        cmd.args([\"-map\", \"[outa]\"]);\n      }\n    }\n\n    Ok(())\n  }\n\n  /// Построить строку комплексных фильтров\n  async fn build_filter_complex(\u0026self) -\u003e Result\u003cString\u003e {\n    let mut filters = Vec::new();\n    let mut input_index = 0;\n\n    // Обрабатываем видео треки\n    let video_tracks = self.get_video_tracks();\n    if !video_tracks.is_empty() {\n      let video_filter = self\n        .build_video_filter_chain(\u0026video_tracks, \u0026mut input_index)\n        .await?;\n      if !video_filter.is_empty() {\n        filters.push(video_filter);\n      }\n    }\n\n    // Обрабатываем аудио треки\n    let audio_tracks = self.get_audio_tracks();\n    if !audio_tracks.is_empty() {\n      let audio_filter = self\n        .build_audio_filter_chain(\u0026audio_tracks, \u0026mut input_index)\n        .await?;\n      if !audio_filter.is_empty() {\n        filters.push(audio_filter);\n      }\n    }\n\n    // Обрабатываем субтитры\n    if !self.project.subtitles.is_empty() {\n      let subtitle_filter = self.build_subtitle_filter().await?;\n      if !subtitle_filter.is_empty() {\n        filters.push(subtitle_filter);\n      }\n    }\n\n    Ok(filters.join(\";\"))\n  }\n\n  /// Построить цепочку видео фильтров\n  async fn build_video_filter_chain(\n    \u0026self,\n    tracks: \u0026[\u0026Track],\n    input_index: \u0026mut usize,\n  ) -\u003e Result\u003cString\u003e {\n    // Проверяем, используются ли шаблоны\n    let mut template_clips: HashMap\u003cString, Vec\u003c(Clip, usize, String)\u003e\u003e = HashMap::new();\n    let mut regular_clips = Vec::new();\n\n    // Разделяем клипы на обычные и с шаблонами\n    for track in tracks {\n      for (clip_index, clip) in track.clips.iter().enumerate() {\n        if let Some(template_id) = \u0026clip.template_id {\n          let clip_filter_label = format!(\"v{}\", *input_index);\n          template_clips\n            .entry(template_id.clone())\n            .or_default()\n            .push((clip.clone(), *input_index, clip_filter_label));\n        } else {\n          regular_clips.push((clip.clone(), *input_index, clip_index));\n        }\n        *input_index += 1;\n      }\n    }\n\n    let mut all_filters = Vec::new();\n\n    // Обрабатываем клипы с шаблонами\n    for (template_id, clips) in template_clips {\n      if let Some(template) = self.find_template(\u0026template_id) {\n        let template_filter = self.build_template_filter(template, \u0026clips).await?;\n        all_filters.push(template_filter);\n      }\n    }\n\n    // Обрабатываем обычные клипы\n    for (clip, input_idx, clip_idx) in regular_clips {\n      let clip_filters = self.build_clip_filters(\u0026clip, input_idx, clip_idx).await?;\n      if !clip_filters.is_empty() {\n        all_filters.push(clip_filters);\n      }\n    }\n\n    // Обрабатываем переходы между клипами\n    for transition in \u0026self.project.transitions {\n      // Находим клипы для перехода\n      let from_clip = self.find_clip_by_id(\u0026transition.from_clip_id);\n      let to_clip = self.find_clip_by_id(\u0026transition.to_clip_id);\n\n      if let (Some(from_clip), Some(to_clip)) = (from_clip, to_clip) {\n        // Находим индексы входов для клипов\n        let from_input = self.get_clip_input_index(\u0026transition.from_clip_id);\n        let to_input = self.get_clip_input_index(\u0026transition.to_clip_id);\n\n        if let (Some(from_idx), Some(to_idx)) = (from_input, to_input) {\n          let transition_filter = self\n            .build_transition_filter(transition, from_clip, to_clip, from_idx, to_idx)\n            .await?;\n          all_filters.push(transition_filter);\n        }\n      }\n    }\n\n    // Если несколько видео элементов, объединяем их\n    if all_filters.len() \u003e 1 {\n      let concat_filter = format!(\n        \"{}concat=n={}:v=1:a=0[outv]\",\n        all_filters.join(\"\"),\n        all_filters.len()\n      );\n      Ok(concat_filter)\n    } else if all_filters.len() == 1 {\n      Ok(format!(\"{}[outv]\", all_filters[0]))\n    } else {\n      Ok(String::new())\n    }\n  }\n\n  /// Построить цепочку аудио фильтров\n  async fn build_audio_filter_chain(\n    \u0026self,\n    tracks: \u0026[\u0026Track],\n    input_index: \u0026mut usize,\n  ) -\u003e Result\u003cString\u003e {\n    let mut audio_clips = Vec::new();\n    let mut clip_global_index = 0;\n\n    // Собираем все аудио клипы с их временными позициями\n    for track in tracks {\n      for clip in \u0026track.clips {\n        let mut filters = Vec::new();\n\n        // Обрезка аудио по времени источника\n        if clip.source_start \u003e 0.0 || clip.get_source_duration() \u003e 0.0 {\n          filters.push(format!(\n            \"atrim=start={}:duration={}\",\n            clip.source_start,\n            clip.get_source_duration()\n          ));\n        }\n\n        // Изменение скорости аудио\n        if (clip.speed - 1.0).abs() \u003e 0.001 {\n          if clip.speed \u003e 0.5 \u0026\u0026 clip.speed \u003c 2.0 {\n            filters.push(format!(\"atempo={}\", clip.speed));\n          } else {\n            // Для больших изменений скорости используем цепочку atempo\n            let mut temp_speed = clip.speed;\n            while temp_speed \u003e 2.0 {\n              filters.push(\"atempo=2.0\".to_string());\n              temp_speed /= 2.0;\n            }\n            while temp_speed \u003c 0.5 {\n              filters.push(\"atempo=0.5\".to_string());\n              temp_speed *= 2.0;\n            }\n            if (temp_speed - 1.0).abs() \u003e 0.001 {\n              filters.push(format!(\"atempo={}\", temp_speed));\n            }\n          }\n        }\n\n        // Применяем эффекты трека\n        for effect_id in \u0026track.effects {\n          if let Some(effect) = self.find_effect(effect_id) {\n            if self.is_audio_effect(\u0026effect.effect_type) {\n              let effect_filter = self.build_effect_filter(effect).await?;\n              if !effect_filter.is_empty() {\n                filters.push(effect_filter);\n              }\n            }\n          }\n        }\n\n        // Применяем эффекты клипа\n        for effect_id in \u0026clip.effects {\n          if let Some(effect) = self.find_effect(effect_id) {\n            if self.is_audio_effect(\u0026effect.effect_type) {\n              let effect_filter = self.build_effect_filter(effect).await?;\n              if !effect_filter.is_empty() {\n                filters.push(effect_filter);\n              }\n            }\n          }\n        }\n\n        // Применяем громкость\n        let volume = track.volume * clip.volume;\n        if (volume - 1.0).abs() \u003e 0.001 {\n          filters.push(format!(\"volume={}\", volume));\n        }\n\n        // Добавляем задержку для правильного позиционирования на timeline\n        if clip.start_time \u003e 0.0 {\n          filters.push(format!(\"adelay={}s\", clip.start_time));\n        }\n\n        // Создаем цепочку фильтров для клипа\n        let filter_chain = if !filters.is_empty() {\n          format!(\"[{}:a]{}\", *input_index, filters.join(\",\"))\n        } else {\n          format!(\"[{}:a]anull\", *input_index)\n        };\n\n        audio_clips.push((\n          clip.start_time,\n          clip.end_time - clip.start_time,\n          format!(\"{}[a{}]\", filter_chain, clip_global_index),\n        ));\n\n        *input_index += 1;\n        clip_global_index += 1;\n      }\n    }\n\n    // Если нет аудио клипов, возвращаем пустую строку\n    if audio_clips.is_empty() {\n      return Ok(String::new());\n    }\n\n    // Сортируем клипы по времени начала для правильного микширования\n    audio_clips.sort_by(|a, b| a.0.partial_cmp(\u0026b.0).unwrap());\n\n    // Если только один клип, просто возвращаем его\n    if audio_clips.len() == 1 {\n      return Ok(format!(\"{}[outa]\", audio_clips[0].2));\n    }\n\n    // Для нескольких клипов проверяем перекрытия и добавляем кроссфейды\n    let mut processed_clips = Vec::new();\n    let mut _current_output = 0;\n\n    // Обрабатываем клипы попарно для определения перекрытий\n    for i in 0..audio_clips.len() {\n      let (start_time, duration, chain) = \u0026audio_clips[i];\n      let end_time = start_time + duration;\n\n      // Проверяем перекрытие со следующим клипом\n      if i \u003c audio_clips.len() - 1 {\n        let (next_start, _, _) = \u0026audio_clips[i + 1];\n\n        if next_start \u003c \u0026end_time {\n          // Есть перекрытие, добавляем кроссфейд\n          let overlap_duration = end_time - next_start;\n          let crossfade_duration = overlap_duration.min(1.0); // Максимум 1 секунда кроссфейда\n\n          // Применяем fade out к текущему клипу\n          let fade_out = format!(\n            \"{}afade=t=out:st={}:d={}[fade_out_{}]\",\n            chain,\n            duration - crossfade_duration,\n            crossfade_duration,\n            i\n          );\n\n          processed_clips.push(fade_out);\n        } else {\n          // Нет перекрытия, используем клип как есть\n          processed_clips.push(chain.clone());\n        }\n      } else {\n        // Последний клип\n        processed_clips.push(chain.clone());\n      }\n    }\n\n    // Создаем финальную цепочку микширования\n    let filter_chains = processed_clips.join(\";\");\n    let mix_inputs: Vec\u003cString\u003e = (0..audio_clips.len())\n      .map(|i| format!(\"[a{}]\", i))\n      .collect();\n\n    Ok(format!(\n      \"{}{}amix=inputs={}:duration=longest[outa]\",\n      filter_chains,\n      mix_inputs.join(\"\"),\n      audio_clips.len()\n    ))\n  }\n\n  /// Построить фильтр перехода между клипами\n  async fn build_transition_filter(\n    \u0026self,\n    transition: \u0026Transition,\n    from_clip: \u0026Clip,\n    _to_clip: \u0026Clip,\n    from_input: usize,\n    to_input: usize,\n  ) -\u003e Result\u003cString\u003e {\n    // Базовый шаблон для xfade\n    let base_template = if let Some(template) = \u0026transition.ffmpeg_command {\n      template.clone()\n    } else {\n      match transition.transition_type.as_str() {\n        \"fade\" =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\",\n        \"wipe-horizontal\" =\u003e \"xfade=transition=wipeleft:duration={duration}:offset={offset}\",\n        \"wipe-vertical\" =\u003e \"xfade=transition=wipedown:duration={duration}:offset={offset}\",\n        \"wipe-diagonal\" =\u003e \"xfade=transition=wipetl:duration={duration}:offset={offset}\",\n        \"radial-wipe\" =\u003e \"xfade=transition=radial:duration={duration}:offset={offset}\",\n        \"dissolve\" =\u003e \"xfade=transition=dissolve:duration={duration}:offset={offset}\",\n        \"pixelize\" =\u003e \"xfade=transition=pixelize:duration={duration}:offset={offset}\",\n        \"slide\" =\u003e \"xfade=transition=slideleft:duration={duration}:offset={offset}\",\n        \"zoom-blur\" =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\", // fallback\n        \"blinds\" =\u003e \"xfade=transition=hblur:duration={duration}:offset={offset}\",\n        \"iris\" =\u003e \"xfade=transition=circleclose:duration={duration}:offset={offset}\",\n        \"tv-static\" =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\", // fallback\n        // 3D и сложные переходы требуют gl фильтр\n        \"cube-3d\" =\u003e \"gl=transition=cube:duration={duration}:offset={offset}\",\n        \"page-turn\" =\u003e \"gl=transition=pagecurl:duration={duration}:offset={offset}\",\n        \"ripple\" =\u003e \"gl=transition=ripple:duration={duration}:offset={offset}\",\n        \"morph\" =\u003e \"gl=transition=morph:duration={duration}:offset={offset}\",\n        \"glitch\" =\u003e \"gl=transition=glitch:duration={duration}:offset={offset}\",\n        \"kaleidoscope\" =\u003e \"gl=transition=kaleidoscope:duration={duration}:offset={offset}\",\n        \"shatter\" =\u003e \"gl=transition=shatter:duration={duration}:offset={offset}\",\n        \"burn\" =\u003e \"gl=transition=burn:duration={duration}:offset={offset}\",\n        \"swirl\" =\u003e \"gl=transition=swirl:duration={duration}:offset={offset}\",\n        \"wave\" =\u003e \"gl=transition=wave:duration={duration}:offset={offset}\",\n        _ =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\", // Fallback к fade\n      }\n      .to_string()\n    };\n\n    // Подставляем параметры\n    let duration = transition.duration.current;\n    let offset = from_clip.end_time - duration; // Переход начинается за duration секунд до конца первого клипа\n\n    let filter_str = base_template\n      .replace(\"{duration}\", \u0026duration.to_string())\n      .replace(\"{offset}\", \u0026offset.to_string())\n      .replace(\"{fps}\", \u0026self.project.timeline.fps.to_string())\n      .replace(\"{width}\", \u0026self.project.timeline.resolution.0.to_string())\n      .replace(\"{height}\", \u0026self.project.timeline.resolution.1.to_string());\n\n    // Добавляем дополнительные параметры если они есть\n    let mut extra_params = Vec::new();\n\n    if let Some(crate::video_compiler::schema::EffectParameter::String(direction)) =\n      transition.parameters.get(\"direction\")\n    {\n      extra_params.push(format!(\":direction={}\", direction));\n    }\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(intensity)) =\n      transition.parameters.get(\"intensity\")\n    {\n      extra_params.push(format!(\":intensity={}\", intensity));\n    }\n\n    let final_filter = if !extra_params.is_empty() {\n      format!(\"{}{}\", filter_str, extra_params.join(\"\"))\n    } else {\n      filter_str\n    };\n\n    Ok(format!(\n      \"[{}:v][{}:v]{}\",\n      from_input, to_input, final_filter\n    ))\n  }\n\n  /// Построить фильтры для клипа\n  async fn build_clip_filters(\n    \u0026self,\n    clip: \u0026Clip,\n    input_index: usize,\n    clip_index: usize,\n  ) -\u003e Result\u003cString\u003e {\n    let mut filters = Vec::new();\n\n    // Обрезка по времени\n    if clip.source_start \u003e 0.0 || clip.get_source_duration() \u003e 0.0 {\n      filters.push(format!(\n        \"[{}:v]trim=start={}:duration={}\",\n        input_index,\n        clip.source_start,\n        clip.get_source_duration()\n      ));\n    } else {\n      filters.push(format!(\"[{}:v]\", input_index));\n    }\n\n    // Изменение скорости\n    if (clip.speed - 1.0).abs() \u003e 0.001 {\n      filters.push(format!(\"setpts={}*PTS\", 1.0 / clip.speed));\n    }\n\n    // Применяем эффекты клипа\n    for effect_id in \u0026clip.effects {\n      if let Some(effect) = self.find_effect(effect_id) {\n        let effect_filter = self.build_effect_filter(effect).await?;\n        if !effect_filter.is_empty() {\n          filters.push(effect_filter);\n        }\n      }\n    }\n\n    // Применяем фильтры клипа\n    for filter_id in \u0026clip.filters {\n      if let Some(filter) = self.find_filter(filter_id) {\n        let filter_str = self.build_filter_string(filter).await?;\n        if !filter_str.is_empty() {\n          filters.push(filter_str);\n        }\n      }\n    }\n\n    let mut filter_chain = if filters.len() \u003e 1 {\n      filters.join(\",\")\n    } else if filters.len() == 1 {\n      filters[0].clone()\n    } else {\n      format!(\"[{}:v]\", input_index)\n    };\n\n    // Применяем стильный шаблон если есть\n    if let Some(style_template_id) = \u0026clip.style_template_id {\n      if let Some(style_template) = self.find_style_template(style_template_id) {\n        let style_filter = self\n          .build_style_template_filter(style_template, clip, input_index)\n          .await?;\n        if !style_filter.is_empty() {\n          filter_chain = style_filter;\n        }\n      }\n    }\n\n    Ok(format!(\"{}[v{}];\", filter_chain, clip_index))\n  }\n\n  /// Построить фильтр для эффекта\n  async fn build_effect_filter(\u0026self, effect: \u0026Effect) -\u003e Result\u003cString\u003e {\n    if !effect.enabled {\n      return Ok(String::new());\n    }\n\n    // Если есть пользовательская FFmpeg команда, используем её\n    if let Some(template) = \u0026effect.ffmpeg_command {\n      return Ok(self.process_ffmpeg_template(template, effect));\n    }\n\n    match effect.effect_type {\n      EffectType::Blur =\u003e {\n        // Frontend использует \"radius\"\n        let radius = match effect.parameters.get(\"radius\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 2.0,\n        };\n        Ok(format!(\"boxblur={}:1\", radius))\n      }\n      EffectType::Brightness =\u003e {\n        // Frontend использует \"intensity\", также проверяем \"value\" для обратной совместимости\n        let value = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"value\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 0.0,\n          },\n        };\n        Ok(format!(\"eq=brightness={}\", value))\n      }\n      EffectType::Contrast =\u003e {\n        // Frontend использует \"intensity\", также проверяем \"value\" для обратной совместимости\n        let value = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"value\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 1.0,\n          },\n        };\n        Ok(format!(\"eq=contrast={}\", value))\n      }\n      EffectType::Saturation =\u003e {\n        // Frontend использует \"intensity\", также проверяем \"value\" для обратной совместимости\n        let value = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"value\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 1.0,\n          },\n        };\n        Ok(format!(\"eq=saturation={}\", value))\n      }\n      EffectType::Speed =\u003e {\n        let speed = match effect.parameters.get(\"speed\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"setpts={}*PTS\", 1.0 / speed))\n      }\n      EffectType::Reverse =\u003e Ok(\"reverse\".to_string()),\n      EffectType::Grayscale =\u003e Ok(\"hue=s=0\".to_string()),\n      EffectType::Sepia =\u003e {\n        Ok(\"colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\".to_string())\n      }\n      EffectType::HueRotate =\u003e {\n        let angle = match effect.parameters.get(\"angle\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        Ok(format!(\"hue=h={}\", angle))\n      }\n      EffectType::Vintage =\u003e Ok(\"curves=vintage\".to_string()),\n      EffectType::Duotone =\u003e {\n        let shadows = match effect.parameters.get(\"shadows\") {\n          Some(EffectParameter::Color(val)) =\u003e format!(\"#{:06x}\", val \u0026 0xFFFFFF),\n          _ =\u003e \"#1e3a8a\".to_string(),\n        };\n        let highlights = match effect.parameters.get(\"highlights\") {\n          Some(EffectParameter::Color(val)) =\u003e format!(\"#{:06x}\", val \u0026 0xFFFFFF),\n          _ =\u003e \"#fbbf24\".to_string(),\n        };\n        Ok(format!(\n          \"duotone=shadows={}:highlights={}\",\n          shadows, highlights\n        ))\n      }\n      EffectType::Dreamy =\u003e Ok(\"gblur=sigma=1,eq=brightness=0.1:contrast=0.9\".to_string()),\n      EffectType::Infrared =\u003e Ok(\n        \"colorchannelmixer=rr=0:rg=0:rb=0:ra=1:gr=1:gg=0:gb=0:ga=0:br=0:bg=0:bb=0:ba=0\".to_string(),\n      ),\n      EffectType::Matrix =\u003e {\n        Ok(\"colorchannelmixer=rr=0:rg=1:rb=0:gr=0:gg=1:gb=0:br=0:bg=1:bb=0\".to_string())\n      }\n      EffectType::Arctic =\u003e {\n        Ok(\"eq=brightness=0.2:contrast=1.1:saturation=0.8,colorbalance=rs=-0.2:bs=0.2\".to_string())\n      }\n      EffectType::Sunset =\u003e {\n        Ok(\"eq=brightness=0.1:contrast=1.1,colorbalance=rs=0.3:gs=0.1:bs=-0.2\".to_string())\n      }\n      EffectType::Lomo =\u003e Ok(\"curves=cross_process,vignette=angle=PI/4\".to_string()),\n      EffectType::Twilight =\u003e {\n        Ok(\"eq=brightness=-0.1:contrast=1.2,colorbalance=rs=0.1:gs=-0.1:bs=0.2\".to_string())\n      }\n      EffectType::Neon =\u003e Ok(\"eq=brightness=0.2:contrast=1.4:saturation=2.0,hue=h=30\".to_string()),\n      EffectType::Invert =\u003e Ok(\"negate\".to_string()),\n      EffectType::Vignette =\u003e {\n        // Frontend использует \"intensity\" и \"radius\"\n        let intensity = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"angle\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 0.3,\n          },\n        };\n        let _radius = match effect.parameters.get(\"radius\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.8,\n        };\n        // Простая виньетка, так как сложная формула из frontend не поддерживается напрямую\n        Ok(format!(\"vignette=angle={}:x0=w/2:y0=h/2\", 1.57 + intensity))\n      }\n      EffectType::FilmGrain =\u003e {\n        // Frontend использует \"intensity\"\n        let strength = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"strength\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 0.5,\n          },\n        };\n        Ok(format!(\"noise=alls={}:allf=t\", (strength * 20.0) as i32))\n      }\n      EffectType::ChromaticAberration =\u003e {\n        Ok(\"chromakey=0x00ff00:0.1,pad=iw+20:ih+20:10:10\".to_string())\n      }\n      EffectType::LensFlare =\u003e Ok(\"flare=x=0.7:y=0.3:s=100\".to_string()),\n      EffectType::Glow =\u003e {\n        let intensity = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\n          \"gblur=sigma={},blend=all_mode=screen\",\n          intensity * 2.0\n        ))\n      }\n      EffectType::Sharpen =\u003e {\n        let amount = match effect.parameters.get(\"amount\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"unsharp=5:5:{}\", amount))\n      }\n      EffectType::Stabilization =\u003e Ok(\"deshake\".to_string()),\n      EffectType::NoiseReduction =\u003e Ok(\"hqdn3d\".to_string()),\n      EffectType::Noir =\u003e {\n        // Noir эффект - черно-белый с высоким контрастом\n        Ok(\"hue=s=0,eq=contrast=1.5:brightness=-0.1\".to_string())\n      }\n      EffectType::Cyberpunk =\u003e {\n        // Cyberpunk - неоновые цвета с искажениями\n        Ok(\n          \"eq=brightness=0.1:contrast=1.8:saturation=1.5,colorbalance=rs=0.5:gs=-0.3:bs=0.8\"\n            .to_string(),\n        )\n      }\n      // Аудио эффекты\n      EffectType::AudioFadeIn =\u003e {\n        let duration = match effect.parameters.get(\"duration\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"afade=t=in:d={}\", duration))\n      }\n      EffectType::AudioFadeOut =\u003e {\n        let duration = match effect.parameters.get(\"duration\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"afade=t=out:d={}\", duration))\n      }\n      EffectType::AudioCrossfade =\u003e {\n        let duration = match effect.parameters.get(\"duration\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"acrossfade=d={}\", duration))\n      }\n      EffectType::AudioEqualizer =\u003e {\n        let gain_low = match effect.parameters.get(\"gain_low\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        let gain_mid = match effect.parameters.get(\"gain_mid\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        let gain_high = match effect.parameters.get(\"gain_high\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        Ok(format!(\n          \"equalizer=f=100:g={}:t=h,equalizer=f=1000:g={}:t=h,equalizer=f=10000:g={}:t=h\",\n          gain_low, gain_mid, gain_high\n        ))\n      }\n      EffectType::AudioCompressor =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -20.0,\n        };\n        let ratio = match effect.parameters.get(\"ratio\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 4.0,\n        };\n        let attack = match effect.parameters.get(\"attack\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 5.0,\n        };\n        let release = match effect.parameters.get(\"release\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 50.0,\n        };\n        Ok(format!(\n          \"acompressor=threshold={}:ratio={}:attack={}:release={}\",\n          threshold, ratio, attack, release\n        ))\n      }\n      EffectType::AudioReverb =\u003e {\n        let room_size = match effect.parameters.get(\"room_size\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        let _damping = match effect.parameters.get(\"damping\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        let _wet = match effect.parameters.get(\"wet\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.3,\n        };\n        Ok(format!(\n          \"aecho=0.8:0.9:{}:0.3,aecho=0.8:0.7:{}:0.25\",\n          60.0 + room_size * 40.0,\n          40.0 + room_size * 30.0\n        ))\n      }\n      EffectType::AudioDelay =\u003e {\n        let delay = match effect.parameters.get(\"delay\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        let decay = match effect.parameters.get(\"decay\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.3,\n        };\n        Ok(format!(\"aecho=0.8:{}:{}:0.5\", decay, delay * 1000.0))\n      }\n      EffectType::AudioChorus =\u003e {\n        let rate = match effect.parameters.get(\"rate\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        let depth = match effect.parameters.get(\"depth\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\"chorus=0.5:0.9:50:0.4:{}:{}:t\", depth, rate))\n      }\n      EffectType::AudioDistortion =\u003e {\n        let amount = match effect.parameters.get(\"amount\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\"aoverload={}:{}\", amount * 10.0, amount * 10.0))\n      }\n      EffectType::AudioNormalize =\u003e {\n        let target = match effect.parameters.get(\"target\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -23.0,\n        };\n        Ok(format!(\"loudnorm=I={}:TP=-1.5:LRA=11\", target))\n      }\n      EffectType::AudioDenoise =\u003e {\n        let amount = match effect.parameters.get(\"amount\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\"afftdn=nr={}\", amount * 20.0))\n      }\n      EffectType::AudioPitch =\u003e {\n        let pitch = match effect.parameters.get(\"pitch\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        Ok(format!(\"asetrate=r=48000*2^({}/12),aresample=48000\", pitch))\n      }\n      EffectType::AudioTempo =\u003e {\n        let tempo = match effect.parameters.get(\"tempo\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"atempo={}\", tempo))\n      }\n      EffectType::AudioDucking =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -30.0,\n        };\n        let ratio = match effect.parameters.get(\"ratio\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 6.0,\n        };\n        Ok(format!(\n          \"sidechaincompress=threshold={}:ratio={}\",\n          threshold, ratio\n        ))\n      }\n      EffectType::AudioGate =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -35.0,\n        };\n        let attack = match effect.parameters.get(\"attack\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 5.0,\n        };\n        Ok(format!(\"agate=threshold={}:attack={}\", threshold, attack))\n      }\n      EffectType::AudioLimiter =\u003e {\n        let limit = match effect.parameters.get(\"limit\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -1.0,\n        };\n        Ok(format!(\"alimiter=limit={}\", limit))\n      }\n      EffectType::AudioExpander =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -40.0,\n        };\n        let ratio = match effect.parameters.get(\"ratio\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 2.0,\n        };\n        Ok(format!(\n          \"acompressor=threshold={}:ratio={}:knee=2.0:makeup=0\",\n          threshold,\n          1.0 / ratio\n        ))\n      }\n      EffectType::AudioPan =\u003e {\n        let pan = match effect.parameters.get(\"pan\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        let left = 1.0 - (pan + 1.0) / 2.0;\n        let right = (pan + 1.0) / 2.0;\n        Ok(format!(\"pan=stereo|c0={}*c0|c1={}*c1\", left, right))\n      }\n      EffectType::AudioStereoWidth =\u003e {\n        let width = match effect.parameters.get(\"width\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"stereowidth=width={}\", width))\n      }\n      EffectType::AudioHighpass =\u003e {\n        let frequency = match effect.parameters.get(\"frequency\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 100.0,\n        };\n        Ok(format!(\"highpass=f={}\", frequency))\n      }\n      EffectType::AudioLowpass =\u003e {\n        let frequency = match effect.parameters.get(\"frequency\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 10000.0,\n        };\n        Ok(format!(\"lowpass=f={}\", frequency))\n      }\n      EffectType::AudioBandpass =\u003e {\n        let frequency = match effect.parameters.get(\"frequency\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1000.0,\n        };\n        let width = match effect.parameters.get(\"width\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 100.0,\n        };\n        Ok(format!(\"bandpass=f={}:w={}\", frequency, width))\n      }\n    }\n  }\n\n  /// Проверить, является ли эффект аудио эффектом\n  fn is_audio_effect(\u0026self, effect_type: \u0026EffectType) -\u003e bool {\n    matches!(\n      effect_type,\n      EffectType::AudioFadeIn\n        | EffectType::AudioFadeOut\n        | EffectType::AudioCrossfade\n        | EffectType::AudioEqualizer\n        | EffectType::AudioCompressor\n        | EffectType::AudioReverb\n        | EffectType::AudioDelay\n        | EffectType::AudioChorus\n        | EffectType::AudioDistortion\n        | EffectType::AudioNormalize\n        | EffectType::AudioDenoise\n        | EffectType::AudioPitch\n        | EffectType::AudioTempo\n        | EffectType::AudioDucking\n        | EffectType::AudioGate\n        | EffectType::AudioLimiter\n        | EffectType::AudioExpander\n        | EffectType::AudioPan\n        | EffectType::AudioStereoWidth\n        | EffectType::AudioHighpass\n        | EffectType::AudioLowpass\n        | EffectType::AudioBandpass\n    )\n  }\n\n  /// Обработать шаблон FFmpeg команды с параметрами эффекта\n  fn process_ffmpeg_template(\u0026self, template: \u0026str, effect: \u0026Effect) -\u003e String {\n    let mut result = template.to_string();\n\n    // Заменяем плейсхолдеры параметрами\n    for (key, value) in \u0026effect.parameters {\n      let placeholder = format!(\"{{{}}}\", key);\n      let value_str = match value {\n        EffectParameter::Float(v) =\u003e v.to_string(),\n        EffectParameter::Int(v) =\u003e v.to_string(),\n        EffectParameter::String(v) =\u003e v.clone(),\n        EffectParameter::Bool(v) =\u003e if *v { \"1\" } else { \"0\" }.to_string(),\n        EffectParameter::Color(v) =\u003e format!(\"#{:06x}\", v \u0026 0xFFFFFF),\n        EffectParameter::FloatArray(v) =\u003e v\n          .iter()\n          .map(|f| f.to_string())\n          .collect::\u003cVec\u003c_\u003e\u003e()\n          .join(\":\"),\n        EffectParameter::FilePath(v) =\u003e v.to_string_lossy().to_string(),\n      };\n      result = result.replace(\u0026placeholder, \u0026value_str);\n    }\n\n    result\n  }\n\n  /// Построить видео эффект\n  async fn build_video_effect_filter(\u0026self, effect: \u0026Effect) -\u003e Result\u003cString\u003e {\n    match effect.name.as_str() {\n      \"blur\" =\u003e {\n        if let Some(crate::video_compiler::schema::EffectParameter::Float(radius)) =\n          effect.parameters.get(\"radius\")\n        {\n          Ok(format!(\"boxblur={}\", radius))\n        } else {\n          Ok(\"boxblur=2\".to_string())\n        }\n      }\n      \"brightness\" =\u003e {\n        if let Some(crate::video_compiler::schema::EffectParameter::Float(value)) =\n          effect.parameters.get(\"brightness\")\n        {\n          Ok(format!(\"eq=brightness={}\", value))\n        } else {\n          Ok(String::new())\n        }\n      }\n      \"contrast\" =\u003e {\n        if let Some(crate::video_compiler::schema::EffectParameter::Float(value)) =\n          effect.parameters.get(\"contrast\")\n        {\n          Ok(format!(\"eq=contrast={}\", value))\n        } else {\n          Ok(String::new())\n        }\n      }\n      _ =\u003e Ok(String::new()),\n    }\n  }\n\n  /// Построить фильтр цветокоррекции\n  async fn build_color_correction_filter(\u0026self, effect: \u0026Effect) -\u003e Result\u003cString\u003e {\n    let mut eq_params = Vec::new();\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(brightness)) =\n      effect.parameters.get(\"brightness\")\n    {\n      eq_params.push(format!(\"brightness={}\", brightness));\n    }\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(contrast)) =\n      effect.parameters.get(\"contrast\")\n    {\n      eq_params.push(format!(\"contrast={}\", contrast));\n    }\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(saturation)) =\n      effect.parameters.get(\"saturation\")\n    {\n      eq_params.push(format!(\"saturation={}\", saturation));\n    }\n\n    if !eq_params.is_empty() {\n      Ok(format!(\"eq={}\", eq_params.join(\":\")))\n    } else {\n      Ok(String::new())\n    }\n  }\n\n  /// Добавить настройки вывода\n  async fn add_output_settings(\u0026self, cmd: \u0026mut Command, output_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    let export_settings = \u0026self.project.settings.export;\n\n    // Аппаратное ускорение (устанавливает видео кодек)\n    if export_settings.hardware_acceleration {\n      self.add_hardware_acceleration(cmd).await;\n    } else {\n      // Программный кодек видео\n      self.add_cpu_encoding(cmd, export_settings.quality);\n    }\n\n    // Аудио кодек\n    match export_settings.format {\n      OutputFormat::Mp4 | OutputFormat::Mov =\u003e {\n        cmd.args([\"-c:a\", \"aac\"]);\n      }\n      OutputFormat::Avi =\u003e {\n        cmd.args([\"-c:a\", \"mp3\"]);\n      }\n      OutputFormat::Mkv =\u003e {\n        cmd.args([\"-c:a\", \"aac\"]);\n      }\n      OutputFormat::WebM =\u003e {\n        cmd.args([\"-c:a\", \"libopus\"]);\n      }\n      _ =\u003e {\n        cmd.args([\"-c:a\", \"aac\"]);\n      }\n    }\n\n    // Битрейт видео (только если не используется CQ/CRF режим)\n    if !export_settings.hardware_acceleration {\n      cmd.args([\"-b:v\", \u0026format!(\"{}k\", export_settings.video_bitrate)]);\n    }\n\n    // Битрейт аудио\n    cmd.args([\"-b:a\", \u0026format!(\"{}k\", export_settings.audio_bitrate)]);\n\n    // FPS\n    cmd.args([\"-r\", \u0026self.project.timeline.fps.to_string()]);\n\n    // Разрешение\n    cmd.args([\n      \"-s\",\n      \u0026format!(\n        \"{}x{}\",\n        self.project.timeline.resolution.0, self.project.timeline.resolution.1\n      ),\n    ]);\n\n    // Дополнительные аргументы\n    for arg in \u0026export_settings.ffmpeg_args {\n      cmd.arg(arg);\n    }\n\n    // Выходной файл\n    cmd.arg(output_path);\n\n    Ok(())\n  }\n\n  /// Добавить аппаратное ускорение\n  async fn add_hardware_acceleration(\u0026self, cmd: \u0026mut Command) {\n    use crate::video_compiler::gpu::{GpuDetector, GpuEncoder, GpuHelper};\n\n    // Создаем детектор GPU\n    let detector = GpuDetector::new(self.settings.ffmpeg_path.clone());\n\n    // Получаем качество из настроек экспорта\n    let quality = self.project.settings.export.quality;\n\n    // Получаем кодировщик: либо предпочитаемый пользователем, либо рекомендуемый системой\n    let encoder = if let Some(preferred) = \u0026self.project.settings.export.preferred_gpu_encoder {\n      // Пытаемся использовать предпочитаемый кодировщик\n      match preferred.as_str() {\n        \"nvenc\" =\u003e Some(GpuEncoder::Nvenc),\n        \"quicksync\" =\u003e Some(GpuEncoder::QuickSync),\n        \"vaapi\" =\u003e Some(GpuEncoder::Vaapi),\n        \"videotoolbox\" =\u003e Some(GpuEncoder::VideoToolbox),\n        \"amf\" =\u003e Some(GpuEncoder::AMF),\n        _ =\u003e detector.get_recommended_encoder().await.unwrap_or(None),\n      }\n    } else {\n      detector.get_recommended_encoder().await.unwrap_or(None)\n    };\n\n    // Пытаемся использовать выбранный кодировщик\n    if let Some(encoder) = encoder {\n      // Выбираем кодек в зависимости от формата\n      let codec = match self.project.settings.export.format {\n        OutputFormat::Mp4 | OutputFormat::Mov =\u003e encoder.h264_codec_name(),\n        OutputFormat::WebM =\u003e \"libvpx-vp9\", // WebM не поддерживает GPU кодирование\n        _ =\u003e encoder.h264_codec_name(),\n      };\n\n      // Если это GPU кодек\n      if encoder.is_hardware() \u0026\u0026 codec != \"libvpx-vp9\" {\n        cmd.args([\"-c:v\", codec]);\n\n        // Добавляем специфичные параметры для GPU\n        let gpu_params = GpuHelper::get_ffmpeg_params(\u0026encoder, quality);\n        for param in gpu_params {\n          cmd.arg(param);\n        }\n\n        // Добавляем специфичные параметры для платформы\n        match encoder {\n          GpuEncoder::Nvenc =\u003e {\n            // Дополнительные оптимизации для NVENC\n            cmd.args([\"-gpu\", \"0\"]); // Использовать первый GPU\n            cmd.args([\"-b:v\", \"0\"]); // Автоматический битрейт\n          }\n          GpuEncoder::QuickSync =\u003e {\n            // Дополнительные оптимизации для QuickSync\n            cmd.args([\"-init_hw_device\", \"qsv=hw\"]);\n            cmd.args([\"-filter_hw_device\", \"hw\"]);\n          }\n          GpuEncoder::VideoToolbox =\u003e {\n            // macOS специфичные настройки\n            cmd.args([\"-allow_sw\", \"1\"]);\n          }\n          _ =\u003e {}\n        }\n\n        log::info!(\n          \"Используется GPU кодировщик: {:?} ({}), качество: {}\",\n          encoder,\n          codec,\n          quality\n        );\n      } else {\n        // Fallback на CPU для WebM или если GPU недоступен\n        self.add_cpu_encoding(cmd, quality);\n      }\n    } else {\n      // Fallback на CPU кодирование\n      self.add_cpu_encoding(cmd, quality);\n      log::warn!(\"GPU ускорение недоступно, используется CPU кодирование\");\n    }\n  }\n\n  /// Добавить CPU кодирование\n  fn add_cpu_encoding(\u0026self, cmd: \u0026mut Command, quality: u8) {\n    match self.project.settings.export.format {\n      OutputFormat::Mp4 | OutputFormat::Mov | OutputFormat::Avi =\u003e {\n        cmd.args([\"-c:v\", \"libx264\"]);\n        let crf = self.quality_to_crf(quality);\n        cmd.args([\"-crf\", \u0026crf.to_string()]);\n        cmd.args([\"-preset\", \"medium\"]);\n      }\n      OutputFormat::WebM =\u003e {\n        cmd.args([\"-c:v\", \"libvpx-vp9\"]);\n        cmd.args([\"-b:v\", \"0\"]); // VBR\n        let crf = self.quality_to_crf(quality);\n        cmd.args([\"-crf\", \u0026crf.to_string()]);\n        cmd.args([\"-deadline\", \"good\"]);\n      }\n      OutputFormat::Mkv =\u003e {\n        cmd.args([\"-c:v\", \"libx265\"]);\n        let crf = self.quality_to_crf(quality);\n        cmd.args([\"-crf\", \u0026crf.to_string()]);\n        cmd.args([\"-preset\", \"medium\"]);\n      }\n      _ =\u003e {\n        cmd.args([\"-c:v\", \"libx264\"]);\n        cmd.args([\"-crf\", \"23\"]);\n      }\n    }\n  }\n\n  /// Добавить глобальные опции\n  fn add_global_options(\u0026self, cmd: \u0026mut Command) {\n    // Перезапись выходного файла\n    cmd.arg(\"-y\");\n\n    // Скрыть баннер\n    cmd.arg(\"-hide_banner\");\n\n    // Количество потоков\n    if let Some(threads) = self.settings.threads {\n      cmd.args([\"-threads\", \u0026threads.to_string()]);\n    }\n\n    // Логирование\n    cmd.args([\"-loglevel\", \"info\"]);\n\n    // Статистика прогресса\n    cmd.arg(\"-progress\");\n    cmd.arg(\"pipe:2\");\n  }\n\n  /// Конвертировать качество (0-100) в CRF (0-51)\n  fn quality_to_crf(\u0026self, quality: u8) -\u003e u8 {\n    // Инвертируем: высокое качество = низкий CRF\n    let quality = quality.min(100) as u32;\n    let crf = (51 * (100 - quality)) / 100;\n    crf.min(51) as u8\n  }\n\n  /// Получить видео треки\n  fn get_video_tracks(\u0026self) -\u003e Vec\u003c\u0026Track\u003e {\n    self\n      .project\n      .tracks\n      .iter()\n      .filter(|track| track.track_type == TrackType::Video \u0026\u0026 track.enabled)\n      .collect()\n  }\n\n  /// Получить аудио треки\n  fn get_audio_tracks(\u0026self) -\u003e Vec\u003c\u0026Track\u003e {\n    self\n      .project\n      .tracks\n      .iter()\n      .filter(|track| track.track_type == TrackType::Audio \u0026\u0026 track.enabled)\n      .collect()\n  }\n\n  /// Найти эффект по ID\n  fn find_effect(\u0026self, effect_id: \u0026str) -\u003e Option\u003c\u0026Effect\u003e {\n    self\n      .project\n      .effects\n      .iter()\n      .find(|effect| effect.id == effect_id)\n  }\n\n  /// Найти фильтр по ID\n  fn find_filter(\u0026self, filter_id: \u0026str) -\u003e Option\u003c\u0026Filter\u003e {\n    self\n      .project\n      .filters\n      .iter()\n      .find(|filter| filter.id == filter_id)\n  }\n\n  /// Найти клип по ID\n  fn find_clip_by_id(\u0026self, id: \u0026str) -\u003e Option\u003c\u0026Clip\u003e {\n    for track in \u0026self.project.tracks {\n      if let Some(clip) = track.clips.iter().find(|c| c.id == id) {\n        return Some(clip);\n      }\n    }\n    None\n  }\n\n  /// Получить индекс входа для клипа\n  fn get_clip_input_index(\u0026self, clip_id: \u0026str) -\u003e Option\u003cusize\u003e {\n    let mut index = 0;\n    for track in \u0026self.project.tracks {\n      for clip in \u0026track.clips {\n        if clip.id == clip_id {\n          return Some(index);\n        }\n        index += 1;\n      }\n    }\n    None\n  }\n\n  /// Найти шаблон по ID\n  fn find_template(\u0026self, template_id: \u0026str) -\u003e Option\u003c\u0026Template\u003e {\n    self\n      .project\n      .templates\n      .iter()\n      .find(|template| template.id == template_id)\n  }\n\n  /// Найти стильный шаблон по ID\n  fn find_style_template(\u0026self, style_template_id: \u0026str) -\u003e Option\u003c\u0026StyleTemplate\u003e {\n    self\n      .project\n      .style_templates\n      .iter()\n      .find(|template| template.id == style_template_id)\n  }\n\n  /// Построить строку фильтра для FFmpeg\n  async fn build_filter_string(\u0026self, filter: \u0026Filter) -\u003e Result\u003cString\u003e {\n    if !filter.enabled {\n      return Ok(String::new());\n    }\n\n    // Если есть пользовательская FFmpeg команда, используем её\n    if let Some(ffmpeg_cmd) = \u0026filter.ffmpeg_command {\n      return Ok(ffmpeg_cmd.clone());\n    }\n\n    // Генерируем фильтр на основе типа\n    match filter.filter_type {\n      FilterType::Brightness =\u003e {\n        let value = filter.parameters.get(\"brightness\").unwrap_or(\u00260.0);\n        // FFmpeg использует brightness от -1 до 1, где 0 - нормальная яркость\n        Ok(format!(\"eq=brightness={}\", value))\n      }\n      FilterType::Contrast =\u003e {\n        let value = filter.parameters.get(\"contrast\").unwrap_or(\u00261.0);\n        // FFmpeg использует contrast от 0 до 2, где 1 - нормальный контраст\n        Ok(format!(\"eq=contrast={}\", value))\n      }\n      FilterType::Saturation =\u003e {\n        let value = filter.parameters.get(\"saturation\").unwrap_or(\u00261.0);\n        // FFmpeg использует saturation от 0 до 3, где 1 - нормальная насыщенность\n        Ok(format!(\"eq=saturation={}\", value))\n      }\n      FilterType::Gamma =\u003e {\n        let value = filter.parameters.get(\"gamma\").unwrap_or(\u00261.0);\n        // FFmpeg использует gamma от 0.1 до 10, где 1 - нормальная гамма\n        Ok(format!(\"eq=gamma={}\", value))\n      }\n      FilterType::Hue =\u003e {\n        let value = filter.parameters.get(\"hue\").unwrap_or(\u00260.0);\n        // FFmpeg использует hue в градусах\n        Ok(format!(\"hue=h={}\", value))\n      }\n      FilterType::Temperature =\u003e {\n        // Температура цвета через colortemperature фильтр\n        let value = filter.parameters.get(\"temperature\").unwrap_or(\u00266500.0);\n        Ok(format!(\"colortemperature=temperature={}\", value))\n      }\n      FilterType::Blur =\u003e {\n        let radius = filter.parameters.get(\"radius\").unwrap_or(\u00265.0);\n        Ok(format!(\"boxblur={}:{}\", radius, radius))\n      }\n      FilterType::Sharpen =\u003e {\n        let amount = filter.parameters.get(\"amount\").unwrap_or(\u00261.0);\n        Ok(format!(\"unsharp=5:5:{}:5:5:0\", amount))\n      }\n      FilterType::Vignette =\u003e {\n        let angle = filter.parameters.get(\"angle\").unwrap_or(\u00260.0);\n        let x0 = filter.parameters.get(\"x0\").unwrap_or(\u00260.5);\n        let y0 = filter.parameters.get(\"y0\").unwrap_or(\u00260.5);\n        Ok(format!(\"vignette=angle={}:x0={}:y0={}\", angle, x0, y0))\n      }\n      FilterType::Grain =\u003e {\n        let amount = filter.parameters.get(\"amount\").unwrap_or(\u00260.1);\n        Ok(format!(\"noise=alls={}:allf=t\", amount * 100.0))\n      }\n      _ =\u003e {\n        // Для остальных типов используем colorchannelmixer\n        Ok(self.build_color_channel_mixer_filter(filter))\n      }\n    }\n  }\n\n  /// Построить фильтр colorchannelmixer для сложных цветовых коррекций\n  fn build_color_channel_mixer_filter(\u0026self, filter: \u0026Filter) -\u003e String {\n    let mut params = Vec::new();\n\n    match filter.filter_type {\n      FilterType::Shadows =\u003e {\n        let value = filter.parameters.get(\"shadows\").unwrap_or(\u00260.0);\n        // Поднимаем тени\n        params.push(format!(\"aa={}\", 1.0 + value * 0.2));\n      }\n      FilterType::Highlights =\u003e {\n        let value = filter.parameters.get(\"highlights\").unwrap_or(\u00260.0);\n        // Опускаем светлые тона\n        params.push(format!(\"aa={}\", 1.0 - value * 0.2));\n      }\n      FilterType::Vibrance =\u003e {\n        let value = filter.parameters.get(\"vibrance\").unwrap_or(\u00260.0);\n        // Увеличиваем насыщенность менее насыщенных цветов\n        let factor = 1.0 + value * 0.5;\n        params.push(format!(\"rr={}:gg={}:bb={}\", factor, factor, factor));\n      }\n      _ =\u003e {}\n    }\n\n    if params.is_empty() {\n      String::new()\n    } else {\n      format!(\"colorchannelmixer={}\", params.join(\":\"))\n    }\n  }\n\n  /// Построить фильтр для шаблона многокамерной раскладки\n  async fn build_template_filter(\n    \u0026self,\n    template: \u0026Template,\n    clips: \u0026[(Clip, usize, String)],\n  ) -\u003e Result\u003cString\u003e {\n    let mut overlay_chain = Vec::new();\n    let resolution = self.project.timeline.resolution;\n    let base_width = resolution.0 as f32;\n    let base_height = resolution.1 as f32;\n\n    // Создаем черный фон\n    let background = format!(\"color=c=black:s={}x{}:d=1[bg]\", resolution.0, resolution.1);\n    overlay_chain.push(background);\n\n    // Обрабатываем каждый клип в шаблоне\n    for (clip, input_idx, _) in clips {\n      if let Some(cell_index) = clip.template_cell {\n        if let Some(cell) = template.cells.get(cell_index) {\n          // Применяем фильтры к клипу\n          let mut clip_filter = format!(\"[{}:v]\", input_idx);\n\n          // Масштабируем видео под размер ячейки\n          let cell_width = (base_width * cell.width / 100.0) as i32;\n          let cell_height = (base_height * cell.height / 100.0) as i32;\n\n          // Применяем режим масштабирования\n          match \u0026cell.fit_mode {\n            crate::video_compiler::schema::FitMode::Contain =\u003e {\n              // Вписываем с сохранением пропорций\n              clip_filter.push_str(\u0026format!(\n                \"scale={}:{}:force_original_aspect_ratio=decrease,pad={}:{}:(ow-iw)/2:(oh-ih)/2\",\n                cell_width, cell_height, cell_width, cell_height\n              ));\n            }\n            crate::video_compiler::schema::FitMode::Cover =\u003e {\n              // Заполняем с обрезкой\n              clip_filter.push_str(\u0026format!(\n                \"scale={}:{}:force_original_aspect_ratio=increase,crop={}:{}\",\n                cell_width, cell_height, cell_width, cell_height\n              ));\n            }\n            crate::video_compiler::schema::FitMode::Fill =\u003e {\n              // Растягиваем на весь размер\n              clip_filter.push_str(\u0026format!(\"scale={}:{}\", cell_width, cell_height));\n            }\n          }\n\n          // Применяем дополнительное масштабирование, если есть\n          if let Some(scale) = cell.scale {\n            if scale != 1.0 {\n              let scaled_width = (cell_width as f32 * scale) as i32;\n              let scaled_height = (cell_height as f32 * scale) as i32;\n              clip_filter.push_str(\u0026format!(\",scale={}:{}\", scaled_width, scaled_height));\n            }\n          }\n\n          // Добавляем метку для этого клипа\n          let clip_label = format!(\"clip{}\", cell_index);\n          clip_filter.push_str(\u0026format!(\"[{}]\", clip_label));\n          overlay_chain.push(clip_filter);\n\n          // Вычисляем позицию с учетом выравнивания\n          let x_pos = (base_width * cell.x / 100.0) as i32;\n          let y_pos = (base_height * cell.y / 100.0) as i32;\n\n          // Применяем overlay для размещения видео\n          let prev_label = if overlay_chain.len() == 2 {\n            \"bg\"\n          } else {\n            \u0026format!(\"comp{}\", overlay_chain.len() - 2)\n          };\n          let next_label = format!(\"comp{}\", overlay_chain.len() - 1);\n\n          let overlay = format!(\n            \"[{}][{}]overlay={}:{}[{}]\",\n            prev_label, clip_label, x_pos, y_pos, next_label\n          );\n          overlay_chain.push(overlay);\n        }\n      }\n    }\n\n    // Финальный вывод\n    let final_label = if overlay_chain.len() \u003e 1 {\n      format!(\"comp{}\", overlay_chain.len() - 2)\n    } else {\n      \"bg\".to_string()\n    };\n\n    Ok(format!(\"{};[{}]\", overlay_chain.join(\";\"), final_label))\n  }\n\n  /// Построить фильтр для стильного шаблона\n  async fn build_style_template_filter(\n    \u0026self,\n    template: \u0026StyleTemplate,\n    clip: \u0026Clip,\n    input_idx: usize,\n  ) -\u003e Result\u003cString\u003e {\n    let mut filter_chain = Vec::new();\n    let mut current_input = format!(\"[{}:v]\", input_idx);\n\n    // Обрабатываем каждый элемент шаблона\n    for (elem_idx, element) in template.elements.iter().enumerate() {\n      // Проверяем временные рамки элемента\n      let element_start = clip.start_time + element.timing.start;\n      let element_end = clip.start_time + element.timing.end.min(clip.get_timeline_duration());\n\n      match \u0026element.element_type {\n        StyleElementType::Text =\u003e {\n          // Генерируем текстовый оверлей\n          if let Some(text) = \u0026element.properties.text {\n            let mut drawtext_params = vec![\n              format!(\"text='{}'\", text.replace(\"'\", \"\\\\'\")),\n              format!(\"x=(w-text_w)*{}/100\", element.position.x / 100.0),\n              format!(\"y=(h-text_h)*{}/100\", element.position.y / 100.0),\n            ];\n\n            if let Some(font_size) = element.properties.font_size {\n              drawtext_params.push(format!(\"fontsize={}\", font_size));\n            }\n\n            if let Some(color) = \u0026element.properties.color {\n              drawtext_params.push(format!(\"fontcolor={}\", color));\n            }\n\n            if let Some(font_family) = \u0026element.properties.font_family {\n              drawtext_params.push(format!(\"fontfile={}\", font_family));\n            }\n\n            // Добавляем временные ограничения\n            drawtext_params.push(format!(\n              \"enable='between(t,{},{})'\",\n              element_start, element_end\n            ));\n\n            let drawtext_filter = format!(\n              \"{}drawtext={}[text{}]\",\n              current_input,\n              drawtext_params.join(\":\"),\n              elem_idx\n            );\n\n            filter_chain.push(drawtext_filter);\n            current_input = format!(\"[text{}]\", elem_idx);\n          }\n        }\n\n        StyleElementType::Shape =\u003e {\n          // Генерируем оверлей для фигуры\n          if let Some(bg_color) = \u0026element.properties.background_color {\n            let shape_label = format!(\"shape{}\", elem_idx);\n\n            // Создаем цветной прямоугольник\n            let color_filter = format!(\n              \"color=c={}:s={}x{}:d=1[{}]\",\n              bg_color,\n              (element.size.width * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.size.height * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              shape_label\n            );\n            filter_chain.push(color_filter);\n\n            // Применяем прозрачность если есть\n            let mut shape_with_alpha = shape_label.clone();\n            if let Some(opacity) = element.properties.opacity {\n              let alpha_label = format!(\"shapealpha{}\", elem_idx);\n              let alpha_filter = format!(\n                \"[{}]colorchannelmixer=aa={}[{}]\",\n                shape_label, opacity, alpha_label\n              );\n              filter_chain.push(alpha_filter);\n              shape_with_alpha = alpha_label;\n            }\n\n            // Накладываем фигуру на видео\n            let overlay_filter = format!(\n              \"{}[{}]overlay={}:{}:enable='between(t,{},{})'[comp{}]\",\n              current_input,\n              shape_with_alpha,\n              (element.position.x * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.position.y * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              element_start,\n              element_end,\n              elem_idx\n            );\n            filter_chain.push(overlay_filter);\n            current_input = format!(\"[comp{}]\", elem_idx);\n          }\n        }\n\n        StyleElementType::Image =\u003e {\n          // Для изображений нужно будет загрузить файл\n          if let Some(src) = \u0026element.properties.src {\n            let img_label = format!(\"img{}\", elem_idx);\n\n            // Загружаем изображение и масштабируем\n            let img_filter = format!(\n              \"movie={}:loop=1,scale={}:{}[{}]\",\n              src,\n              (element.size.width * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.size.height * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              img_label\n            );\n            filter_chain.push(img_filter);\n\n            // Накладываем изображение\n            let overlay_filter = format!(\n              \"{}[{}]overlay={}:{}:enable='between(t,{},{})'[comp{}]\",\n              current_input,\n              img_label,\n              (element.position.x * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.position.y * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              element_start,\n              element_end,\n              elem_idx\n            );\n            filter_chain.push(overlay_filter);\n            current_input = format!(\"[comp{}]\", elem_idx);\n          }\n        }\n\n        _ =\u003e {\n          // Другие типы элементов пока пропускаем\n          log::warn!(\n            \"Тип элемента {:?} еще не поддерживается\",\n            element.element_type\n          );\n        }\n      }\n\n      // Применяем анимации если есть\n      for animation in \u0026element.animations {\n        current_input = self\n          .apply_element_animation(\n            \u0026current_input,\n            animation,\n            element_start,\n            element_end,\n            elem_idx,\n          )\n          .await?;\n      }\n    }\n\n    Ok(format!(\"{}{}\", filter_chain.join(\";\"), current_input))\n  }\n\n  /// Применить анимацию к элементу\n  async fn apply_element_animation(\n    \u0026self,\n    input: \u0026str,\n    animation: \u0026crate::video_compiler::schema::ElementAnimation,\n    start_time: f64,\n    _end_time: f64,\n    elem_idx: usize,\n  ) -\u003e Result\u003cString\u003e {\n    use crate::video_compiler::schema::AnimationType;\n\n    let anim_start = start_time + animation.delay.unwrap_or(0.0);\n    let anim_end = anim_start + animation.duration;\n\n    match \u0026animation.animation_type {\n      AnimationType::FadeIn =\u003e {\n        // Анимация появления\n        Ok(format!(\n          \"{}fade=in:st={}:d={}[anim{}]\",\n          input, anim_start, animation.duration, elem_idx\n        ))\n      }\n      AnimationType::FadeOut =\u003e {\n        // Анимация исчезновения\n        Ok(format!(\n          \"{}fade=out:st={}:d={}[anim{}]\",\n          input,\n          anim_end - animation.duration,\n          animation.duration,\n          elem_idx\n        ))\n      }\n      AnimationType::SlideIn =\u003e {\n        // Анимация въезда\n        let direction = animation\n          .direction\n          .as_ref()\n          .unwrap_or(\u0026crate::video_compiler::schema::AnimationDirection::Right);\n        let (x_expr, y_expr) = match direction {\n          crate::video_compiler::schema::AnimationDirection::Left =\u003e (\"w*(1-t/{})\", \"0\"),\n          crate::video_compiler::schema::AnimationDirection::Right =\u003e (\"-w+w*t/{}\", \"0\"),\n          crate::video_compiler::schema::AnimationDirection::Up =\u003e (\"0\", \"h*(1-t/{})\"),\n          crate::video_compiler::schema::AnimationDirection::Down =\u003e (\"0\", \"-h+h*t/{}\"),\n        };\n\n        Ok(format!(\n          \"{}overlay=x='if(between(t,{},{}),{},0)':y='if(between(t,{},{}),{},0)'[anim{}]\",\n          input,\n          anim_start,\n          anim_end,\n          x_expr.replace(\"{}\", \u0026animation.duration.to_string()),\n          anim_start,\n          anim_end,\n          y_expr.replace(\"{}\", \u0026animation.duration.to_string()),\n          elem_idx\n        ))\n      }\n      _ =\u003e {\n        // Другие анимации пока не реализованы\n        log::warn!(\n          \"Анимация {:?} еще не поддерживается\",\n          animation.animation_type\n        );\n        Ok(input.to_string())\n      }\n    }\n  }\n\n  /// Построить фильтр субтитров\n  async fn build_subtitle_filter(\u0026self) -\u003e Result\u003cString\u003e {\n    let mut subtitle_filters = Vec::new();\n\n    for subtitle in \u0026self.project.subtitles {\n      if !subtitle.enabled {\n        continue;\n      }\n\n      let filter = self.build_single_subtitle_filter(subtitle).await?;\n      if !filter.is_empty() {\n        subtitle_filters.push(filter);\n      }\n    }\n\n    if subtitle_filters.is_empty() {\n      return Ok(String::new());\n    }\n\n    // Соединяем субтитры с видео\n    // Предполагаем, что видео уже доступно как [outv]\n    let mut final_filter = \"[outv]\".to_string();\n\n    for (index, filter) in subtitle_filters.iter().enumerate() {\n      let input_label = if index == 0 {\n        \"[outv]\"\n      } else {\n        \u0026format!(\"[sub{}]\", index - 1)\n      };\n      let output_label = if index == subtitle_filters.len() - 1 {\n        \"[outv_with_subs]\"\n      } else {\n        \u0026format!(\"[sub{}]\", index)\n      };\n\n      final_filter = format!(\"{}{},{}{}\", final_filter, filter, input_label, output_label);\n    }\n\n    Ok(final_filter)\n  }\n\n  /// Построить фильтр для одного субтитра\n  async fn build_single_subtitle_filter(\u0026self, subtitle: \u0026Subtitle) -\u003e Result\u003cString\u003e {\n    let style = \u0026subtitle.style;\n    let pos = \u0026subtitle.position;\n\n    // Экранируем текст для FFmpeg\n    let escaped_text = self.escape_subtitle_text(\u0026subtitle.text);\n\n    // Построение основного drawtext фильтра\n    let mut drawtext_params = vec![\n      format!(\"text='{}'\", escaped_text),\n      format!(\"fontfile='{}'\", self.get_font_path(\u0026style.font_family)?),\n      format!(\"fontsize={}\", style.font_size),\n      format!(\"fontcolor={}\", style.color),\n    ];\n\n    // Позиционирование\n    let (x_pos, y_pos) = self.calculate_subtitle_position(pos);\n    drawtext_params.push(format!(\"x={}\", x_pos));\n    drawtext_params.push(format!(\"y={}\", y_pos));\n\n    // Толщина шрифта\n    let weight = match style.font_weight {\n      SubtitleFontWeight::Thin =\u003e \"thin\",\n      SubtitleFontWeight::Light =\u003e \"light\",\n      SubtitleFontWeight::Normal =\u003e \"normal\",\n      SubtitleFontWeight::Medium =\u003e \"medium\",\n      SubtitleFontWeight::Bold =\u003e \"bold\",\n      SubtitleFontWeight::Black =\u003e \"black\",\n    };\n    drawtext_params.push(format!(\"fontweight={}\", weight));\n\n    // Временные параметры\n    drawtext_params.push(format!(\n      \"enable='between(t,{},{})' \",\n      subtitle.start_time, subtitle.end_time\n    ));\n\n    // Обводка\n    if let Some(stroke_color) = \u0026style.stroke_color {\n      if style.stroke_width \u003e 0.0 {\n        drawtext_params.push(format!(\"bordercolor={}\", stroke_color));\n        drawtext_params.push(format!(\"borderw={}\", style.stroke_width));\n      }\n    }\n\n    // Тень\n    if let Some(shadow_color) = \u0026style.shadow_color {\n      if style.shadow_blur \u003e 0.0 {\n        drawtext_params.push(format!(\"shadowcolor={}\", shadow_color));\n        drawtext_params.push(format!(\"shadowx={}\", style.shadow_x));\n        drawtext_params.push(format!(\"shadowy={}\", style.shadow_y));\n      }\n    }\n\n    // Фон\n    if let Some(bg_color) = \u0026style.background_color {\n      drawtext_params.push(\"box=1\".to_string());\n      drawtext_params.push(format!(\"boxcolor={}\", bg_color));\n      drawtext_params.push(format!(\n        \"boxborderw={}\",\n        style.padding.left.max(style.padding.right)\n      ));\n    }\n\n    // Максимальная ширина\n    if style.max_width \u003e 0.0 \u0026\u0026 style.max_width \u003c 100.0 {\n      let max_width_px =\n        (self.project.timeline.resolution.0 as f32 * style.max_width / 100.0) as u32;\n      drawtext_params.push(format!(\"text_w={}\", max_width_px));\n    }\n\n    // Построение финального фильтра\n    let mut filter = format!(\"drawtext={}\", drawtext_params.join(\":\"));\n\n    // Добавляем анимации если есть\n    if !subtitle.animations.is_empty() {\n      filter = self.apply_subtitle_animations(filter, subtitle).await?;\n    }\n\n    Ok(filter)\n  }\n\n  /// Применить анимации к субтитру\n  async fn apply_subtitle_animations(\n    \u0026self,\n    base_filter: String,\n    subtitle: \u0026Subtitle,\n  ) -\u003e Result\u003cString\u003e {\n    let mut filter = base_filter;\n\n    for animation in \u0026subtitle.animations {\n      filter = self\n        .apply_single_subtitle_animation(filter, animation, subtitle)\n        .await?;\n    }\n\n    Ok(filter)\n  }\n\n  /// Применить одну анимацию к субтитру\n  async fn apply_single_subtitle_animation(\n    \u0026self,\n    base_filter: String,\n    animation: \u0026SubtitleAnimation,\n    subtitle: \u0026Subtitle,\n  ) -\u003e Result\u003cString\u003e {\n    let start_time = subtitle.start_time + animation.delay;\n    let end_time = start_time + animation.duration;\n\n    match animation.animation_type {\n      SubtitleAnimationType::FadeIn =\u003e {\n        // Плавное появление через изменение alpha\n        Ok(format!(\n          \"{}:alpha='if(between(t,{},{}), (t-{})/{}*1.0, 1.0)'\",\n          base_filter, start_time, end_time, start_time, animation.duration\n        ))\n      }\n      SubtitleAnimationType::FadeOut =\u003e {\n        // Плавное исчезновение\n        Ok(format!(\n          \"{}:alpha='if(between(t,{},{}), 1.0-(t-{})/{}*1.0, 1.0)'\",\n          base_filter, start_time, end_time, start_time, animation.duration\n        ))\n      }\n      SubtitleAnimationType::SlideIn =\u003e {\n        // Въезд с указанного направления\n        if let Some(direction) = \u0026animation.direction {\n          let (start_x, _start_y, end_x, _end_y) =\n            self.calculate_slide_positions(direction, subtitle);\n          Ok(format!(\n            \"{}:x='if(between(t,{},{}), {}+({})*((t-{})/{}), {})'\",\n            base_filter,\n            start_time,\n            end_time,\n            start_x,\n            end_x - start_x,\n            start_time,\n            animation.duration,\n            end_x\n          ))\n        } else {\n          Ok(base_filter)\n        }\n      }\n      SubtitleAnimationType::SlideOut =\u003e {\n        // Выезд в указанном направлении\n        if let Some(direction) = \u0026animation.direction {\n          let (start_x, _start_y, end_x, _end_y) =\n            self.calculate_slide_positions(direction, subtitle);\n          Ok(format!(\n            \"{}:x='if(between(t,{},{}), {}+({})*((t-{})/{}), {})'\",\n            base_filter,\n            start_time,\n            end_time,\n            start_x,\n            end_x - start_x,\n            start_time,\n            animation.duration,\n            start_x\n          ))\n        } else {\n          Ok(base_filter)\n        }\n      }\n      SubtitleAnimationType::ScaleIn =\u003e {\n        // Увеличение от 0 до полного размера\n        Ok(format!(\n          \"{}:fontsize='{}*if(between(t,{},{}), (t-{})/{}*1.0, 1.0)'\",\n          base_filter,\n          subtitle.style.font_size,\n          start_time,\n          end_time,\n          start_time,\n          animation.duration\n        ))\n      }\n      _ =\u003e {\n        // Для остальных типов анимаций пока возвращаем базовый фильтр\n        // TODO: Реализовать Typewriter, Wave, Bounce, Shake, Blink, Dissolve\n        Ok(base_filter)\n      }\n    }\n  }\n\n  /// Экранировать текст субтитра для FFmpeg\n  fn escape_subtitle_text(\u0026self, text: \u0026str) -\u003e String {\n    text\n      .replace(\"\\\\\", \"\\\\\\\\\") // Экранируем обратные слеши\n      .replace(\"'\", \"\\\\'\") // Экранируем одинарные кавычки\n      .replace(\":\", \"\\\\:\") // Экранируем двоеточия\n      .replace(\",\", \"\\\\,\") // Экранируем запятые\n      .replace(\"[\", \"\\\\[\") // Экранируем квадратные скобки\n      .replace(\"]\", \"\\\\]\")\n  }\n\n  /// Получить путь к шрифту\n  fn get_font_path(\u0026self, font_family: \u0026str) -\u003e Result\u003cString\u003e {\n    // В реальной реализации нужно искать шрифт в системе\n    // Пока используем стандартные пути\n    match font_family.to_lowercase().as_str() {\n      \"arial\" =\u003e Ok(\"/System/Library/Fonts/Arial.ttf\".to_string()),\n      \"helvetica\" =\u003e Ok(\"/System/Library/Fonts/Helvetica.ttc\".to_string()),\n      \"times\" | \"times new roman\" =\u003e Ok(\"/System/Library/Fonts/Times.ttc\".to_string()),\n      _ =\u003e {\n        // Пытаемся найти шрифт или используем fallback\n        Ok(\"/System/Library/Fonts/Arial.ttf\".to_string())\n      }\n    }\n  }\n\n  /// Вычислить позицию субтитра\n  fn calculate_subtitle_position(\u0026self, pos: \u0026SubtitlePosition) -\u003e (String, String) {\n    let resolution = \u0026self.project.timeline.resolution;\n    let screen_width = resolution.0 as f32;\n    let screen_height = resolution.1 as f32;\n\n    // Базовые координаты в пикселях\n    let base_x = (pos.x / 100.0) * screen_width;\n    let base_y = (pos.y / 100.0) * screen_height;\n\n    // Корректировка на основе выравнивания\n    let x_offset = match pos.align_x {\n      SubtitleAlignX::Left =\u003e 0.0,\n      SubtitleAlignX::Center =\u003e -0.5,\n      SubtitleAlignX::Right =\u003e -1.0,\n    };\n\n    let y_offset = match pos.align_y {\n      SubtitleAlignY::Top =\u003e 0.0,\n      SubtitleAlignY::Center =\u003e -0.5,\n      SubtitleAlignY::Bottom =\u003e -1.0,\n    };\n\n    // Добавляем отступы\n    let final_x = base_x + pos.margin.left;\n    let final_y = base_y + pos.margin.top;\n\n    // FFmpeg поддерживает выражения для центрирования\n    let x_expr = if x_offset != 0.0 {\n      format!(\"(w-text_w)*{:.1}+{}\", (x_offset as f32).abs(), final_x)\n    } else {\n      format!(\"{}\", final_x)\n    };\n\n    let y_expr = if y_offset != 0.0 {\n      format!(\"(h-text_h)*{:.1}+{}\", (y_offset as f32).abs(), final_y)\n    } else {\n      format!(\"{}\", final_y)\n    };\n\n    (x_expr, y_expr)\n  }\n\n  /// Вычислить позиции для анимации слайда\n  fn calculate_slide_positions(\n    \u0026self,\n    direction: \u0026SubtitleDirection,\n    subtitle: \u0026Subtitle,\n  ) -\u003e (f32, f32, f32, f32) {\n    let resolution = \u0026self.project.timeline.resolution;\n    let screen_width = resolution.0 as f32;\n    let screen_height = resolution.1 as f32;\n\n    let (normal_x, normal_y) = self.calculate_subtitle_position(\u0026subtitle.position);\n\n    // Парсим нормальные позиции (упрощенно)\n    let normal_x_val = normal_x.parse::\u003cf32\u003e().unwrap_or(screen_width / 2.0);\n    let normal_y_val = normal_y.parse::\u003cf32\u003e().unwrap_or(screen_height * 0.85);\n\n    match direction {\n      SubtitleDirection::Left =\u003e (-screen_width, normal_y_val, normal_x_val, normal_y_val),\n      SubtitleDirection::Right =\u003e (screen_width, normal_y_val, normal_x_val, normal_y_val),\n      SubtitleDirection::Top =\u003e (normal_x_val, -screen_height, normal_x_val, normal_y_val),\n      SubtitleDirection::Bottom =\u003e (normal_x_val, screen_height, normal_x_val, normal_y_val),\n      SubtitleDirection::Center =\u003e (normal_x_val, normal_y_val, normal_x_val, normal_y_val),\n    }\n  }\n  /// Построить граф фильтров для конкретного сегмента\n  async fn build_segment_filter_complex(\u0026self, start_time: f64, end_time: f64) -\u003e Result\u003cString\u003e {\n    let mut filter_chain = String::new();\n    let mut input_index = 0;\n\n    // Получаем только те треки и клипы, которые попадают в заданный временной диапазон\n    let video_tracks: Vec\u003c\u0026Track\u003e = self\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.enabled \u0026\u0026 t.track_type == TrackType::Video)\n      .filter(|t| {\n        // Проверяем, есть ли клипы в нужном диапазоне\n        t.clips.iter().any(|c| {\n          let clip_start = c.start_time;\n          let clip_end = c.end_time;\n          // Клип пересекается с диапазоном пререндера\n          clip_start \u003c end_time \u0026\u0026 clip_end \u003e start_time\n        })\n      })\n      .collect();\n\n    let audio_tracks: Vec\u003c\u0026Track\u003e = self\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.enabled \u0026\u0026 t.track_type == TrackType::Audio)\n      .filter(|t| {\n        t.clips.iter().any(|c| {\n          let clip_start = c.start_time;\n          let clip_end = c.end_time;\n          clip_start \u003c end_time \u0026\u0026 clip_end \u003e start_time\n        })\n      })\n      .collect();\n\n    // Строим видео цепочку\n    if !video_tracks.is_empty() {\n      let video_filter = self\n        .build_video_filter_chain(\u0026video_tracks, \u0026mut input_index)\n        .await?;\n      filter_chain.push_str(\u0026video_filter);\n    }\n\n    // Строим аудио цепочку\n    if !audio_tracks.is_empty() {\n      if !filter_chain.is_empty() {\n        filter_chain.push_str(\"; \");\n      }\n      let audio_filter = self\n        .build_audio_filter_chain(\u0026audio_tracks, \u0026mut input_index)\n        .await?;\n      filter_chain.push_str(\u0026audio_filter);\n    }\n\n    Ok(filter_chain)\n  }\n}\n\n/// Входной источник для FFmpeg\n#[derive(Debug, Clone)]\npub struct InputSource {\n  /// Путь к файлу\n  pub path: PathBuf,\n  /// Время начала в файле\n  pub start_time: f64,\n  /// Длительность\n  pub duration: f64,\n  /// Индекс входа в FFmpeg\n  pub input_index: usize,\n  /// Тип трека\n  pub track_type: TrackType,\n}\n\n/// Настройки построителя FFmpeg\n#[derive(Debug, Clone)]\npub struct FFmpegBuilderSettings {\n  /// Путь к FFmpeg\n  pub ffmpeg_path: String,\n  /// Количество потоков\n  pub threads: Option\u003cu32\u003e,\n  /// Предпочитать NVENC\n  pub prefer_nvenc: bool,\n  /// Предпочитать QuickSync\n  pub prefer_quicksync: bool,\n  /// Дополнительные глобальные параметры\n  pub global_args: Vec\u003cString\u003e,\n}\n\nimpl Default for FFmpegBuilderSettings {\n  fn default() -\u003e Self {\n    Self {\n      ffmpeg_path: \"ffmpeg\".to_string(),\n      threads: None, // Автоматическое определение\n      prefer_nvenc: true,\n      prefer_quicksync: false,\n      global_args: Vec::new(),\n    }\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::schema::{\n    Clip, Effect, EffectParameter, EffectType, ProjectSchema, Track, TrackType,\n  };\n  use std::path::PathBuf;\n\n  #[tokio::test]\n  async fn test_blur_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_blur_effect(5.0);\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"boxblur=5:1\");\n  }\n\n  #[tokio::test]\n  async fn test_brightness_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_brightness_effect(0.3);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"eq=brightness=0.3\");\n  }\n\n  #[tokio::test]\n  async fn test_contrast_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_contrast_effect(1.5);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"eq=contrast=1.5\");\n  }\n\n  #[tokio::test]\n  async fn test_saturation_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_saturation_effect(0.8);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"eq=saturation=0.8\");\n  }\n\n  #[tokio::test]\n  async fn test_speed_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_speed_effect(2.0);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"setpts=0.5*PTS\");\n  }\n\n  #[tokio::test]\n  async fn test_grayscale_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_simple_effect(EffectType::Grayscale);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"hue=s=0\");\n  }\n\n  #[tokio::test]\n  async fn test_sepia_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_simple_effect(EffectType::Sepia);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(\n      result,\n      \"colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\"\n    );\n  }\n\n  #[tokio::test]\n  async fn test_vignette_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_vignette_effect(3.14);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"vignette=angle=4.71:x0=w/2:y0=h/2\");\n  }\n\n  #[tokio::test]\n  async fn test_custom_ffmpeg_template() {\n    let builder = create_test_builder();\n    let effect = create_custom_effect_with_template(\"blur=sigma={intensity}\", 2.5);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"blur=sigma=2.5\");\n  }\n\n  #[tokio::test]\n  async fn test_disabled_effect() {\n    let builder = create_test_builder();\n    let mut effect = create_simple_effect(EffectType::Blur);\n    effect.enabled = false;\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"\");\n  }\n\n  // Project setup helper\n  fn create_test_project() -\u003e ProjectSchema {\n    let mut project = ProjectSchema::new(\"Test Project\".to_string());\n\n    // Add video track with clip\n    let mut video_track = Track::new(TrackType::Video, \"Video Track\".to_string());\n    let video_clip = Clip::new(PathBuf::from(\"/test/video.mp4\"), 0.0, 10.0);\n    video_track.clips.push(video_clip);\n    project.tracks.push(video_track);\n\n    project\n  }\n\n  #[test]\n  fn test_ffmpeg_builder_creation() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n    assert_eq!(builder.project.metadata.name, \"Test Project\");\n  }\n\n  #[test]\n  fn test_ffmpeg_builder_with_settings() {\n    let project = create_test_project();\n    let mut settings = FFmpegBuilderSettings::default();\n    settings.ffmpeg_path = \"/custom/path/ffmpeg\".to_string();\n    settings.threads = Some(8);\n    settings.prefer_nvenc = false;\n    settings.prefer_quicksync = true;\n    settings.global_args = vec![\"-hide_banner\".to_string()];\n\n    let builder = FFmpegBuilder::with_settings(project, settings.clone());\n    assert_eq!(builder.settings.ffmpeg_path, \"/custom/path/ffmpeg\");\n    assert_eq!(builder.settings.threads, Some(8));\n    assert!(!builder.settings.prefer_nvenc);\n    assert!(builder.settings.prefer_quicksync);\n    assert_eq!(\n      builder.settings.global_args,\n      vec![\"-hide_banner\".to_string()]\n    );\n  }\n\n  #[test]\n  fn test_quality_to_crf() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    assert_eq!(builder.quality_to_crf(100), 0); // Best quality\n    assert_eq!(builder.quality_to_crf(0), 51); // Worst quality\n    assert_eq!(builder.quality_to_crf(50), 25); // Medium quality\n  }\n\n  #[test]\n  fn test_get_video_tracks() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let video_tracks = builder.get_video_tracks();\n    assert_eq!(video_tracks.len(), 1);\n    assert_eq!(video_tracks[0].track_type, TrackType::Video);\n  }\n\n  #[test]\n  fn test_get_audio_tracks() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let audio_tracks = builder.get_audio_tracks();\n    assert_eq!(audio_tracks.len(), 0); // No audio tracks in test project\n  }\n\n  #[tokio::test]\n  async fn test_collect_input_sources() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let sources = builder.collect_input_sources().await.unwrap();\n    assert_eq!(sources.len(), 1);\n    assert_eq!(sources[0].input_index, 0);\n    assert_eq!(sources[0].track_type, TrackType::Video);\n  }\n\n  #[tokio::test]\n  async fn test_build_preview_command() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let input_path = PathBuf::from(\"/test/input.mp4\");\n    let output_path = PathBuf::from(\"/test/preview.jpg\");\n\n    let cmd = builder\n      .build_preview_command(\u0026input_path, 10.0, \u0026output_path, (640, 360))\n      .await\n      .unwrap();\n\n    // Check that command contains required arguments\n    let cmd_str = format!(\"{:?}\", cmd);\n    assert!(cmd_str.contains(\"ffmpeg\"));\n    assert!(cmd_str.contains(\"-ss\"));\n    assert!(cmd_str.contains(\"10\"));\n    assert!(cmd_str.contains(\"-vframes\"));\n    assert!(cmd_str.contains(\"1\"));\n  }\n\n  #[test]\n  fn test_ffmpeg_builder_settings_default() {\n    let settings = FFmpegBuilderSettings::default();\n    assert_eq!(settings.ffmpeg_path, \"ffmpeg\");\n    assert!(settings.prefer_nvenc);\n    assert!(!settings.prefer_quicksync);\n    assert!(settings.global_args.is_empty());\n  }\n\n  #[tokio::test]\n  async fn test_build_filter_complex_empty() {\n    let project = ProjectSchema::new(\"Empty Project\".to_string());\n    let builder = FFmpegBuilder::new(project);\n\n    let filter_complex = builder.build_filter_complex().await.unwrap();\n    assert!(filter_complex.is_empty());\n  }\n\n  #[tokio::test]\n  async fn test_build_render_command() {\n    let mut project = create_test_project();\n    project.timeline.resolution = (1920, 1080);\n    project.timeline.fps = 30;\n    project.settings.export.quality = 80;\n    project.settings.export.video_bitrate = 5000;\n    project.settings.export.audio_bitrate = 192;\n\n    let builder = FFmpegBuilder::new(project);\n    let output_path = PathBuf::from(\"/test/output.mp4\");\n\n    let cmd = builder.build_render_command(\u0026output_path).await.unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"ffmpeg\"));\n    assert!(cmd_str.contains(\"/test/output.mp4\"));\n  }\n\n  #[tokio::test]\n  async fn test_add_input_sources() {\n    let mut project = create_test_project();\n    let mut audio_track = Track::new(TrackType::Audio, \"Audio Track\".to_string());\n    let audio_clip = Clip::new(PathBuf::from(\"/test/audio.mp3\"), 0.0, 10.0);\n    audio_track.clips.push(audio_clip);\n    project.tracks.push(audio_track);\n\n    let builder = FFmpegBuilder::new(project);\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n\n    builder.add_input_sources(\u0026mut cmd).await.unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"/test/video.mp4\"));\n    assert!(cmd_str.contains(\"/test/audio.mp3\"));\n  }\n\n  #[tokio::test]\n  async fn test_add_filter_complex() {\n    let mut project = create_test_project();\n    // Add effect to test filter generation\n    let mut effect = Effect::new(EffectType::Blur, \"Test Blur\".to_string());\n    effect\n      .parameters\n      .insert(\"radius\".to_string(), EffectParameter::Float(5.0));\n    effect.id = \"test-effect-123\".to_string();\n    project.tracks[0].clips[0].effects.push(effect.id.clone());\n    project.effects.push(effect);\n\n    let builder = FFmpegBuilder::new(project);\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n\n    builder.add_filter_complex(\u0026mut cmd).await.unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"-filter_complex\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_video_filter_chain() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n    let video_tracks = builder.get_video_tracks();\n\n    let mut input_index = 0;\n    let filter_chain = builder\n      .build_video_filter_chain(\u0026video_tracks, \u0026mut input_index)\n      .await\n      .unwrap();\n    // Should have output label\n    assert!(filter_chain.contains(\"[outv]\") || filter_chain.contains(\"[v\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_audio_filter_chain() {\n    let mut project = create_test_project();\n    // Add audio track for testing\n    let mut audio_track = Track::new(TrackType::Audio, \"Audio Track\".to_string());\n    let audio_clip = Clip::new(PathBuf::from(\"/test/audio.mp3\"), 0.0, 10.0);\n    audio_track.clips.push(audio_clip);\n    project.tracks.push(audio_track);\n\n    let builder = FFmpegBuilder::new(project);\n    let audio_tracks = builder.get_audio_tracks();\n\n    let mut input_index = 0;\n    let filter_chain = builder\n      .build_audio_filter_chain(\u0026audio_tracks, \u0026mut input_index)\n      .await\n      .unwrap();\n    // Should have volume control and output\n    assert!(filter_chain.contains(\"volume=\") || filter_chain.contains(\"[outa]\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_clip_filters() {\n    let mut clip = Clip::new(PathBuf::from(\"/test/video.mp4\"), 0.0, 10.0);\n    clip.source_start = 2.0;\n    clip.source_end = 8.0;\n    clip.speed = 2.0; // Double speed to ensure setpts is added\n\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let filters = builder.build_clip_filters(\u0026clip, 0, 0).await.unwrap();\n    assert!(filters.contains(\"trim=\"));\n    assert!(filters.contains(\"setpts=\")); // Will be added because speed != 1.0\n    assert!(filters.contains(\"[v0]\")); // Output label\n  }\n\n  #[tokio::test]\n  async fn test_process_ffmpeg_template() {\n    let builder = create_test_builder();\n    let mut effect = Effect::new(EffectType::Blur, \"Custom Blur\".to_string());\n    effect\n      .parameters\n      .insert(\"blur\".to_string(), EffectParameter::Float(10.0));\n    effect\n      .parameters\n      .insert(\"intensity\".to_string(), EffectParameter::Float(0.8));\n    effect.ffmpeg_command = Some(\"boxblur={blur}:enable='between(t,0,{intensity})'\".to_string());\n\n    let template = effect.ffmpeg_command.as_ref().unwrap();\n    let result = builder.process_ffmpeg_template(template, \u0026effect);\n\n    assert_eq!(result, \"boxblur=10:enable='between(t,0,0.8)'\");\n  }\n\n  #[tokio::test]\n  async fn test_build_video_effect_filter() {\n    let builder = create_test_builder();\n    let mut effect = Effect::new(EffectType::HueRotate, \"Hue Rotate\".to_string());\n    effect\n      .parameters\n      .insert(\"angle\".to_string(), EffectParameter::Float(45.0));\n\n    // build_video_effect_filter is a private method, use build_effect_filter instead\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert!(result.contains(\"hue=h=45\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_color_correction_filter() {\n    let builder = create_test_builder();\n    let mut effect = Effect::new(EffectType::Brightness, \"Brightness\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(0.2));\n\n    let mut contrast_effect = Effect::new(EffectType::Contrast, \"Contrast\".to_string());\n    contrast_effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(1.2));\n\n    let mut saturation_effect = Effect::new(EffectType::Saturation, \"Saturation\".to_string());\n    saturation_effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(1.1));\n\n    // Test individual color correction effects through build_effect_filter\n    let brightness_result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(brightness_result, \"eq=brightness=0.2\");\n\n    let contrast_result = builder.build_effect_filter(\u0026contrast_effect).await.unwrap();\n    assert_eq!(contrast_result, \"eq=contrast=1.2\");\n\n    let saturation_result = builder\n      .build_effect_filter(\u0026saturation_effect)\n      .await\n      .unwrap();\n    assert_eq!(saturation_result, \"eq=saturation=1.1\");\n  }\n\n  #[tokio::test]\n  async fn test_add_output_settings() {\n    let mut project = create_test_project();\n    project.settings.export.video_bitrate = 5000; // 5Mbps\n    project.settings.export.audio_bitrate = 192; // 192kbps\n    project.settings.export.quality = 80;\n    project.settings.export.hardware_acceleration = false; // Отключаем для теста битрейта\n\n    let builder = FFmpegBuilder::new(project);\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n    let output_path = PathBuf::from(\"/test/output.mp4\");\n\n    builder\n      .add_output_settings(\u0026mut cmd, \u0026output_path)\n      .await\n      .unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"-c:v\"));\n    assert!(cmd_str.contains(\"-c:a\"));\n    assert!(cmd_str.contains(\"-b:v\"));\n    assert!(cmd_str.contains(\"-b:a\"));\n    assert!(cmd_str.contains(\"-crf\"));\n    assert!(cmd_str.contains(\"/test/output.mp4\"));\n  }\n\n  #[tokio::test]\n  async fn test_add_hardware_acceleration() {\n    let mut settings = FFmpegBuilderSettings::default();\n    settings.prefer_nvenc = true;\n    let project = create_test_project();\n    let builder = FFmpegBuilder::with_settings(project, settings);\n\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n    builder.add_hardware_acceleration(\u0026mut cmd).await;\n\n    let cmd_str = format!(\"{:?}\", cmd);\n    // Should contain video codec parameter\n    assert!(cmd_str.contains(\"-c:v\"));\n  }\n\n  #[test]\n  fn test_add_global_options() {\n    let mut settings = FFmpegBuilderSettings::default();\n    settings.threads = Some(4);\n    settings.global_args = vec![\n      \"-hide_banner\".to_string(),\n      \"-loglevel\".to_string(),\n      \"error\".to_string(),\n    ];\n\n    let project = create_test_project();\n    let builder = FFmpegBuilder::with_settings(project, settings);\n\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n    builder.add_global_options(\u0026mut cmd);\n\n    let cmd_str = format!(\"{:?}\", cmd);\n    assert!(cmd_str.contains(\"-threads\"));\n    assert!(cmd_str.contains(\"4\"));\n    assert!(cmd_str.contains(\"-hide_banner\"));\n    assert!(cmd_str.contains(\"-loglevel\"));\n    assert!(cmd_str.contains(\"info\")); // По умолчанию используется \"info\", а не \"error\"\n    assert!(cmd_str.contains(\"-progress\"));\n  }\n\n  #[test]\n  fn test_find_effect() {\n    let mut project = create_test_project();\n    let mut effect = Effect::new(EffectType::Blur, \"Test Effect\".to_string());\n    effect.id = \"test-effect-123\".to_string();\n    project.effects.push(effect);\n    project.tracks[0].clips[0]\n      .effects\n      .push(\"test-effect-123\".to_string());\n\n    let builder = FFmpegBuilder::new(project);\n\n    let found = builder.find_effect(\"test-effect-123\");\n    assert!(found.is_some());\n    assert_eq!(found.unwrap().name, \"Test Effect\");\n\n    let not_found = builder.find_effect(\"non-existent\");\n    assert!(not_found.is_none());\n  }\n\n  fn create_test_builder() -\u003e FFmpegBuilder {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    FFmpegBuilder::new(project)\n  }\n\n  fn create_blur_effect(radius: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Blur, \"Blur\".to_string());\n    effect\n      .parameters\n      .insert(\"radius\".to_string(), EffectParameter::Float(radius));\n    effect\n  }\n\n  fn create_brightness_effect(value: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Brightness, \"Brightness\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(value));\n    effect\n  }\n\n  fn create_contrast_effect(value: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Contrast, \"Contrast\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(value));\n    effect\n  }\n\n  fn create_saturation_effect(value: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Saturation, \"Saturation\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(value));\n    effect\n  }\n\n  fn create_speed_effect(speed: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Speed, \"Speed\".to_string());\n    effect\n      .parameters\n      .insert(\"speed\".to_string(), EffectParameter::Float(speed));\n    effect\n  }\n\n  fn create_vignette_effect(angle: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Vignette, \"Vignette\".to_string());\n    effect\n      .parameters\n      .insert(\"angle\".to_string(), EffectParameter::Float(angle));\n    effect\n  }\n\n  fn create_simple_effect(effect_type: EffectType) -\u003e Effect {\n    Effect::new(effect_type, \"Test Effect\".to_string())\n  }\n\n  fn create_custom_effect_with_template(template: \u0026str, intensity: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Noir, \"Custom Effect\".to_string());\n    effect.ffmpeg_command = Some(template.to_string());\n    effect\n      .parameters\n      .insert(\"intensity\".to_string(), EffectParameter::Float(intensity));\n    effect\n  }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":33}},{"line":32,"address":[],"length":0,"stats":{"Line":33}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":203,"address":[],"length":0,"stats":{"Line":11}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":9}},{"line":301,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":3}},{"line":318,"address":[],"length":0,"stats":{"Line":3}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":9}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":3}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":3}},{"line":362,"address":[],"length":0,"stats":{"Line":3}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":3}},{"line":379,"address":[],"length":0,"stats":{"Line":3}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[],"length":0,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":1}},{"line":386,"address":[],"length":0,"stats":{"Line":1}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":1}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":1}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":4}},{"line":617,"address":[],"length":0,"stats":{"Line":4}},{"line":620,"address":[],"length":0,"stats":{"Line":11}},{"line":621,"address":[],"length":0,"stats":{"Line":4}},{"line":622,"address":[],"length":0,"stats":{"Line":4}},{"line":623,"address":[],"length":0,"stats":{"Line":4}},{"line":624,"address":[],"length":0,"stats":{"Line":4}},{"line":625,"address":[],"length":0,"stats":{"Line":4}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":5}},{"line":633,"address":[],"length":0,"stats":{"Line":1}},{"line":637,"address":[],"length":0,"stats":{"Line":6}},{"line":638,"address":[],"length":0,"stats":{"Line":2}},{"line":639,"address":[],"length":0,"stats":{"Line":1}},{"line":640,"address":[],"length":0,"stats":{"Line":1}},{"line":641,"address":[],"length":0,"stats":{"Line":1}},{"line":647,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":4}},{"line":657,"address":[],"length":0,"stats":{"Line":2}},{"line":658,"address":[],"length":0,"stats":{"Line":2}},{"line":659,"address":[],"length":0,"stats":{"Line":2}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":4}},{"line":680,"address":[],"length":0,"stats":{"Line":30}},{"line":681,"address":[],"length":0,"stats":{"Line":15}},{"line":682,"address":[],"length":0,"stats":{"Line":1}},{"line":686,"address":[],"length":0,"stats":{"Line":15}},{"line":690,"address":[],"length":0,"stats":{"Line":13}},{"line":693,"address":[],"length":0,"stats":{"Line":2}},{"line":694,"address":[],"length":0,"stats":{"Line":2}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":4}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":2}},{"line":704,"address":[],"length":0,"stats":{"Line":2}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":2}},{"line":712,"address":[],"length":0,"stats":{"Line":4}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":2}},{"line":715,"address":[],"length":0,"stats":{"Line":2}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":2}},{"line":723,"address":[],"length":0,"stats":{"Line":4}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":2}},{"line":726,"address":[],"length":0,"stats":{"Line":2}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":2}},{"line":733,"address":[],"length":0,"stats":{"Line":2}},{"line":734,"address":[],"length":0,"stats":{"Line":1}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":1}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":1}},{"line":742,"address":[],"length":0,"stats":{"Line":1}},{"line":745,"address":[],"length":0,"stats":{"Line":2}},{"line":746,"address":[],"length":0,"stats":{"Line":1}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":1}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":2}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":790,"address":[],"length":0,"stats":{"Line":1}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":2}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":1}},{"line":799,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":2}},{"line":1106,"address":[],"length":0,"stats":{"Line":2}},{"line":1109,"address":[],"length":0,"stats":{"Line":8}},{"line":1112,"address":[],"length":0,"stats":{"Line":3}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":2}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":4}},{"line":1195,"address":[],"length":0,"stats":{"Line":2}},{"line":1198,"address":[],"length":0,"stats":{"Line":2}},{"line":1199,"address":[],"length":0,"stats":{"Line":1}},{"line":1202,"address":[],"length":0,"stats":{"Line":1}},{"line":1206,"address":[],"length":0,"stats":{"Line":2}},{"line":1207,"address":[],"length":0,"stats":{"Line":2}},{"line":1208,"address":[],"length":0,"stats":{"Line":2}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":1}},{"line":1226,"address":[],"length":0,"stats":{"Line":1}},{"line":1245,"address":[],"length":0,"stats":{"Line":2}},{"line":1256,"address":[],"length":0,"stats":{"Line":4}},{"line":1260,"address":[],"length":0,"stats":{"Line":2}},{"line":1263,"address":[],"length":0,"stats":{"Line":2}},{"line":1266,"address":[],"length":0,"stats":{"Line":4}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1270,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":4}},{"line":1281,"address":[],"length":0,"stats":{"Line":2}},{"line":1284,"address":[],"length":0,"stats":{"Line":2}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":2}},{"line":1291,"address":[],"length":0,"stats":{"Line":2}},{"line":1294,"address":[],"length":0,"stats":{"Line":2}},{"line":1295,"address":[],"length":0,"stats":{"Line":34}},{"line":1300,"address":[],"length":0,"stats":{"Line":2}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1304,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":2}},{"line":1313,"address":[],"length":0,"stats":{"Line":2}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":2}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":1}},{"line":1337,"address":[],"length":0,"stats":{"Line":1}},{"line":1338,"address":[],"length":0,"stats":{"Line":1}},{"line":1339,"address":[],"length":0,"stats":{"Line":1}},{"line":1340,"address":[],"length":0,"stats":{"Line":1}},{"line":1341,"address":[],"length":0,"stats":{"Line":1}},{"line":1342,"address":[],"length":0,"stats":{"Line":1}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":2}},{"line":1367,"address":[],"length":0,"stats":{"Line":2}},{"line":1370,"address":[],"length":0,"stats":{"Line":2}},{"line":1373,"address":[],"length":0,"stats":{"Line":3}},{"line":1378,"address":[],"length":0,"stats":{"Line":2}},{"line":1381,"address":[],"length":0,"stats":{"Line":2}},{"line":1382,"address":[],"length":0,"stats":{"Line":2}},{"line":1386,"address":[],"length":0,"stats":{"Line":4}},{"line":1388,"address":[],"length":0,"stats":{"Line":4}},{"line":1389,"address":[],"length":0,"stats":{"Line":4}},{"line":1390,"address":[],"length":0,"stats":{"Line":4}},{"line":1394,"address":[],"length":0,"stats":{"Line":7}},{"line":1395,"address":[],"length":0,"stats":{"Line":7}},{"line":1396,"address":[],"length":0,"stats":{"Line":7}},{"line":1397,"address":[],"length":0,"stats":{"Line":7}},{"line":1399,"address":[],"length":0,"stats":{"Line":26}},{"line":1404,"address":[],"length":0,"stats":{"Line":7}},{"line":1405,"address":[],"length":0,"stats":{"Line":7}},{"line":1406,"address":[],"length":0,"stats":{"Line":7}},{"line":1407,"address":[],"length":0,"stats":{"Line":7}},{"line":1409,"address":[],"length":0,"stats":{"Line":22}},{"line":1414,"address":[],"length":0,"stats":{"Line":3}},{"line":1415,"address":[],"length":0,"stats":{"Line":3}},{"line":1416,"address":[],"length":0,"stats":{"Line":3}},{"line":1417,"address":[],"length":0,"stats":{"Line":3}},{"line":1419,"address":[],"length":0,"stats":{"Line":9}},{"line":1423,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1457,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1513,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1556,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1559,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1581,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1623,"address":[],"length":0,"stats":{"Line":0}},{"line":1624,"address":[],"length":0,"stats":{"Line":0}},{"line":1625,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1659,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1678,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1695,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1723,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1766,"address":[],"length":0,"stats":{"Line":0}},{"line":1797,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1806,"address":[],"length":0,"stats":{"Line":0}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1822,"address":[],"length":0,"stats":{"Line":0}},{"line":1832,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1835,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1839,"address":[],"length":0,"stats":{"Line":0}},{"line":1840,"address":[],"length":0,"stats":{"Line":0}},{"line":1845,"address":[],"length":0,"stats":{"Line":0}},{"line":1846,"address":[],"length":0,"stats":{"Line":0}},{"line":1847,"address":[],"length":0,"stats":{"Line":0}},{"line":1848,"address":[],"length":0,"stats":{"Line":0}},{"line":1849,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1855,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1858,"address":[],"length":0,"stats":{"Line":0}},{"line":1859,"address":[],"length":0,"stats":{"Line":0}},{"line":1860,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1862,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1872,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[],"length":0,"stats":{"Line":0}},{"line":1874,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1880,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1890,"address":[],"length":0,"stats":{"Line":0}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":0}},{"line":1894,"address":[],"length":0,"stats":{"Line":0}},{"line":1895,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":0}},{"line":1941,"address":[],"length":0,"stats":{"Line":0}},{"line":1953,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1955,"address":[],"length":0,"stats":{"Line":0}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1969,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[],"length":0,"stats":{"Line":0}},{"line":1971,"address":[],"length":0,"stats":{"Line":0}},{"line":1972,"address":[],"length":0,"stats":{"Line":0}},{"line":1977,"address":[],"length":0,"stats":{"Line":0}},{"line":1978,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1986,"address":[],"length":0,"stats":{"Line":0}},{"line":1996,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2007,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2022,"address":[],"length":0,"stats":{"Line":0}},{"line":2023,"address":[],"length":0,"stats":{"Line":0}},{"line":2024,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2031,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2038,"address":[],"length":0,"stats":{"Line":0}},{"line":2040,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2044,"address":[],"length":0,"stats":{"Line":0}},{"line":2045,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[],"length":0,"stats":{"Line":0}},{"line":2077,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2097,"address":[],"length":0,"stats":{"Line":0}},{"line":2098,"address":[],"length":0,"stats":{"Line":0}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2100,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[],"length":0,"stats":{"Line":0}},{"line":2102,"address":[],"length":0,"stats":{"Line":0}},{"line":2103,"address":[],"length":0,"stats":{"Line":0}},{"line":2104,"address":[],"length":0,"stats":{"Line":0}},{"line":2110,"address":[],"length":0,"stats":{"Line":0}},{"line":2116,"address":[],"length":0,"stats":{"Line":0}},{"line":2117,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2130,"address":[],"length":0,"stats":{"Line":0}},{"line":2131,"address":[],"length":0,"stats":{"Line":0}},{"line":2132,"address":[],"length":0,"stats":{"Line":0}},{"line":2133,"address":[],"length":0,"stats":{"Line":0}},{"line":2136,"address":[],"length":0,"stats":{"Line":0}},{"line":2142,"address":[],"length":0,"stats":{"Line":0}},{"line":2143,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2148,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[],"length":0,"stats":{"Line":0}},{"line":2154,"address":[],"length":0,"stats":{"Line":0}},{"line":2155,"address":[],"length":0,"stats":{"Line":0}},{"line":2158,"address":[],"length":0,"stats":{"Line":0}},{"line":2159,"address":[],"length":0,"stats":{"Line":0}},{"line":2160,"address":[],"length":0,"stats":{"Line":0}},{"line":2161,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2169,"address":[],"length":0,"stats":{"Line":0}},{"line":2170,"address":[],"length":0,"stats":{"Line":0}},{"line":2172,"address":[],"length":0,"stats":{"Line":0}},{"line":2175,"address":[],"length":0,"stats":{"Line":0}},{"line":2176,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[],"length":0,"stats":{"Line":0}},{"line":2181,"address":[],"length":0,"stats":{"Line":0}},{"line":2185,"address":[],"length":0,"stats":{"Line":0}},{"line":2190,"address":[],"length":0,"stats":{"Line":0}},{"line":2191,"address":[],"length":0,"stats":{"Line":0}},{"line":2192,"address":[],"length":0,"stats":{"Line":0}},{"line":2194,"address":[],"length":0,"stats":{"Line":0}},{"line":2197,"address":[],"length":0,"stats":{"Line":0}},{"line":2198,"address":[],"length":0,"stats":{"Line":0}},{"line":2200,"address":[],"length":0,"stats":{"Line":0}},{"line":2201,"address":[],"length":0,"stats":{"Line":0}},{"line":2202,"address":[],"length":0,"stats":{"Line":0}},{"line":2203,"address":[],"length":0,"stats":{"Line":0}},{"line":2204,"address":[],"length":0,"stats":{"Line":0}},{"line":2205,"address":[],"length":0,"stats":{"Line":0}},{"line":2209,"address":[],"length":0,"stats":{"Line":0}},{"line":2210,"address":[],"length":0,"stats":{"Line":0}},{"line":2211,"address":[],"length":0,"stats":{"Line":0}},{"line":2214,"address":[],"length":0,"stats":{"Line":0}},{"line":2215,"address":[],"length":0,"stats":{"Line":0}},{"line":2216,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2219,"address":[],"length":0,"stats":{"Line":0}},{"line":2221,"address":[],"length":0,"stats":{"Line":0}},{"line":2222,"address":[],"length":0,"stats":{"Line":0}},{"line":2223,"address":[],"length":0,"stats":{"Line":0}},{"line":2225,"address":[],"length":0,"stats":{"Line":0}},{"line":2230,"address":[],"length":0,"stats":{"Line":0}},{"line":2231,"address":[],"length":0,"stats":{"Line":0}},{"line":2232,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2235,"address":[],"length":0,"stats":{"Line":0}},{"line":2236,"address":[],"length":0,"stats":{"Line":0}},{"line":2237,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2239,"address":[],"length":0,"stats":{"Line":0}},{"line":2245,"address":[],"length":0,"stats":{"Line":0}},{"line":2246,"address":[],"length":0,"stats":{"Line":0}},{"line":2247,"address":[],"length":0,"stats":{"Line":0}},{"line":2248,"address":[],"length":0,"stats":{"Line":0}},{"line":2249,"address":[],"length":0,"stats":{"Line":0}},{"line":2253,"address":[],"length":0,"stats":{"Line":0}},{"line":2254,"address":[],"length":0,"stats":{"Line":0}},{"line":2255,"address":[],"length":0,"stats":{"Line":0}},{"line":2257,"address":[],"length":0,"stats":{"Line":0}},{"line":2258,"address":[],"length":0,"stats":{"Line":0}},{"line":2259,"address":[],"length":0,"stats":{"Line":0}},{"line":2260,"address":[],"length":0,"stats":{"Line":0}},{"line":2263,"address":[],"length":0,"stats":{"Line":0}},{"line":2298,"address":[],"length":0,"stats":{"Line":37}},{"line":2300,"address":[],"length":0,"stats":{"Line":37}},{"line":2304,"address":[],"length":0,"stats":{"Line":37}}],"covered":208,"coverable":958},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","frame_extraction.rs"],"content":"//! Frame Extraction - Модуль извлечения кадров для различных целей\n//!\n//! Этот модуль обеспечивает извлечение кадров из видео для:\n//! - Превью на timeline\n//! - Распознавания объектов и сцен\n//! - Анализа субтитров\n//! - Кэширования для быстрого доступа\n\nuse crate::video_compiler::cache::RenderCache;\nuse crate::video_compiler::error::Result;\nuse crate::video_compiler::preview::{PreviewGenerator, VideoInfo};\nuse crate::video_compiler::schema::{Clip, PreviewFormat, Subtitle};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// Тип извлечения кадра\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum ExtractionPurpose {\n  /// Для превью на timeline\n  TimelinePreview,\n  /// Для распознавания объектов (YOLO)\n  ObjectDetection,\n  /// Для распознавания сцен\n  SceneRecognition,\n  /// Для распознавания текста (OCR)\n  TextRecognition,\n  /// Для анализа субтитров\n  SubtitleAnalysis,\n  /// Ключевой кадр (I-frame)\n  KeyFrame,\n  /// Пользовательский скриншот\n  UserScreenshot,\n}\n\n/// Стратегия извлечения кадров\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ExtractionStrategy {\n  /// Равномерное извлечение через интервалы\n  Interval {\n    /// Интервал в секундах\n    seconds: f64,\n  },\n  /// Извлечение по изменению сцены\n  SceneChange {\n    /// Чувствительность (0.0-1.0)\n    threshold: f32,\n  },\n  /// Извлечение по временным меткам субтитров\n  SubtitleSync {\n    /// Смещение от начала субтитра\n    offset_seconds: f64,\n  },\n  /// Извлечение ключевых кадров (I-frames)\n  KeyFrames,\n  /// Комбинированная стратегия\n  Combined {\n    /// Минимальный интервал между кадрами\n    min_interval: f64,\n    /// Включить изменения сцен\n    include_scene_changes: bool,\n    /// Включить ключевые кадры\n    include_keyframes: bool,\n  },\n}\n\n/// Настройки извлечения кадров\n#[derive(Debug, Clone)]\npub struct ExtractionSettings {\n  /// Стратегия извлечения\n  pub strategy: ExtractionStrategy,\n  /// Цель извлечения\n  pub purpose: ExtractionPurpose,\n  /// Разрешение кадров\n  pub resolution: (u32, u32),\n  /// Качество (0-100)\n  pub quality: u8,\n  /// Формат изображения\n  pub format: PreviewFormat,\n  /// Максимальное количество кадров\n  pub max_frames: Option\u003cusize\u003e,\n  /// Использовать GPU для декодирования\n  pub gpu_decode: bool,\n  /// Параллельная обработка\n  pub parallel_extraction: bool,\n  /// Количество потоков\n  pub thread_count: Option\u003cusize\u003e,\n}\n\nimpl Default for ExtractionSettings {\n  fn default() -\u003e Self {\n    Self {\n      strategy: ExtractionStrategy::Interval { seconds: 1.0 },\n      purpose: ExtractionPurpose::TimelinePreview,\n      resolution: (640, 360),\n      quality: 75,\n      format: PreviewFormat::Jpeg,\n      max_frames: None,\n      gpu_decode: false,\n      parallel_extraction: true,\n      thread_count: None,\n    }\n  }\n}\n\n/// Менеджер извлечения кадров\npub struct FrameExtractionManager {\n  /// Генератор превью\n  pub preview_generator: Arc\u003cPreviewGenerator\u003e,\n  /// Кэш\n  cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n  /// Настройки по умолчанию для разных целей\n  purpose_settings: HashMap\u003cExtractionPurpose, ExtractionSettings\u003e,\n  /// Путь к FFmpeg\n  ffmpeg_path: String,\n}\n\nimpl FrameExtractionManager {\n  /// Создать новый менеджер\n  pub fn new(cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e) -\u003e Self {\n    let preview_generator = Arc::new(PreviewGenerator::new(cache.clone()));\n    let mut purpose_settings = HashMap::new();\n\n    // Настройки для timeline превью\n    purpose_settings.insert(\n      ExtractionPurpose::TimelinePreview,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::Combined {\n          min_interval: 0.5,\n          include_scene_changes: true,\n          include_keyframes: true,\n        },\n        purpose: ExtractionPurpose::TimelinePreview,\n        resolution: (160, 90),\n        quality: 60,\n        format: PreviewFormat::Jpeg,\n        max_frames: Some(200),\n        gpu_decode: true,\n        parallel_extraction: true,\n        thread_count: None,\n      },\n    );\n\n    // Настройки для распознавания объектов\n    purpose_settings.insert(\n      ExtractionPurpose::ObjectDetection,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::Interval { seconds: 1.0 },\n        purpose: ExtractionPurpose::ObjectDetection,\n        resolution: (1280, 720), // Выше разрешение для лучшего распознавания\n        quality: 85,\n        format: PreviewFormat::Png, // PNG для лучшего качества\n        max_frames: None,\n        gpu_decode: true,\n        parallel_extraction: true,\n        thread_count: None,\n      },\n    );\n\n    // Настройки для распознавания сцен\n    purpose_settings.insert(\n      ExtractionPurpose::SceneRecognition,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::SceneChange { threshold: 0.3 },\n        purpose: ExtractionPurpose::SceneRecognition,\n        resolution: (960, 540),\n        quality: 80,\n        format: PreviewFormat::Jpeg,\n        max_frames: Some(500),\n        gpu_decode: true,\n        parallel_extraction: true,\n        thread_count: None,\n      },\n    );\n\n    // Настройки для анализа субтитров\n    purpose_settings.insert(\n      ExtractionPurpose::SubtitleAnalysis,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::SubtitleSync {\n          offset_seconds: 0.5,\n        },\n        purpose: ExtractionPurpose::SubtitleAnalysis,\n        resolution: (1920, 1080), // Полное разрешение для OCR\n        quality: 90,\n        format: PreviewFormat::Png,\n        max_frames: None,\n        gpu_decode: true,\n        parallel_extraction: false, // Последовательно для синхронизации\n        thread_count: Some(1),\n      },\n    );\n\n    Self {\n      preview_generator,\n      cache,\n      purpose_settings,\n      ffmpeg_path: \"ffmpeg\".to_string(),\n    }\n  }\n\n  /// Извлечь кадры для клипа\n  pub async fn extract_frames_for_clip(\n    \u0026self,\n    clip: \u0026Clip,\n    settings: Option\u003cExtractionSettings\u003e,\n  ) -\u003e Result\u003cVec\u003cExtractedFrame\u003e\u003e {\n    let settings =\n      settings.unwrap_or_else(|| self.get_default_settings(ExtractionPurpose::TimelinePreview));\n\n    let video_path = \u0026clip.source_path;\n    let video_info = self.preview_generator.get_video_info(video_path).await?;\n\n    // Вычисляем временные метки для извлечения\n    let timestamps = self.calculate_timestamps(\n      \u0026settings.strategy,\n      clip.source_start,\n      clip.source_end,\n      \u0026video_info,\n      None,\n    )?;\n\n    // Извлекаем кадры\n    self\n      .extract_frames_batch(video_path, timestamps, \u0026settings)\n      .await\n  }\n\n  /// Извлечь кадры для субтитров\n  pub async fn extract_frames_for_subtitles(\n    \u0026self,\n    video_path: \u0026Path,\n    subtitles: \u0026[Subtitle],\n    settings: Option\u003cExtractionSettings\u003e,\n  ) -\u003e Result\u003cVec\u003cSubtitleFrame\u003e\u003e {\n    let settings =\n      settings.unwrap_or_else(|| self.get_default_settings(ExtractionPurpose::SubtitleAnalysis));\n\n    let mut frames = Vec::new();\n\n    for subtitle in subtitles {\n      if !subtitle.enabled {\n        continue;\n      }\n\n      // Вычисляем время кадра для субтитра\n      let timestamp = match \u0026settings.strategy {\n        ExtractionStrategy::SubtitleSync { offset_seconds } =\u003e subtitle.start_time + offset_seconds,\n        _ =\u003e subtitle.start_time + 0.5, // По умолчанию 0.5 сек от начала\n      };\n\n      // Извлекаем кадр\n      let frame_data = self\n        .preview_generator\n        .generate_preview(\n          video_path,\n          timestamp,\n          Some(settings.resolution),\n          Some(settings.quality),\n        )\n        .await?;\n\n      frames.push(SubtitleFrame {\n        subtitle_id: subtitle.id.clone(),\n        subtitle_text: subtitle.text.clone(),\n        timestamp,\n        frame_data,\n        start_time: subtitle.start_time,\n        end_time: subtitle.end_time,\n      });\n    }\n\n    Ok(frames)\n  }\n\n  /// Извлечь кадры для распознавания\n  pub async fn extract_frames_for_recognition(\n    \u0026self,\n    video_path: \u0026Path,\n    duration: f64,\n    purpose: ExtractionPurpose,\n  ) -\u003e Result\u003cVec\u003cRecognitionFrame\u003e\u003e {\n    let settings = self.get_default_settings(purpose);\n    let video_info = self.preview_generator.get_video_info(video_path).await?;\n\n    // Вычисляем временные метки\n    let timestamps = self.calculate_timestamps(\n      \u0026settings.strategy,\n      0.0,\n      duration,\n      \u0026video_info,\n      settings.max_frames,\n    )?;\n\n    // Извлекаем кадры\n    let extracted_frames = self\n      .extract_frames_batch(video_path, timestamps, \u0026settings)\n      .await?;\n\n    // Преобразуем в формат для распознавания\n    Ok(\n      extracted_frames\n        .into_iter()\n        .map(|frame| RecognitionFrame {\n          timestamp: frame.timestamp,\n          frame_data: frame.data,\n          resolution: frame.resolution,\n          scene_change_score: frame.scene_change_score,\n          is_keyframe: frame.is_keyframe,\n        })\n        .collect(),\n    )\n  }\n\n  /// Получить существующие скриншоты\n  pub async fn get_existing_screenshots(\u0026self, _video_path: \u0026Path) -\u003e Result\u003cVec\u003cExtractedFrame\u003e\u003e {\n    let _cache = self.cache.read().await;\n\n    // Здесь нужно реализовать получение скриншотов из кэша\n    // Пока возвращаем пустой вектор\n    Ok(Vec::new())\n  }\n\n  /// Получить настройки по умолчанию для цели\n  fn get_default_settings(\u0026self, purpose: ExtractionPurpose) -\u003e ExtractionSettings {\n    self\n      .purpose_settings\n      .get(\u0026purpose)\n      .cloned()\n      .unwrap_or_default()\n  }\n\n  /// Вычислить временные метки для извлечения\n  fn calculate_timestamps(\n    \u0026self,\n    strategy: \u0026ExtractionStrategy,\n    start_time: f64,\n    end_time: f64,\n    _video_info: \u0026VideoInfo,\n    max_frames: Option\u003cusize\u003e,\n  ) -\u003e Result\u003cVec\u003cf64\u003e\u003e {\n    let _duration = end_time - start_time;\n\n    let timestamps = match strategy {\n      ExtractionStrategy::Interval { seconds } =\u003e {\n        let mut timestamps = Vec::new();\n        let mut current = start_time;\n\n        while current \u003c= end_time {\n          timestamps.push(current);\n          current += seconds;\n        }\n\n        timestamps\n      }\n\n      ExtractionStrategy::SceneChange { threshold: _ } =\u003e {\n        // Здесь нужно использовать FFmpeg scene detection\n        // Пока используем простые интервалы\n        vec![] // TODO: Implement scene detection\n      }\n\n      ExtractionStrategy::KeyFrames =\u003e {\n        // Извлечение I-frames через FFmpeg\n        vec![] // TODO: Implement keyframe extraction\n      }\n\n      ExtractionStrategy::Combined {\n        min_interval,\n        include_scene_changes,\n        include_keyframes,\n      } =\u003e {\n        let mut timestamps = Vec::new();\n\n        // Добавляем равномерные интервалы\n        let mut current = start_time;\n        while current \u003c= end_time {\n          timestamps.push(current);\n          current += min_interval;\n        }\n\n        // Добавляем изменения сцен\n        if *include_scene_changes {\n          // TODO: Implement scene detection\n          // let scene_changes = self.detect_scene_changes(start_time, end_time, 0.3)?;\n          // timestamps.extend(scene_changes);\n        }\n\n        // Добавляем ключевые кадры\n        if *include_keyframes {\n          // TODO: Implement keyframe extraction\n          // let keyframes = self.extract_keyframe_timestamps(start_time, end_time)?;\n          // timestamps.extend(keyframes);\n        }\n\n        // Удаляем дубликаты и сортируем\n        timestamps.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        timestamps.dedup();\n\n        // Фильтруем по минимальному интервалу\n        let mut filtered = vec![timestamps[0]];\n        for \u0026ts in \u0026timestamps[1..] {\n          if ts - filtered.last().unwrap() \u003e= *min_interval {\n            filtered.push(ts);\n          }\n        }\n\n        filtered\n      }\n\n      ExtractionStrategy::SubtitleSync { .. } =\u003e {\n        // Обрабатывается отдельно в extract_frames_for_subtitles\n        vec![]\n      }\n    };\n\n    // Ограничиваем количество кадров если необходимо\n    Ok(if let Some(max) = max_frames {\n      timestamps.into_iter().take(max).collect()\n    } else {\n      timestamps\n    })\n  }\n\n  /// Обнаружить изменения сцен\n  async fn detect_scene_changes(\n    \u0026self,\n    _start_time: f64,\n    _end_time: f64,\n    _threshold: f32,\n  ) -\u003e Result\u003cVec\u003cf64\u003e\u003e {\n    // TODO: Реализовать через FFmpeg scene detection filter\n    // ffmpeg -i input.mp4 -filter:v \"select='gt(scene,0.3)',showinfo\" -f null -\n\n    // Пока возвращаем пустой вектор\n    Ok(vec![])\n  }\n\n  /// Извлечь временные метки ключевых кадров\n  async fn extract_keyframe_timestamps(\n    \u0026self,\n    _start_time: f64,\n    _end_time: f64,\n  ) -\u003e Result\u003cVec\u003cf64\u003e\u003e {\n    // TODO: Реализовать через FFmpeg\n    // ffmpeg -i input.mp4 -vf select='eq(pict_type\\,I)' -vsync vfr -f image2 keyframes-%04d.jpg\n\n    // Пока возвращаем пустой вектор\n    Ok(vec![])\n  }\n\n  /// Извлечь пакет кадров\n  async fn extract_frames_batch(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamps: Vec\u003cf64\u003e,\n    settings: \u0026ExtractionSettings,\n  ) -\u003e Result\u003cVec\u003cExtractedFrame\u003e\u003e {\n    let mut frames = Vec::new();\n\n    if settings.parallel_extraction {\n      // Параллельное извлечение\n      let results = self\n        .preview_generator\n        .generate_preview_batch_for_file(\n          video_path,\n          timestamps.clone(),\n          Some(settings.resolution),\n          Some(settings.quality),\n        )\n        .await?;\n\n      for (i, result) in results.into_iter().enumerate() {\n        match result.result {\n          Ok(data) =\u003e {\n            frames.push(ExtractedFrame {\n              timestamp: timestamps[i],\n              data,\n              resolution: settings.resolution,\n              purpose: settings.purpose.clone(),\n              scene_change_score: None,\n              is_keyframe: false,\n            });\n          }\n          Err(e) =\u003e {\n            log::warn!(\"Не удалось извлечь кадр на {:.2}s: {}\", timestamps[i], e);\n          }\n        }\n      }\n    } else {\n      // Последовательное извлечение\n      for timestamp in timestamps {\n        match self\n          .preview_generator\n          .generate_preview(\n            video_path,\n            timestamp,\n            Some(settings.resolution),\n            Some(settings.quality),\n          )\n          .await\n        {\n          Ok(data) =\u003e {\n            frames.push(ExtractedFrame {\n              timestamp,\n              data,\n              resolution: settings.resolution,\n              purpose: settings.purpose.clone(),\n              scene_change_score: None,\n              is_keyframe: false,\n            });\n          }\n          Err(e) =\u003e {\n            log::warn!(\"Не удалось извлечь кадр на {:.2}s: {}\", timestamp, e);\n          }\n        }\n      }\n    }\n\n    Ok(frames)\n  }\n}\n\n/// Извлеченный кадр\n#[derive(Debug, Clone)]\npub struct ExtractedFrame {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные изображения\n  pub data: Vec\u003cu8\u003e,\n  /// Разрешение\n  pub resolution: (u32, u32),\n  /// Цель извлечения\n  pub purpose: ExtractionPurpose,\n  /// Оценка изменения сцены (если доступно)\n  pub scene_change_score: Option\u003cf32\u003e,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Кадр для субтитра\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SubtitleFrame {\n  /// ID субтитра\n  pub subtitle_id: String,\n  /// Текст субтитра\n  pub subtitle_text: String,\n  /// Временная метка кадра\n  pub timestamp: f64,\n  /// Данные кадра\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Время начала субтитра\n  pub start_time: f64,\n  /// Время окончания субтитра\n  pub end_time: f64,\n}\n\n/// Кадр для распознавания\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RecognitionFrame {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные кадра\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Разрешение\n  pub resolution: (u32, u32),\n  /// Оценка изменения сцены\n  pub scene_change_score: Option\u003cf32\u003e,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Метаданные извлечения кадров\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExtractionMetadata {\n  /// Путь к видео\n  pub video_path: String,\n  /// Общее количество извлеченных кадров\n  pub total_frames: usize,\n  /// Использованная стратегия\n  pub strategy: ExtractionStrategy,\n  /// Цель извлечения\n  pub purpose: ExtractionPurpose,\n  /// Время извлечения (мс)\n  pub extraction_time_ms: u64,\n  /// Использовалось ли GPU ускорение\n  pub gpu_used: bool,\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::cache::{PreviewKey, PreviewData, MediaMetadata};\n  use crate::video_compiler::preview::VideoInfo;\n  use std::collections::HashMap;\n  use std::time::{Duration, SystemTime};\n  use tempfile::NamedTempFile;\n\n  #[test]\n  fn test_extraction_settings_default() {\n    let settings = ExtractionSettings::default();\n    assert_eq!(settings.resolution, (640, 360));\n    assert_eq!(settings.quality, 75);\n    assert!(settings.parallel_extraction);\n    assert!(!settings.gpu_decode);\n    assert_eq!(settings.max_frames, None);\n    assert_eq!(settings.thread_count, None);\n    assert!(matches!(settings.strategy, ExtractionStrategy::Interval { seconds } if seconds == 1.0));\n    assert_eq!(settings.purpose, ExtractionPurpose::TimelinePreview);\n    assert!(matches!(settings.format, PreviewFormat::Jpeg));\n  }\n\n  #[test]\n  fn test_extraction_purpose_equality() {\n    assert_eq!(\n      ExtractionPurpose::TimelinePreview,\n      ExtractionPurpose::TimelinePreview\n    );\n    assert_ne!(\n      ExtractionPurpose::TimelinePreview,\n      ExtractionPurpose::ObjectDetection\n    );\n  }\n\n  #[test]\n  fn test_extraction_purpose_serialization() {\n    let purpose = ExtractionPurpose::ObjectDetection;\n    let json = serde_json::to_string(\u0026purpose).unwrap();\n    assert!(json.contains(\"ObjectDetection\"));\n    \n    let deserialized: ExtractionPurpose = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized, purpose);\n  }\n\n  #[test]\n  fn test_extraction_strategy_serialization() {\n    let strategies = vec![\n      ExtractionStrategy::Interval { seconds: 2.5 },\n      ExtractionStrategy::SceneChange { threshold: 0.4 },\n      ExtractionStrategy::SubtitleSync { offset_seconds: 0.3 },\n      ExtractionStrategy::KeyFrames,\n      ExtractionStrategy::Combined {\n        min_interval: 1.0,\n        include_scene_changes: true,\n        include_keyframes: false,\n      },\n    ];\n\n    for strategy in strategies {\n      let json = serde_json::to_string(\u0026strategy).unwrap();\n      let deserialized: ExtractionStrategy = serde_json::from_str(\u0026json).unwrap();\n      \n      match (\u0026strategy, \u0026deserialized) {\n        (ExtractionStrategy::Interval { seconds: s1 }, ExtractionStrategy::Interval { seconds: s2 }) =\u003e {\n          assert_eq!(s1, s2);\n        }\n        (ExtractionStrategy::SceneChange { threshold: t1 }, ExtractionStrategy::SceneChange { threshold: t2 }) =\u003e {\n          assert_eq!(t1, t2);\n        }\n        _ =\u003e {}\n      }\n    }\n  }\n\n  #[tokio::test]\n  async fn test_frame_extraction_manager_new() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    assert_eq!(manager.ffmpeg_path, \"ffmpeg\");\n    assert!(!manager.purpose_settings.is_empty());\n    \n    // Check default settings for different purposes\n    let timeline_settings = manager.get_default_settings(ExtractionPurpose::TimelinePreview);\n    assert_eq!(timeline_settings.resolution, (160, 90));\n    assert_eq!(timeline_settings.quality, 60);\n    \n    let object_detection_settings = manager.get_default_settings(ExtractionPurpose::ObjectDetection);\n    assert_eq!(object_detection_settings.resolution, (1280, 720));\n    assert_eq!(object_detection_settings.quality, 85);\n  }\n\n  #[test]\n  fn test_preview_key_new() {\n    let key = PreviewKey::new(\n      \"/test/video.mp4\".to_string(),\n      10.5,\n      (1920, 1080),\n      85\n    );\n    \n    assert_eq!(key.file_path, \"/test/video.mp4\");\n    assert_eq!(key.timestamp, 10500); // 10.5 * 1000\n    assert_eq!(key.resolution, (1920, 1080));\n    assert_eq!(key.quality, 85);\n  }\n\n  #[test]\n  fn test_preview_data_is_expired() {\n    let data = PreviewData {\n      image_data: vec![1, 2, 3],\n      timestamp: SystemTime::now() - Duration::from_secs(3600),\n      access_count: 5,\n    };\n    \n    assert!(data.is_expired(Duration::from_secs(1800))); // Should be expired\n    assert!(!data.is_expired(Duration::from_secs(7200))); // Should not be expired\n  }\n\n  #[test]\n  fn test_media_metadata_serialization() {\n    let metadata = MediaMetadata {\n      file_path: \"/test/video.mp4\".to_string(),\n      file_size: 1024000,\n      modified_time: SystemTime::now(),\n      duration: 120.5,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n      cached_at: SystemTime::now(),\n    };\n    \n    let json = serde_json::to_string(\u0026metadata).unwrap();\n    assert!(json.contains(\"1024000\"));\n    assert!(json.contains(\"120.5\"));\n    \n    let deserialized: MediaMetadata = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.file_path, metadata.file_path);\n    assert_eq!(deserialized.duration, metadata.duration);\n  }\n\n  #[test]\n  fn test_subtitle_frame_serialization() {\n    let frame = SubtitleFrame {\n      subtitle_id: \"sub-001\".to_string(),\n      subtitle_text: \"Hello World\".to_string(),\n      timestamp: 15.5,\n      frame_data: vec![10, 20, 30],\n      start_time: 15.0,\n      end_time: 17.0,\n    };\n    \n    let json = serde_json::to_string(\u0026frame).unwrap();\n    assert!(json.contains(\"sub-001\"));\n    assert!(json.contains(\"Hello World\"));\n    assert!(json.contains(\"15.5\"));\n    \n    let deserialized: SubtitleFrame = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.subtitle_id, frame.subtitle_id);\n    assert_eq!(deserialized.timestamp, frame.timestamp);\n  }\n\n  #[test]\n  fn test_recognition_frame_serialization() {\n    let frame = RecognitionFrame {\n      timestamp: 20.0,\n      frame_data: vec![5, 10, 15],\n      resolution: (1280, 720),\n      scene_change_score: Some(0.75),\n      is_keyframe: true,\n    };\n    \n    let json = serde_json::to_string(\u0026frame).unwrap();\n    assert!(json.contains(\"20.0\"));\n    assert!(json.contains(\"1280\"));\n    assert!(json.contains(\"0.75\"));\n    assert!(json.contains(\"true\"));\n    \n    let deserialized: RecognitionFrame = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.timestamp, frame.timestamp);\n    assert_eq!(deserialized.scene_change_score, frame.scene_change_score);\n  }\n\n  #[test]\n  fn test_extraction_metadata_serialization() {\n    let metadata = ExtractionMetadata {\n      video_path: \"/test/video.mp4\".to_string(),\n      total_frames: 100,\n      strategy: ExtractionStrategy::Interval { seconds: 1.0 },\n      purpose: ExtractionPurpose::TimelinePreview,\n      extraction_time_ms: 5000,\n      gpu_used: true,\n    };\n    \n    let json = serde_json::to_string(\u0026metadata).unwrap();\n    assert!(json.contains(\"/test/video.mp4\"));\n    assert!(json.contains(\"100\"));\n    assert!(json.contains(\"5000\"));\n    \n    let deserialized: ExtractionMetadata = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.total_frames, metadata.total_frames);\n    assert_eq!(deserialized.gpu_used, metadata.gpu_used);\n  }\n\n  #[test]\n  fn test_extracted_frame_creation() {\n    let frame = ExtractedFrame {\n      timestamp: 5.0,\n      data: vec![1, 2, 3, 4, 5],\n      resolution: (640, 360),\n      purpose: ExtractionPurpose::TimelinePreview,\n      scene_change_score: Some(0.45),\n      is_keyframe: false,\n    };\n    \n    assert_eq!(frame.timestamp, 5.0);\n    assert_eq!(frame.data.len(), 5);\n    assert_eq!(frame.resolution, (640, 360));\n    assert_eq!(frame.scene_change_score, Some(0.45));\n  }\n\n  #[tokio::test]\n  async fn test_calculate_timestamps_interval_strategy() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    let strategy = ExtractionStrategy::Interval { seconds: 2.0 };\n    let video_info = VideoInfo {\n      duration: 10.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let timestamps = manager.calculate_timestamps(\n      \u0026strategy,\n      0.0,\n      10.0,\n      \u0026video_info,\n      None\n    ).unwrap();\n    \n    assert_eq!(timestamps.len(), 6); // 0, 2, 4, 6, 8, 10\n    assert_eq!(timestamps[0], 0.0);\n    assert_eq!(timestamps[1], 2.0);\n    assert_eq!(timestamps[5], 10.0);\n  }\n\n  #[tokio::test]\n  async fn test_calculate_timestamps_with_max_frames() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    let strategy = ExtractionStrategy::Interval { seconds: 1.0 };\n    let video_info = VideoInfo {\n      duration: 60.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let timestamps = manager.calculate_timestamps(\n      \u0026strategy,\n      0.0,\n      60.0,\n      \u0026video_info,\n      Some(5)\n    ).unwrap();\n    \n    assert_eq!(timestamps.len(), 5); // Limited to 5 frames\n  }\n\n  #[tokio::test]\n  async fn test_calculate_timestamps_combined_strategy() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    let strategy = ExtractionStrategy::Combined {\n      min_interval: 2.0,\n      include_scene_changes: false,\n      include_keyframes: false,\n    };\n    let video_info = VideoInfo {\n      duration: 10.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let timestamps = manager.calculate_timestamps(\n      \u0026strategy,\n      0.0,\n      10.0,\n      \u0026video_info,\n      None\n    ).unwrap();\n    \n    assert!(timestamps.len() \u003e 0);\n    assert_eq!(timestamps[0], 0.0);\n    \n    // Check minimum interval between timestamps\n    for i in 1..timestamps.len() {\n      assert!(timestamps[i] - timestamps[i-1] \u003e= 2.0);\n    }\n  }\n\n  #[tokio::test]\n  async fn test_default_purpose_settings() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    // Test Timeline Preview settings\n    let timeline_settings = manager.get_default_settings(ExtractionPurpose::TimelinePreview);\n    assert_eq!(timeline_settings.purpose, ExtractionPurpose::TimelinePreview);\n    assert_eq!(timeline_settings.resolution, (160, 90));\n    assert_eq!(timeline_settings.quality, 60);\n    assert_eq!(timeline_settings.max_frames, Some(200));\n    \n    // Test Object Detection settings\n    let object_settings = manager.get_default_settings(ExtractionPurpose::ObjectDetection);\n    assert_eq!(object_settings.purpose, ExtractionPurpose::ObjectDetection);\n    assert_eq!(object_settings.resolution, (1280, 720));\n    assert_eq!(object_settings.quality, 85);\n    assert!(matches!(object_settings.format, PreviewFormat::Png));\n    \n    // Test Scene Recognition settings  \n    let scene_settings = manager.get_default_settings(ExtractionPurpose::SceneRecognition);\n    assert_eq!(scene_settings.resolution, (960, 540));\n    assert_eq!(scene_settings.quality, 80);\n    assert_eq!(scene_settings.max_frames, Some(500));\n    \n    // Test Subtitle Analysis settings\n    let subtitle_settings = manager.get_default_settings(ExtractionPurpose::SubtitleAnalysis);\n    assert_eq!(subtitle_settings.resolution, (1920, 1080));\n    assert_eq!(subtitle_settings.quality, 90);\n    assert!(!subtitle_settings.parallel_extraction);\n  }\n\n  #[test]\n  fn test_all_extraction_purposes() {\n    let purposes = vec![\n      ExtractionPurpose::TimelinePreview,\n      ExtractionPurpose::ObjectDetection,\n      ExtractionPurpose::SceneRecognition,\n      ExtractionPurpose::TextRecognition,\n      ExtractionPurpose::SubtitleAnalysis,\n      ExtractionPurpose::KeyFrame,\n      ExtractionPurpose::UserScreenshot,\n    ];\n    \n    for purpose in purposes {\n      let json = serde_json::to_string(\u0026purpose).unwrap();\n      let deserialized: ExtractionPurpose = serde_json::from_str(\u0026json).unwrap();\n      assert_eq!(purpose, deserialized);\n    }\n  }\n\n  #[test]\n  fn test_purpose_hash_map() {\n    let mut map = HashMap::new();\n    map.insert(ExtractionPurpose::TimelinePreview, \"preview\");\n    map.insert(ExtractionPurpose::ObjectDetection, \"detection\");\n    \n    assert_eq!(map.get(\u0026ExtractionPurpose::TimelinePreview), Some(\u0026\"preview\"));\n    assert_eq!(map.get(\u0026ExtractionPurpose::ObjectDetection), Some(\u0026\"detection\"));\n  }\n}\n","traces":[{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":5}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":5}},{"line":129,"address":[],"length":0,"stats":{"Line":5}},{"line":130,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":5}},{"line":133,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":137,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":5}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":149,"address":[],"length":0,"stats":{"Line":5}},{"line":150,"address":[],"length":0,"stats":{"Line":5}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":5}},{"line":154,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":5}},{"line":156,"address":[],"length":0,"stats":{"Line":5}},{"line":157,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":5}},{"line":165,"address":[],"length":0,"stats":{"Line":5}},{"line":166,"address":[],"length":0,"stats":{"Line":5}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":5}},{"line":170,"address":[],"length":0,"stats":{"Line":5}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":172,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":5}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":179,"address":[],"length":0,"stats":{"Line":5}},{"line":180,"address":[],"length":0,"stats":{"Line":5}},{"line":181,"address":[],"length":0,"stats":{"Line":5}},{"line":182,"address":[],"length":0,"stats":{"Line":5}},{"line":183,"address":[],"length":0,"stats":{"Line":5}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":5}},{"line":189,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":192,"address":[],"length":0,"stats":{"Line":5}},{"line":200,"address":[],"length":0,"stats":{"Line":5}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":328,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":6}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":344,"address":[],"length":0,"stats":{"Line":3}},{"line":346,"address":[],"length":0,"stats":{"Line":6}},{"line":347,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":136}},{"line":352,"address":[],"length":0,"stats":{"Line":67}},{"line":353,"address":[],"length":0,"stats":{"Line":67}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":373,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":13}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":385,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":7}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":6}},{"line":405,"address":[],"length":0,"stats":{"Line":5}},{"line":406,"address":[],"length":0,"stats":{"Line":5}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":423,"address":[],"length":0,"stats":{"Line":2}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}}],"covered":92,"coverable":203},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","gpu.rs"],"content":"/*!\n * GPU ускорение для Video Compiler\n *\n * Этот модуль отвечает за:\n * - Автоматическое определение доступных GPU кодировщиков\n * - Выбор оптимального кодировщика для каждой платформы\n * - Мониторинг использования GPU во время рендеринга\n * - Fallback на CPU кодирование при недоступности GPU\n */\n\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse serde::{Deserialize, Serialize};\n\n/// Типы GPU кодировщиков\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum GpuEncoder {\n  /// Нет GPU ускорения (CPU only)\n  None,\n  /// NVIDIA NVENC\n  Nvenc,\n  /// Intel QuickSync Video\n  QuickSync,\n  /// Video Acceleration API (Linux)\n  Vaapi,\n  /// Apple VideoToolbox (macOS)\n  VideoToolbox,\n  /// AMD Advanced Media Framework\n  AMF,\n}\n\nimpl GpuEncoder {\n  /// Получить название FFmpeg кодека для H.264\n  pub fn h264_codec_name(\u0026self) -\u003e \u0026'static str {\n    match self {\n      GpuEncoder::None =\u003e \"libx264\",\n      GpuEncoder::Nvenc =\u003e \"h264_nvenc\",\n      GpuEncoder::QuickSync =\u003e \"h264_qsv\",\n      GpuEncoder::Vaapi =\u003e \"h264_vaapi\",\n      GpuEncoder::VideoToolbox =\u003e \"h264_videotoolbox\",\n      GpuEncoder::AMF =\u003e \"h264_amf\",\n    }\n  }\n\n  /// Получить название FFmpeg кодека для H.265/HEVC\n  pub fn hevc_codec_name(\u0026self) -\u003e \u0026'static str {\n    match self {\n      GpuEncoder::None =\u003e \"libx265\",\n      GpuEncoder::Nvenc =\u003e \"hevc_nvenc\",\n      GpuEncoder::QuickSync =\u003e \"hevc_qsv\",\n      GpuEncoder::Vaapi =\u003e \"hevc_vaapi\",\n      GpuEncoder::VideoToolbox =\u003e \"hevc_videotoolbox\",\n      GpuEncoder::AMF =\u003e \"hevc_amf\",\n    }\n  }\n\n  /// Проверить, является ли кодировщик аппаратным\n  pub fn is_hardware(\u0026self) -\u003e bool {\n    !matches!(self, GpuEncoder::None)\n  }\n}\n\n/// Информация о GPU\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GpuInfo {\n  pub name: String,\n  pub driver_version: Option\u003cString\u003e,\n  pub memory_total: Option\u003cu64\u003e,\n  pub memory_used: Option\u003cu64\u003e,\n  pub utilization: Option\u003cf32\u003e,\n  pub encoder_type: GpuEncoder,\n  pub supported_codecs: Vec\u003cString\u003e,\n}\n\n/// Возможности GPU системы\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GpuCapabilities {\n  pub available_encoders: Vec\u003cGpuEncoder\u003e,\n  pub recommended_encoder: Option\u003cGpuEncoder\u003e,\n  pub current_gpu: Option\u003cGpuInfo\u003e,\n  pub hardware_acceleration_supported: bool,\n}\n\n/// Детектор GPU возможностей\npub struct GpuDetector {\n  ffmpeg_path: String,\n}\n\nimpl GpuDetector {\n  pub fn new(ffmpeg_path: String) -\u003e Self {\n    Self { ffmpeg_path }\n  }\n\n  /// Определить все доступные GPU кодировщики\n  pub async fn detect_available_encoders(\u0026self) -\u003e Result\u003cVec\u003cGpuEncoder\u003e\u003e {\n    let mut available = Vec::new();\n\n    // Проверяем каждый тип кодировщика\n    let encoders_to_check = [\n      (GpuEncoder::Nvenc, \"h264_nvenc\"),\n      (GpuEncoder::QuickSync, \"h264_qsv\"),\n      (GpuEncoder::Vaapi, \"h264_vaapi\"),\n      (GpuEncoder::VideoToolbox, \"h264_videotoolbox\"),\n      (GpuEncoder::AMF, \"h264_amf\"),\n    ];\n\n    for (encoder_type, codec_name) in encoders_to_check {\n      if self.check_encoder_available(codec_name).await? {\n        available.push(encoder_type);\n      }\n    }\n\n    Ok(available)\n  }\n\n  /// Проверить доступность конкретного кодировщика\n  async fn check_encoder_available(\u0026self, codec: \u0026str) -\u003e Result\u003cbool\u003e {\n    let output = tokio::process::Command::new(\u0026self.ffmpeg_path)\n      .args([\"-encoders\"])\n      .output()\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to run ffmpeg: {}\", e)))?;\n\n    if output.status.success() {\n      let stdout = String::from_utf8_lossy(\u0026output.stdout);\n      Ok(stdout.contains(codec))\n    } else {\n      Ok(false)\n    }\n  }\n\n  /// Получить рекомендуемый кодировщик для текущей платформы\n  pub async fn get_recommended_encoder(\u0026self) -\u003e Result\u003cOption\u003cGpuEncoder\u003e\u003e {\n    let available = self.detect_available_encoders().await?;\n\n    if available.is_empty() {\n      return Ok(None);\n    }\n\n    // Приоритет кодировщиков по платформам\n    #[cfg(target_os = \"windows\")]\n    let priority = [GpuEncoder::Nvenc, GpuEncoder::QuickSync, GpuEncoder::AMF];\n\n    #[cfg(target_os = \"linux\")]\n    let priority = [GpuEncoder::Nvenc, GpuEncoder::Vaapi, GpuEncoder::QuickSync];\n\n    #[cfg(target_os = \"macos\")]\n    let priority = [GpuEncoder::VideoToolbox, GpuEncoder::Nvenc];\n\n    #[cfg(not(any(target_os = \"windows\", target_os = \"linux\", target_os = \"macos\")))]\n    let priority = [GpuEncoder::Nvenc];\n\n    // Находим первый доступный из приоритетного списка\n    for preferred in \u0026priority {\n      if available.contains(preferred) {\n        return Ok(Some(preferred.clone()));\n      }\n    }\n\n    // Если ни один приоритетный не найден, берем первый доступный\n    Ok(available.first().cloned())\n  }\n\n  /// Получить полную информацию о возможностях GPU\n  pub async fn get_gpu_capabilities(\u0026self) -\u003e Result\u003cGpuCapabilities\u003e {\n    let available_encoders = self.detect_available_encoders().await?;\n    let recommended_encoder = self.get_recommended_encoder().await?;\n    let current_gpu = self.get_current_gpu_info().await.ok();\n\n    Ok(GpuCapabilities {\n      available_encoders: available_encoders.clone(),\n      recommended_encoder,\n      current_gpu,\n      hardware_acceleration_supported: !available_encoders.is_empty(),\n    })\n  }\n\n  /// Получить информацию о текущем GPU\n  async fn get_current_gpu_info(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Пытаемся определить тип GPU и получить информацию\n\n    #[cfg(target_os = \"windows\")]\n    {\n      if let Ok(info) = self.get_nvidia_info_windows().await {\n        return Ok(info);\n      }\n      if let Ok(info) = self.get_intel_info_windows().await {\n        return Ok(info);\n      }\n      if let Ok(info) = self.get_amd_info_windows().await {\n        return Ok(info);\n      }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    {\n      if let Ok(info) = self.get_nvidia_info_linux().await {\n        return Ok(info);\n      }\n      if let Ok(info) = self.get_gpu_info_linux().await {\n        return Ok(info);\n      }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n      if let Ok(info) = self.get_gpu_info_macos().await {\n        return Ok(info);\n      }\n    }\n\n    // Fallback: создаем базовую информацию\n    Ok(GpuInfo {\n      name: \"Unknown GPU\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::None,\n      supported_codecs: vec![\"libx264\".to_string()],\n    })\n  }\n\n  /// Получить информацию о NVIDIA GPU (Windows)\n  #[cfg(target_os = \"windows\")]\n  async fn get_nvidia_info_windows(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    let output = tokio::process::Command::new(\"nvidia-smi\")\n      .args([\n        \"--query-gpu=name,driver_version,memory.total,memory.used,utilization.gpu\",\n        \"--format=csv,noheader,nounits\",\n      ])\n      .output()\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to run nvidia-smi: {}\", e)))?;\n\n    if !output.status.success() {\n      return Err(VideoCompilerError::gpu(\"nvidia-smi failed\"));\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let line = stdout\n      .lines()\n      .next()\n      .ok_or_else(|| VideoCompilerError::gpu(\"No GPU data from nvidia-smi\"))?;\n\n    let parts: Vec\u003c\u0026str\u003e = line.split(\", \").collect();\n    if parts.len() \u003e= 5 {\n      Ok(GpuInfo {\n        name: parts[0].trim().to_string(),\n        driver_version: Some(parts[1].trim().to_string()),\n        memory_total: parts[2].trim().parse::\u003cu64\u003e().ok().map(|m| m * 1024 * 1024),\n        memory_used: parts[3].trim().parse::\u003cu64\u003e().ok().map(|m| m * 1024 * 1024),\n        utilization: parts[4].trim().parse().ok(),\n        encoder_type: GpuEncoder::Nvenc,\n        supported_codecs: vec![\"h264_nvenc\".to_string(), \"hevc_nvenc\".to_string()],\n      })\n    } else {\n      Err(VideoCompilerError::gpu(\"Invalid nvidia-smi output format\"))\n    }\n  }\n\n  /// Получить информацию о NVIDIA GPU (Linux)\n  #[cfg(target_os = \"linux\")]\n  async fn get_nvidia_info_linux(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Аналогично Windows версии\n    self.get_nvidia_info_windows().await\n  }\n\n  /// Получить информацию о Intel GPU (Windows)\n  #[cfg(target_os = \"windows\")]\n  async fn get_intel_info_windows(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Для Intel можно использовать WMI или другие системные API\n    // Пока простая заглушка\n    Ok(GpuInfo {\n      name: \"Intel Graphics\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::QuickSync,\n      supported_codecs: vec![\"h264_qsv\".to_string(), \"hevc_qsv\".to_string()],\n    })\n  }\n\n  /// Получить информацию о AMD GPU (Windows)\n  #[cfg(target_os = \"windows\")]\n  async fn get_amd_info_windows(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    Ok(GpuInfo {\n      name: \"AMD Graphics\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::AMF,\n      supported_codecs: vec![\"h264_amf\".to_string(), \"hevc_amf\".to_string()],\n    })\n  }\n\n  /// Получить информацию о GPU (Linux через /sys)\n  #[cfg(target_os = \"linux\")]\n  async fn get_gpu_info_linux(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Читаем информацию из /sys/class/drm\n    use tokio::fs;\n\n    let drm_cards = fs::read_dir(\"/sys/class/drm\")\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to read /sys/class/drm: {}\", e)))?;\n\n    // Ищем первую видеокарту\n    // Это упрощенная реализация, можно расширить\n    Ok(GpuInfo {\n      name: \"Linux GPU\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::Vaapi,\n      supported_codecs: vec![\"h264_vaapi\".to_string()],\n    })\n  }\n\n  /// Получить информацию о GPU (macOS)\n  #[cfg(target_os = \"macos\")]\n  async fn get_gpu_info_macos(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Используем system_profiler для получения информации\n    let output = tokio::process::Command::new(\"system_profiler\")\n      .args([\"SPDisplaysDataType\", \"-json\"])\n      .output()\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to run system_profiler: {}\", e)))?;\n\n    if output.status.success() {\n      // Парсим JSON вывод system_profiler\n      // Упрощенная реализация\n      Ok(GpuInfo {\n        name: \"macOS GPU\".to_string(),\n        driver_version: None,\n        memory_total: None,\n        memory_used: None,\n        utilization: None,\n        encoder_type: GpuEncoder::VideoToolbox,\n        supported_codecs: vec![\n          \"h264_videotoolbox\".to_string(),\n          \"hevc_videotoolbox\".to_string(),\n        ],\n      })\n    } else {\n      Err(VideoCompilerError::gpu(\"system_profiler failed\"))\n    }\n  }\n}\n\n/// Помощник для выбора GPU параметров\npub struct GpuHelper;\n\nimpl GpuHelper {\n  /// Получить параметры FFmpeg для конкретного GPU кодировщика\n  pub fn get_ffmpeg_params(encoder: \u0026GpuEncoder, quality: u8) -\u003e Vec\u003cString\u003e {\n    match encoder {\n      GpuEncoder::None =\u003e Self::get_cpu_params(quality),\n      GpuEncoder::Nvenc =\u003e Self::get_nvenc_params(quality),\n      GpuEncoder::QuickSync =\u003e Self::get_quicksync_params(quality),\n      GpuEncoder::Vaapi =\u003e Self::get_vaapi_params(quality),\n      GpuEncoder::VideoToolbox =\u003e Self::get_videotoolbox_params(quality),\n      GpuEncoder::AMF =\u003e Self::get_amf_params(quality),\n    }\n  }\n\n  /// Параметры для CPU кодирования\n  fn get_cpu_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    let preset = match quality {\n      0..=30 =\u003e \"ultrafast\",\n      31..=50 =\u003e \"superfast\",\n      51..=70 =\u003e \"fast\",\n      71..=85 =\u003e \"medium\",\n      86..=95 =\u003e \"slow\",\n      _ =\u003e \"slower\",\n    };\n\n    vec![\n      \"-preset\".to_string(),\n      preset.to_string(),\n      \"-crf\".to_string(),\n      Self::quality_to_crf(quality).to_string(),\n    ]\n  }\n\n  /// Параметры для NVIDIA NVENC\n  fn get_nvenc_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    let preset = match quality {\n      0..=40 =\u003e \"p1\", // Fastest\n      41..=60 =\u003e \"p2\",\n      61..=75 =\u003e \"p3\",\n      76..=85 =\u003e \"p4\", // Balanced\n      86..=90 =\u003e \"p5\",\n      91..=95 =\u003e \"p6\",\n      _ =\u003e \"p7\", // Slowest/Best quality\n    };\n\n    vec![\n      \"-preset\".to_string(),\n      preset.to_string(),\n      \"-tune\".to_string(),\n      \"hq\".to_string(),\n      \"-rc\".to_string(),\n      \"vbr\".to_string(),\n      \"-cq\".to_string(),\n      Self::quality_to_nvenc_cq(quality).to_string(),\n      \"-rc-lookahead\".to_string(),\n      \"20\".to_string(),\n      \"-spatial_aq\".to_string(),\n      \"1\".to_string(),\n      \"-temporal_aq\".to_string(),\n      \"1\".to_string(),\n    ]\n  }\n\n  /// Параметры для Intel QuickSync\n  fn get_quicksync_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    let preset = match quality {\n      0..=50 =\u003e \"veryfast\",\n      51..=75 =\u003e \"fast\",\n      76..=85 =\u003e \"medium\",\n      _ =\u003e \"slow\",\n    };\n\n    vec![\n      \"-preset\".to_string(),\n      preset.to_string(),\n      \"-global_quality\".to_string(),\n      Self::quality_to_qsv_quality(quality).to_string(),\n      \"-look_ahead\".to_string(),\n      \"1\".to_string(),\n      \"-look_ahead_depth\".to_string(),\n      \"20\".to_string(),\n    ]\n  }\n\n  /// Параметры для VAAPI\n  fn get_vaapi_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    vec![\n      \"-vaapi_device\".to_string(),\n      \"/dev/dri/renderD128\".to_string(),\n      \"-vf\".to_string(),\n      \"format=nv12,hwupload\".to_string(),\n      \"-rc_mode\".to_string(),\n      \"VBR\".to_string(),\n      \"-quality\".to_string(),\n      Self::quality_to_vaapi_quality(quality).to_string(),\n    ]\n  }\n\n  /// Параметры для VideoToolbox\n  fn get_videotoolbox_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    vec![\n      \"-profile:v\".to_string(),\n      \"high\".to_string(),\n      \"-level\".to_string(),\n      \"4.1\".to_string(),\n      \"-q:v\".to_string(),\n      Self::quality_to_videotoolbox_quality(quality).to_string(),\n      \"-allow_sw\".to_string(),\n      \"1\".to_string(),\n    ]\n  }\n\n  /// Параметры для AMD AMF\n  fn get_amf_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    vec![\n      \"-usage\".to_string(),\n      \"transcoding\".to_string(),\n      \"-quality\".to_string(),\n      \"balanced\".to_string(),\n      \"-rc\".to_string(),\n      \"vbr_peak\".to_string(),\n      \"-qp_i\".to_string(),\n      Self::quality_to_amf_qp(quality).to_string(),\n    ]\n  }\n\n  /// Конвертация качества (0-100) в CRF (0-51)\n  fn quality_to_crf(quality: u8) -\u003e u8 {\n    // Инвертируем: высокое качество = низкий CRF\n    51 - (quality as f32 * 0.51) as u8\n  }\n\n  /// Конвертация качества в NVENC CQ параметр\n  fn quality_to_nvenc_cq(quality: u8) -\u003e u8 {\n    // NVENC CQ: 0-51, где 0 = лучшее качество\n    51 - (quality as f32 * 0.51) as u8\n  }\n\n  /// Конвертация качества в QuickSync quality\n  fn quality_to_qsv_quality(quality: u8) -\u003e u8 {\n    // QSV качество обычно 1-51\n    51 - (quality as f32 * 0.5) as u8\n  }\n\n  /// Конвертация качества в VAAPI quality\n  fn quality_to_vaapi_quality(quality: u8) -\u003e u8 {\n    // VAAPI качество 1-8, где 1 = лучшее\n    8 - (quality as f32 * 0.07) as u8\n  }\n\n  /// Конвертация качества в VideoToolbox quality\n  fn quality_to_videotoolbox_quality(quality: u8) -\u003e u8 {\n    // VideoToolbox q:v 1-100\n    quality.max(1)\n  }\n\n  /// Конвертация качества в AMF QP\n  fn quality_to_amf_qp(quality: u8) -\u003e u8 {\n    // AMF QP 0-51\n    51 - (quality as f32 * 0.51) as u8\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[tokio::test]\n  async fn test_gpu_encoder_codec_names() {\n    assert_eq!(GpuEncoder::Nvenc.h264_codec_name(), \"h264_nvenc\");\n    assert_eq!(GpuEncoder::QuickSync.h264_codec_name(), \"h264_qsv\");\n    assert_eq!(GpuEncoder::None.h264_codec_name(), \"libx264\");\n  }\n\n  #[tokio::test]\n  async fn test_quality_conversion() {\n    // Тест конвертации качества в CRF\n    assert_eq!(GpuHelper::quality_to_crf(100), 0); // Лучшее качество\n    assert_eq!(GpuHelper::quality_to_crf(0), 51); // Худшее качество\n    assert_eq!(GpuHelper::quality_to_crf(50), 26); // Среднее качество\n  }\n\n  #[tokio::test]\n  async fn test_gpu_params_generation() {\n    let params = GpuHelper::get_ffmpeg_params(\u0026GpuEncoder::Nvenc, 85);\n    assert!(params.contains(\u0026\"-preset\".to_string()));\n    assert!(params.contains(\u0026\"p4\".to_string()));\n  }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":22}},{"line":107,"address":[],"length":0,"stats":{"Line":12}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":20}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":10}},{"line":121,"address":[],"length":0,"stats":{"Line":20}},{"line":124,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":358,"address":[],"length":0,"stats":{"Line":3}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":1}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":2}},{"line":454,"address":[],"length":0,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":2}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":458,"address":[],"length":0,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":2}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":3}},{"line":483,"address":[],"length":0,"stats":{"Line":3}},{"line":487,"address":[],"length":0,"stats":{"Line":1}},{"line":489,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}}],"covered":77,"coverable":188},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","mod.rs"],"content":"//! Video Compiler Module - Центральный модуль компиляции видео\n//!\n//! Этот модуль отвечает за компиляцию проектов Timeline Studio в финальное видео\n//! с использованием FFmpeg. Включает в себя:\n//! - Схему данных проекта (ProjectSchema)\n//! - Рендерер видео (VideoRenderer)\n//! - Генератор превью (PreviewGenerator)\n//! - Отслеживание прогресса (ProgressTracker)\n\npub mod cache;\npub mod commands;\npub mod error;\npub mod ffmpeg_builder;\npub mod frame_extraction;\npub mod gpu;\npub mod pipeline;\npub mod preview;\npub mod progress;\npub mod renderer;\npub mod schema;\n\n#[cfg(test)]\nmod test_integration;\n\n// Re-export основных типов для удобства использования\npub use commands::VideoCompilerState;\npub use error::{Result, VideoCompilerError};\npub use preview::PreviewGenerator;\npub use progress::RenderProgress;\n\nuse serde::{Deserialize, Serialize};\n\n/// Настройки компилятора видео\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CompilerSettings {\n  /// Максимальное количество одновременных задач рендеринга\n  pub max_concurrent_jobs: usize,\n  /// Размер кэша в мегабайтах\n  pub cache_size_mb: usize,\n  /// Временная директория для промежуточных файлов\n  pub temp_directory: std::path::PathBuf,\n  /// Путь к FFmpeg (если не в системном PATH)\n  pub ffmpeg_path: Option\u003cstd::path::PathBuf\u003e,\n  /// Использование аппаратного ускорения\n  pub hardware_acceleration: bool,\n  /// Качество превью (от 1 до 100)\n  pub preview_quality: u8,\n}\n\nimpl Default for CompilerSettings {\n  fn default() -\u003e Self {\n    Self {\n      max_concurrent_jobs: 2,\n      cache_size_mb: 512,\n      temp_directory: std::env::temp_dir().join(\"timeline-studio\"),\n      ffmpeg_path: None,\n      hardware_acceleration: true,\n      preview_quality: 75,\n    }\n  }\n}\n\n/// События Video Compiler для WebSocket\n#[derive(Serialize, Debug, Clone)]\n#[serde(tag = \"type\")]\npub enum VideoCompilerEvent {\n  /// Рендеринг начат\n  RenderStarted { job_id: String },\n  /// Прогресс рендеринга обновлен\n  RenderProgress {\n    job_id: String,\n    progress: RenderProgress,\n  },\n  /// Рендеринг завершен успешно\n  RenderCompleted { job_id: String, output_path: String },\n  /// Рендеринг завершился с ошибкой\n  RenderFailed { job_id: String, error: String },\n  /// Превью сгенерировано\n  PreviewGenerated { timestamp: f64, image_data: Vec\u003cu8\u003e },\n  /// Кэш обновлен\n  CacheUpdated { cache_size_mb: f64 },\n}\n\n/// Проверка зависимостей Video Compiler и возврат пути к FFmpeg\npub async fn check_dependencies() -\u003e Result\u003cString\u003e {\n  // Список возможных путей к FFmpeg в разных системах\n  let ffmpeg_paths = vec![\n    \"ffmpeg\",                                     // По умолчанию в PATH\n    \"/usr/bin/ffmpeg\",                            // Linux стандартный путь\n    \"/usr/local/bin/ffmpeg\",                      // macOS через brew (Intel)\n    \"/opt/homebrew/bin/ffmpeg\",                   // macOS через brew (Apple Silicon)\n    \"/snap/bin/ffmpeg\",                           // Linux через snap\n    \"C:\\\\Program Files\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\", // Windows стандартный путь\n    \"C:\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\",                // Windows альтернативный путь\n  ];\n\n  // Пробуем найти FFmpeg\n  for path in \u0026ffmpeg_paths {\n    log::debug!(\"Проверка FFmpeg по пути: {}\", path);\n\n    let output = tokio::process::Command::new(path)\n      .arg(\"-version\")\n      .output()\n      .await;\n\n    if let Ok(output) = output {\n      if output.status.success() {\n        log::info!(\"FFmpeg найден по пути: {}\", path);\n\n        // Извлекаем версию FFmpeg\n        if let Ok(version_str) = String::from_utf8(output.stdout) {\n          if let Some(version_line) = version_str.lines().next() {\n            log::info!(\"Версия FFmpeg: {}\", version_line);\n          }\n        }\n\n        return Ok(path.to_string());\n      }\n    }\n  }\n\n  // Если не нашли FFmpeg, пробуем which/where команду\n  let which_cmd = if cfg!(target_os = \"windows\") {\n    \"where\"\n  } else {\n    \"which\"\n  };\n\n  if let Ok(output) = tokio::process::Command::new(which_cmd)\n    .arg(\"ffmpeg\")\n    .output()\n    .await\n  {\n    if output.status.success() {\n      if let Ok(path_str) = String::from_utf8(output.stdout) {\n        let path = path_str.trim().to_string();\n        log::info!(\"FFmpeg найден через {}: {}\", which_cmd, path);\n        return Ok(path);\n      }\n    }\n  }\n\n  Err(VideoCompilerError::DependencyMissing(\n    \"FFmpeg не найден в системе. Установите FFmpeg для работы Video Compiler.\\n\\\n     Инструкции по установке:\\n\\\n     - macOS: brew install ffmpeg\\n\\\n     - Ubuntu/Debian: sudo apt install ffmpeg\\n\\\n     - Windows: скачайте с https://ffmpeg.org/download.html\"\n      .to_string(),\n  ))\n}\n\n/// Инициализация Video Compiler модуля\npub async fn initialize() -\u003e Result\u003cVideoCompilerState\u003e {\n  log::info!(\"Инициализация Video Compiler модуля\");\n\n  // Проверяем зависимости и получаем путь к FFmpeg\n  let ffmpeg_path = check_dependencies().await?;\n\n  // Создаем состояние с найденным путем FFmpeg\n  let mut state = VideoCompilerState::new();\n  state.ffmpeg_path = ffmpeg_path;\n\n  // Обновляем настройки\n  {\n    let settings = state.settings.write().await;\n\n    // Создаем временную директорию если не существует\n    if !settings.temp_directory.exists() {\n      tokio::fs::create_dir_all(\u0026settings.temp_directory.clone())\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n  }\n\n  log::info!(\n    \"Video Compiler модуль успешно инициализирован с FFmpeg: {}\",\n    \u0026state.ffmpeg_path\n  );\n  Ok(state)\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[tokio::test]\n  async fn test_video_compiler_state_creation() {\n    let state = VideoCompilerState::new();\n    assert_eq!(state.active_jobs.read().await.len(), 0);\n\n    let settings = state.settings.read().await;\n    assert_eq!(settings.max_concurrent_jobs, 2);\n    assert_eq!(settings.cache_size_mb, 512);\n  }\n\n  #[tokio::test]\n  async fn test_compiler_settings_default() {\n    let settings = CompilerSettings::default();\n    assert_eq!(settings.max_concurrent_jobs, 2);\n    assert_eq!(settings.cache_size_mb, 512);\n    assert!(settings.hardware_acceleration);\n    assert_eq!(settings.preview_quality, 75);\n  }\n\n  #[tokio::test]\n  async fn test_check_dependencies() {\n    // Тест может не пройти если FFmpeg не установлен, но это ожидаемо\n    match check_dependencies().await {\n      Ok(_) =\u003e println!(\"FFmpeg найден и работает\"),\n      Err(e) =\u003e println!(\"FFmpeg недоступен: {:?}\", e),\n    }\n  }\n\n  #[test]\n  fn test_video_compiler_event_serialization() {\n    let event = VideoCompilerEvent::RenderStarted {\n      job_id: \"test-123\".to_string(),\n    };\n\n    let json = serde_json::to_string(\u0026event).unwrap();\n    assert!(json.contains(\"RenderStarted\"));\n    assert!(json.contains(\"test-123\"));\n  }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":32}},{"line":55,"address":[],"length":0,"stats":{"Line":32}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}}],"covered":18,"coverable":35},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","pipeline.rs"],"content":"//! Pipeline - Модуль конвейера обработки видео\n//!\n//! Этот модуль реализует конвейер обработки видео проектов,\n//! включая этапы валидации, предобработки, композиции и кодирования.\n\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::sync::RwLock;\n\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::progress::ProgressTracker;\nuse crate::video_compiler::schema::ProjectSchema;\nuse crate::video_compiler::CompilerSettings;\n\n/// Основной конвейер обработки видео\n#[derive(Debug)]\npub struct RenderPipeline {\n  /// Схема проекта\n  project: ProjectSchema,\n  /// Этапы конвейера\n  stages: Vec\u003cBox\u003cdyn PipelineStage\u003e\u003e,\n  /// Трекер прогресса\n  progress_tracker: Arc\u003cProgressTracker\u003e,\n  /// Настройки\n  settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n  /// Контекст выполнения\n  context: PipelineContext,\n}\n\nimpl RenderPipeline {\n  /// Создать новый конвейер\n  pub async fn new(\n    project: ProjectSchema,\n    progress_tracker: Arc\u003cProgressTracker\u003e,\n    settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n    output_path: PathBuf,\n  ) -\u003e Result\u003cSelf\u003e {\n    let context = PipelineContext::new(project.clone(), output_path);\n\n    let mut pipeline = Self {\n      project,\n      stages: Vec::new(),\n      progress_tracker,\n      settings,\n      context,\n    };\n\n    // Добавляем стандартные этапы\n    pipeline.add_default_stages().await?;\n\n    Ok(pipeline)\n  }\n\n  /// Добавить стандартные этапы конвейера\n  async fn add_default_stages(\u0026mut self) -\u003e Result\u003c()\u003e {\n    self.add_stage(Box::new(ValidationStage::new()));\n    self.add_stage(Box::new(PreprocessingStage::new()));\n    self.add_stage(Box::new(CompositionStage::new()));\n    self.add_stage(Box::new(EncodingStage::new()));\n    self.add_stage(Box::new(FinalizationStage::new()));\n    Ok(())\n  }\n\n  /// Добавить этап в конвейер\n  pub fn add_stage(\u0026mut self, stage: Box\u003cdyn PipelineStage\u003e) {\n    self.stages.push(stage);\n  }\n\n  /// Выполнить весь конвейер\n  pub async fn execute(\u0026mut self, job_id: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n    log::info!(\"=== Запуск конвейера обработки ===\");\n    log::info!(\"ID задачи: {}\", job_id);\n    log::info!(\"Проект: {}\", self.project.metadata.name);\n    log::info!(\"Выходной файл: {:?}\", self.context.output_path);\n    log::info!(\"Временная директория: {:?}\", self.context.temp_dir);\n    log::info!(\"Количество этапов: {}\", self.stages.len());\n\n    // Создаем временную директорию\n    self.context.ensure_temp_dir().await?;\n\n    let total_stages = self.stages.len();\n    let mut current_stage = 0;\n\n    for stage in \u0026self.stages {\n      current_stage += 1;\n      let stage_name = stage.name();\n\n      log::info!(\n        \"[{}/{}] Начало этапа: {}\",\n        current_stage,\n        total_stages,\n        stage_name\n      );\n\n      // Проверяем отмену\n      if self.context.is_cancelled() {\n        log::warn!(\"Конвейер отменен пользователем\");\n        return Err(VideoCompilerError::render(\n          job_id,\n          stage_name,\n          \"Операция отменена пользователем\".to_string(),\n        ));\n      }\n\n      // Обновляем прогресс\n      let progress_percentage = ((current_stage - 1) as f64 / total_stages as f64) * 100.0;\n      if let Err(e) = self\n        .update_progress(job_id, progress_percentage as u64, stage_name)\n        .await\n      {\n        log::warn!(\"Не удалось обновить прогресс: {}\", e);\n        // Продолжаем выполнение\n      }\n\n      // Выполняем этап\n      let start_time = SystemTime::now();\n\n      match stage.process(\u0026mut self.context).await {\n        Ok(_) =\u003e {\n          let duration = start_time.elapsed().unwrap_or(Duration::ZERO);\n          log::info!(\n            \"✓ Этап '{}' завершен за {:.2}с\",\n            stage_name,\n            duration.as_secs_f64()\n          );\n\n          // Обновляем статистику\n          // Для отслеживания прогресса используем frames_processed\n          self.context.statistics.frames_processed += 1;\n        }\n        Err(e) =\u003e {\n          log::error!(\"✗ Ошибка на этапе '{}': {}\", stage_name, e);\n          log::error!(\"  Код ошибки: {}\", e.error_code());\n          log::error!(\n            \"  Критическая: {}\",\n            if e.is_critical() { \"да\" } else { \"нет\" }\n          );\n          log::error!(\n            \"  Можно повторить: {}\",\n            if e.is_retryable() { \"да\" } else { \"нет\" }\n          );\n          log::debug!(\"Детали ошибки: {:?}\", e);\n\n          // Очищаем временные файлы при ошибке\n          if let Err(cleanup_err) = self.context.cleanup().await {\n            log::warn!(\"Не удалось очистить временные файлы: {}\", cleanup_err);\n          }\n\n          return Err(VideoCompilerError::render(\n            job_id,\n            stage_name,\n            e.to_string(),\n          ));\n        }\n      }\n    }\n\n    // Финальное обновление прогресса\n    self.update_progress(job_id, 100, \"Completed\").await?;\n\n    // Очищаем временные файлы\n    if let Err(e) = self.context.cleanup().await {\n      log::warn!(\"Не удалось очистить временные файлы: {}\", e);\n    }\n\n    log::info!(\"=== Конвейер обработки завершен успешно ===\");\n    log::info!(\"Выходной файл: {:?}\", self.context.output_path);\n    log::info!(\n      \"Общее время: {:.2}с\",\n      self.context.statistics.total_duration().as_secs_f64()\n    );\n\n    Ok(self.context.output_path.clone())\n  }\n\n  /// Обновить прогресс выполнения\n  async fn update_progress(\u0026self, job_id: \u0026str, percentage: u64, stage: \u0026str) -\u003e Result\u003c()\u003e {\n    let total_frames = (self.project.get_duration() * self.project.timeline.fps as f64) as u64;\n    let current_frame = (total_frames * percentage) / 100;\n\n    self\n      .progress_tracker\n      .update_progress(job_id, current_frame, stage.to_string(), None)\n      .await\n  }\n\n  /// Отменить выполнение конвейера\n  pub async fn cancel(\u0026mut self) -\u003e Result\u003c()\u003e {\n    self.context.cancelled = true;\n    log::info!(\"Конвейер отменен\");\n    Ok(())\n  }\n\n  /// Получить статистику выполнения\n  pub fn get_statistics(\u0026self) -\u003e PipelineStatistics {\n    self.context.statistics.clone()\n  }\n}\n\n/// Контекст выполнения конвейера\n#[derive(Debug)]\npub struct PipelineContext {\n  /// Схема проекта\n  pub project: ProjectSchema,\n  /// Путь к выходному файлу\n  pub output_path: PathBuf,\n  /// Временная директория\n  pub temp_dir: PathBuf,\n  /// Промежуточные файлы\n  pub intermediate_files: HashMap\u003cString, PathBuf\u003e,\n  /// Флаг отмены\n  pub cancelled: bool,\n  /// Пользовательские данные\n  pub user_data: HashMap\u003cString, serde_json::Value\u003e,\n  /// Статистика выполнения\n  pub statistics: PipelineStatistics,\n}\n\nimpl PipelineContext {\n  /// Создать новый контекст\n  pub fn new(project: ProjectSchema, output_path: PathBuf) -\u003e Self {\n    let temp_dir = std::env::temp_dir()\n      .join(\"timeline-studio\")\n      .join(\"pipeline\")\n      .join(uuid::Uuid::new_v4().to_string());\n\n    Self {\n      project,\n      output_path,\n      temp_dir,\n      intermediate_files: HashMap::new(),\n      cancelled: false,\n      user_data: HashMap::new(),\n      statistics: PipelineStatistics::default(),\n    }\n  }\n\n  /// Добавить промежуточный файл\n  pub fn add_intermediate_file(\u0026mut self, key: String, path: PathBuf) {\n    self.intermediate_files.insert(key, path);\n  }\n\n  /// Получить промежуточный файл\n  pub fn get_intermediate_file(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026PathBuf\u003e {\n    self.intermediate_files.get(key)\n  }\n\n  /// Проверить, отменено ли выполнение\n  pub fn is_cancelled(\u0026self) -\u003e bool {\n    self.cancelled\n  }\n\n  /// Создать временную директорию\n  pub async fn ensure_temp_dir(\u0026self) -\u003e Result\u003c()\u003e {\n    if !self.temp_dir.exists() {\n      tokio::fs::create_dir_all(\u0026self.temp_dir)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n    Ok(())\n  }\n\n  /// Очистить временные файлы\n  pub async fn cleanup(\u0026self) -\u003e Result\u003c()\u003e {\n    if self.temp_dir.exists() {\n      tokio::fs::remove_dir_all(\u0026self.temp_dir)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n    Ok(())\n  }\n}\n\n/// Трейт для этапа конвейера\n#[async_trait]\npub trait PipelineStage: Send + Sync + std::fmt::Debug {\n  /// Выполнить этап\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e;\n\n  /// Получить название этапа\n  fn name(\u0026self) -\u003e \u0026str;\n\n  /// Получить оценочную длительность этапа\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(10)\n  }\n\n  /// Проверить, можно ли пропустить этап\n  fn can_skip(\u0026self, _context: \u0026PipelineContext) -\u003e bool {\n    false\n  }\n}\n\n/// Этап валидации проекта\n#[derive(Debug)]\npub struct ValidationStage;\n\nimpl ValidationStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for ValidationStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало валидации проекта\");\n\n    // Валидация схемы проекта\n    context\n      .project\n      .validate()\n      .map_err(VideoCompilerError::validation)?;\n\n    // Проверка существования медиа файлов и их форматов\n    for track in \u0026context.project.tracks {\n      for clip in \u0026track.clips {\n        // Проверка существования\n        if !clip.source_path.exists() {\n          return Err(VideoCompilerError::media_file(\n            clip.source_path.to_string_lossy(),\n            \"Файл не найден\",\n          ));\n        }\n\n        // Проверка поддерживаемых форматов\n        let extension = clip\n          .source_path\n          .extension()\n          .and_then(|ext| ext.to_str())\n          .unwrap_or(\"\");\n\n        let supported_formats = match track.track_type {\n          crate::video_compiler::schema::TrackType::Video =\u003e {\n            vec![\n              \"mp4\", \"mov\", \"avi\", \"mkv\", \"webm\", \"flv\", \"m4v\", \"jpg\", \"jpeg\", \"png\", \"gif\", \"bmp\",\n              \"webp\",\n            ]\n          }\n          crate::video_compiler::schema::TrackType::Audio =\u003e {\n            vec![\"mp3\", \"wav\", \"aac\", \"m4a\", \"flac\", \"ogg\", \"wma\"]\n          }\n          crate::video_compiler::schema::TrackType::Subtitle =\u003e {\n            vec![\"srt\", \"vtt\", \"ass\", \"ssa\"]\n          }\n        };\n\n        if !supported_formats.contains(\u0026extension.to_lowercase().as_str()) {\n          return Err(VideoCompilerError::media_file(\n            clip.source_path.to_string_lossy(),\n            format!(\"Неподдерживаемый формат файла: .{}\", extension),\n          ));\n        }\n\n        // Проверка временных интервалов\n        if clip.start_time \u003c 0.0 {\n          return Err(VideoCompilerError::validation(format!(\n            \"Некорректное время начала клипа: {}\",\n            clip.start_time\n          )));\n        }\n\n        let duration = clip.end_time - clip.start_time;\n        if duration \u003c= 0.0 {\n          return Err(VideoCompilerError::validation(format!(\n            \"Некорректная длительность клипа: {}\",\n            duration\n          )));\n        }\n      }\n    }\n\n    // Создание временной директории\n    context.ensure_temp_dir().await?;\n\n    context.statistics.validation_time = SystemTime::now();\n    log::info!(\"Валидация проекта завершена успешно\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Validation\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(5)\n  }\n}\n\n/// Этап предобработки медиа\n#[derive(Debug)]\npub struct PreprocessingStage;\n\nimpl PreprocessingStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for PreprocessingStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало предобработки медиа\");\n\n    // Анализ медиа файлов\n    for track in \u0026context.project.tracks {\n      for clip in \u0026track.clips {\n        self.analyze_media_file(\u0026clip.source_path).await?;\n      }\n    }\n\n    // Подготовка промежуточных файлов\n    self.prepare_intermediate_files(context).await?;\n\n    context.statistics.preprocessing_time = SystemTime::now();\n    log::info!(\"Предобработка медиа завершена\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Preprocessing\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(30)\n  }\n}\n\nimpl PreprocessingStage {\n  /// Анализ медиа файла через FFprobe\n  async fn analyze_media_file(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    // Проверяем доступность файла\n    if !path.exists() {\n      return Err(VideoCompilerError::media_file(\n        path.to_string_lossy().to_string(),\n        \"Файл не существует\".to_string(),\n      ));\n    }\n\n    // Запускаем FFprobe для анализа\n    let output = Command::new(\"ffprobe\")\n      .args([\n        \"-v\",\n        \"error\",\n        \"-select_streams\",\n        \"v:0\",\n        \"-show_entries\",\n        \"stream=codec_name,width,height,r_frame_rate,duration\",\n        \"-of\",\n        \"json\",\n        path.to_str().unwrap(),\n      ])\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFprobe: {}\", e),\n          \"ffprobe\".to_string(),\n        )\n      })?;\n\n    if !output.status.success() {\n      let error = String::from_utf8_lossy(\u0026output.stderr);\n      return Err(VideoCompilerError::media_file(\n        path.to_string_lossy(),\n        format!(\"FFprobe ошибка: {}\", error),\n      ));\n    }\n\n    // Парсим JSON результат\n    let json_str = String::from_utf8_lossy(\u0026output.stdout);\n    let probe_data: serde_json::Value = serde_json::from_str(\u0026json_str).map_err(|e| {\n      VideoCompilerError::media_file(\n        path.to_string_lossy(),\n        format!(\"Ошибка парсинга FFprobe данных: {}\", e),\n      )\n    })?;\n\n    // Логируем информацию о файле\n    if let Some(streams) = probe_data[\"streams\"].as_array() {\n      if let Some(stream) = streams.first() {\n        log::info!(\n          \"Медиа файл {}: {}x{}, codec: {}, fps: {}\",\n          path.display(),\n          stream[\"width\"].as_u64().unwrap_or(0),\n          stream[\"height\"].as_u64().unwrap_or(0),\n          stream[\"codec_name\"].as_str().unwrap_or(\"unknown\"),\n          stream[\"r_frame_rate\"].as_str().unwrap_or(\"unknown\")\n        );\n      }\n    }\n\n    // Здесь можно добавить дополнительную логику анализа\n    log::debug!(\"Анализ файла: {:?}\", path);\n    Ok(())\n  }\n\n  /// Подготовка промежуточных файлов\n  async fn prepare_intermediate_files(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::debug!(\"Подготовка промежуточных файлов\");\n\n    // Собираем информацию о необходимых преобразованиях\n    let mut conversions = Vec::new();\n\n    for (track_idx, track) in context.project.tracks.iter().enumerate() {\n      for (clip_idx, clip) in track.clips.iter().enumerate() {\n        // Проверяем нужно ли конвертировать файл\n        let needs_conversion = self.check_needs_conversion(\u0026clip.source_path).await?;\n\n        if needs_conversion {\n          conversions.push((track_idx, clip_idx, clip.source_path.clone()));\n        }\n      }\n    }\n\n    // Теперь добавляем промежуточные файлы\n    for (track_idx, clip_idx, source_path) in conversions {\n      // Создаем путь для временного файла\n      let temp_file = context\n        .temp_dir\n        .join(format!(\"track_{}_clip_{}_temp.mp4\", track_idx, clip_idx));\n\n      // Сохраняем информацию о временном файле\n      let key = format!(\"track_{}_clip_{}\", track_idx, clip_idx);\n      context.add_intermediate_file(key, temp_file);\n\n      log::info!(\"Клип {} требует преобразования\", source_path.display());\n    }\n\n    // Создаем основные промежуточные файлы для композиции\n    let video_composite = context.temp_dir.join(\"video_composite.mp4\");\n    let audio_composite = context.temp_dir.join(\"audio_composite.wav\");\n\n    context.add_intermediate_file(\"video_composite\".to_string(), video_composite);\n    context.add_intermediate_file(\"audio_composite\".to_string(), audio_composite);\n\n    Ok(())\n  }\n\n  /// Проверка необходимости конвертации\n  async fn check_needs_conversion(\u0026self, path: \u0026Path) -\u003e Result\u003cbool\u003e {\n    // Простая проверка по расширению\n    // В реальности здесь должна быть проверка кодеков через FFprobe\n    let extension = path.extension().and_then(|ext| ext.to_str()).unwrap_or(\"\");\n\n    // Форматы, которые требуют конвертации\n    let needs_conversion_formats = [\"avi\", \"flv\", \"wmv\", \"mkv\"];\n\n    Ok(needs_conversion_formats.contains(\u0026extension.to_lowercase().as_str()))\n  }\n}\n\n/// Этап композиции видео\n#[derive(Debug)]\npub struct CompositionStage;\n\nimpl CompositionStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for CompositionStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало композиции видео\");\n\n    // Проверка отмены\n    if context.is_cancelled() {\n      return Err(VideoCompilerError::CancelledError(\n        \"Композиция отменена\".to_string(),\n      ));\n    }\n\n    // Композиция видео дорожек\n    self.compose_video_tracks(context).await?;\n\n    // Композиция аудио дорожек\n    self.compose_audio_tracks(context).await?;\n\n    context.statistics.composition_time = SystemTime::now();\n    log::info!(\"Композиция видео завершена\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Composition\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(120)\n  }\n}\n\nimpl CompositionStage {\n  /// Композиция видео дорожек\n  async fn compose_video_tracks(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    let video_tracks: Vec\u003c_\u003e = context\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.track_type == crate::video_compiler::schema::TrackType::Video)\n      .collect();\n\n    if video_tracks.is_empty() {\n      return Err(VideoCompilerError::validation(\n        \"Нет видео дорожек для композиции\",\n      ));\n    }\n\n    log::debug!(\"Композиция {} видео дорожек\", video_tracks.len());\n\n    // Строим команду FFmpeg для композиции видео\n    let ffmpeg_command = self.build_video_composition_command(context, \u0026video_tracks)?;\n\n    // Выполняем команду FFmpeg\n    log::info!(\"Запуск композиции видео\");\n    let output = Command::new(\u0026ffmpeg_command[0])\n      .args(\u0026ffmpeg_command[1..])\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFmpeg для видео композиции: {}\", e),\n          \"video composition\".to_string(),\n        )\n      })?;\n\n    if !output.status.success() {\n      let error = String::from_utf8_lossy(\u0026output.stderr);\n      return Err(VideoCompilerError::ffmpeg(\n        output.status.code(),\n        format!(\"FFmpeg видео композиция не удалась: {}\", error),\n        \"video composition\".to_string(),\n      ));\n    }\n\n    log::info!(\"Видео композиция завершена успешно\");\n    Ok(())\n  }\n\n  /// Построение команды FFmpeg для композиции видео\n  fn build_video_composition_command(\n    \u0026self,\n    context: \u0026PipelineContext,\n    video_tracks: \u0026[\u0026crate::video_compiler::schema::Track],\n  ) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut command = vec![\"ffmpeg\".to_string()];\n\n    // Добавляем входные файлы\n    let mut input_count = 0;\n    for track in video_tracks {\n      for clip in \u0026track.clips {\n        command.extend([\n          \"-i\".to_string(),\n          clip.source_path.to_string_lossy().to_string(),\n        ]);\n        input_count += 1;\n      }\n    }\n\n    // Если только один клип - простое копирование\n    if input_count == 1 {\n      command.extend([\n        \"-c:v\".to_string(),\n        \"copy\".to_string(),\n        \"-an\".to_string(), // Без аудио на этом этапе\n      ]);\n    } else {\n      // Сложная композиция с filter_complex\n      let mut filter_complex = String::new();\n\n      // Простой пример конкатенации\n      for i in 0..input_count {\n        filter_complex.push_str(\u0026format!(\"[{}:v]\", i));\n      }\n      filter_complex.push_str(\u0026format!(\"concat=n={}:v=1:a=0[outv]\", input_count));\n\n      command.extend([\n        \"-filter_complex\".to_string(),\n        filter_complex,\n        \"-map\".to_string(),\n        \"[outv]\".to_string(),\n      ]);\n    }\n\n    // Выходной файл\n    if let Some(video_composite) = context.intermediate_files.get(\"video_composite\") {\n      command.push(video_composite.to_string_lossy().to_string());\n    }\n\n    log::debug!(\"FFmpeg команда для видео: {:?}\", command);\n    Ok(command)\n  }\n\n  /// Композиция аудио дорожек\n  async fn compose_audio_tracks(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    let audio_tracks: Vec\u003c_\u003e = context\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.track_type == crate::video_compiler::schema::TrackType::Audio)\n      .collect();\n\n    if audio_tracks.is_empty() {\n      log::info!(\"Нет аудио дорожек для композиции\");\n      return Ok(());\n    }\n\n    log::debug!(\"Композиция {} аудио дорожек\", audio_tracks.len());\n\n    // Строим команду FFmpeg для композиции аудио\n    let ffmpeg_command = self.build_audio_composition_command(context, \u0026audio_tracks)?;\n\n    // Выполняем команду FFmpeg\n    log::info!(\"Запуск композиции аудио\");\n    let output = Command::new(\u0026ffmpeg_command[0])\n      .args(\u0026ffmpeg_command[1..])\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFmpeg для аудио композиции: {}\", e),\n          \"audio composition\".to_string(),\n        )\n      })?;\n\n    if !output.status.success() {\n      let error = String::from_utf8_lossy(\u0026output.stderr);\n      return Err(VideoCompilerError::ffmpeg(\n        output.status.code(),\n        format!(\"FFmpeg аудио композиция не удалась: {}\", error),\n        \"audio composition\".to_string(),\n      ));\n    }\n\n    log::info!(\"Аудио композиция завершена успешно\");\n    Ok(())\n  }\n\n  /// Построение команды FFmpeg для композиции аудио\n  fn build_audio_composition_command(\n    \u0026self,\n    context: \u0026PipelineContext,\n    audio_tracks: \u0026[\u0026crate::video_compiler::schema::Track],\n  ) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut command = vec![\"ffmpeg\".to_string()];\n\n    // Добавляем входные файлы\n    let mut input_count = 0;\n    for track in audio_tracks {\n      for clip in \u0026track.clips {\n        command.extend([\n          \"-i\".to_string(),\n          clip.source_path.to_string_lossy().to_string(),\n        ]);\n        input_count += 1;\n      }\n    }\n\n    // Если только один аудио клип - простое копирование\n    if input_count == 1 {\n      command.extend([\n        \"-c:a\".to_string(),\n        \"copy\".to_string(),\n        \"-vn\".to_string(), // Без видео на этом этапе\n      ]);\n    } else {\n      // Сложное микширование с amerge или amix\n      let mut filter_complex = String::new();\n\n      // Используем amix для микширования нескольких аудио потоков\n      for i in 0..input_count {\n        filter_complex.push_str(\u0026format!(\"[{}:a]\", i));\n      }\n      filter_complex.push_str(\u0026format!(\n        \"amix=inputs={}:duration=longest:dropout_transition=2[outa]\",\n        input_count\n      ));\n\n      command.extend([\n        \"-filter_complex\".to_string(),\n        filter_complex,\n        \"-map\".to_string(),\n        \"[outa]\".to_string(),\n      ]);\n    }\n\n    // Выходной файл\n    if let Some(audio_composite) = context.intermediate_files.get(\"audio_composite\") {\n      command.push(audio_composite.to_string_lossy().to_string());\n    }\n\n    log::debug!(\"FFmpeg команда для аудио: {:?}\", command);\n    Ok(command)\n  }\n}\n\n/// Этап кодирования\n#[derive(Debug)]\npub struct EncodingStage;\n\nimpl EncodingStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for EncodingStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало кодирования видео\");\n\n    // Проверка отмены\n    if context.is_cancelled() {\n      return Err(VideoCompilerError::CancelledError(\n        \"Кодирование отменено\".to_string(),\n      ));\n    }\n\n    // Кодирование финального видео\n    self.encode_final_video(context).await?;\n\n    context.statistics.encoding_time = SystemTime::now();\n    log::info!(\"Кодирование видео завершено\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Encoding\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(300)\n  }\n}\n\nimpl EncodingStage {\n  /// Кодирование финального видео\n  async fn encode_final_video(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::io::{AsyncBufReadExt, BufReader};\n    use tokio::process::Command;\n\n    log::info!(\"Начало кодирования в файл: {:?}\", context.output_path);\n\n    // Создаем родительскую директорию если не существует\n    if let Some(parent) = context.output_path.parent() {\n      tokio::fs::create_dir_all(parent)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n\n    // Получаем промежуточные файлы\n    let video_composite = context\n      .get_intermediate_file(\"video_composite\")\n      .ok_or_else(|| {\n        VideoCompilerError::render(\n          \"encoding\",\n          \"missing_video\",\n          \"Промежуточный видео файл не найден\",\n        )\n      })?;\n\n    let audio_composite = context.get_intermediate_file(\"audio_composite\");\n\n    // Строим финальную команду FFmpeg\n    let mut command = vec![\"ffmpeg\".to_string(), \"-y\".to_string()]; // -y для перезаписи\n\n    // Добавляем видео вход\n    command.extend([\n      \"-i\".to_string(),\n      video_composite.to_string_lossy().to_string(),\n    ]);\n\n    // Добавляем аудио вход если есть\n    if let Some(audio_path) = audio_composite {\n      command.extend([\"-i\".to_string(), audio_path.to_string_lossy().to_string()]);\n      // Маппинг видео и аудио\n      command.extend([\n        \"-map\".to_string(),\n        \"0:v\".to_string(),\n        \"-map\".to_string(),\n        \"1:a\".to_string(),\n      ]);\n    } else {\n      // Только видео\n      command.extend([\"-map\".to_string(), \"0:v\".to_string()]);\n    }\n\n    // Кодеки и настройки качества\n    command.extend([\n      \"-c:v\".to_string(),\n      \"libx264\".to_string(),\n      \"-preset\".to_string(),\n      \"medium\".to_string(),\n      \"-crf\".to_string(),\n      \"23\".to_string(),\n      \"-c:a\".to_string(),\n      \"aac\".to_string(),\n      \"-b:a\".to_string(),\n      \"192k\".to_string(),\n      \"-movflags\".to_string(),\n      \"+faststart\".to_string(), // Для веб-воспроизведения\n    ]);\n\n    // Разрешение и FPS из timeline\n    let resolution = context.project.timeline.resolution;\n    command.extend([\n      \"-vf\".to_string(),\n      format!(\"scale={}:{}\", resolution.0, resolution.1),\n      \"-r\".to_string(),\n      context.project.timeline.fps.to_string(),\n    ]);\n\n    // Выходной файл\n    command.push(context.output_path.to_string_lossy().to_string());\n\n    log::debug!(\"Финальная FFmpeg команда: {:?}\", command);\n\n    // Запускаем FFmpeg процесс\n    let mut child = Command::new(\u0026command[0])\n      .args(\u0026command[1..])\n      .stderr(std::process::Stdio::piped())\n      .spawn()\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFmpeg: {}\", e),\n          \"ffmpeg spawn\".to_string(),\n        )\n      })?;\n\n    // Читаем stderr для прогресса\n    if let Some(stderr) = child.stderr.take() {\n      let reader = BufReader::new(stderr);\n      let mut lines = reader.lines();\n\n      while let Some(line) = lines.next_line().await.ok().flatten() {\n        // Парсим прогресс из вывода FFmpeg\n        if line.contains(\"frame=\") {\n          self.parse_ffmpeg_progress(\u0026line, context);\n        }\n        log::trace!(\"FFmpeg: {}\", line);\n\n        // Проверяем отмену\n        if context.is_cancelled() {\n          child.kill().await.ok();\n          return Err(VideoCompilerError::CancelledError(\n            \"Кодирование отменено пользователем\".to_string(),\n          ));\n        }\n      }\n    }\n\n    // Ждем завершения процесса\n    let status = child.wait().await.map_err(|e| {\n      VideoCompilerError::ffmpeg(\n        None,\n        format!(\"Ошибка ожидания FFmpeg: {}\", e),\n        \"ffmpeg wait\".to_string(),\n      )\n    })?;\n\n    if !status.success() {\n      return Err(VideoCompilerError::ffmpeg(\n        status.code(),\n        \"FFmpeg завершился с ошибкой\".to_string(),\n        \"ffmpeg encoding\".to_string(),\n      ));\n    }\n\n    // Проверяем что файл создан\n    if !context.output_path.exists() {\n      return Err(VideoCompilerError::render(\n        \"encoding\",\n        \"output_missing\",\n        \"Выходной файл не был создан\",\n      ));\n    }\n\n    log::info!(\"Кодирование завершено успешно\");\n    Ok(())\n  }\n\n  /// Парсинг прогресса из вывода FFmpeg\n  fn parse_ffmpeg_progress(\u0026self, line: \u0026str, context: \u0026mut PipelineContext) {\n    // Пример строки: frame= 2490 fps=100 q=29.0 size=    5376kB time=00:00:41.50 bitrate=1061.2kbits/s\n    if let Some(frame_match) = line.split(\"frame=\").nth(1) {\n      if let Some(frame_str) = frame_match.split_whitespace().next() {\n        if let Ok(frame) = frame_str.trim().parse::\u003cu64\u003e() {\n          context.statistics.frames_processed = frame;\n          log::trace!(\"Обработано кадров: {}\", frame);\n        }\n      }\n    }\n  }\n}\n\n/// Этап финализации\n#[derive(Debug)]\npub struct FinalizationStage;\n\nimpl FinalizationStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for FinalizationStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало финализации\");\n\n    // Проверка выходного файла\n    if !context.output_path.exists() {\n      return Err(VideoCompilerError::render(\n        \"finalization\",\n        \"file_check\",\n        \"Выходной файл не был создан\",\n      ));\n    }\n\n    // Получаем размер файла\n    let file_size = tokio::fs::metadata(\u0026context.output_path)\n      .await\n      .map(|m| m.len())\n      .unwrap_or(0);\n\n    log::info!(\n      \"Выходной файл создан: {:?}, размер: {} МБ\",\n      context.output_path,\n      file_size / 1_048_576\n    );\n\n    // Добавляем метаданные к файлу\n    self.add_metadata(context).await?;\n\n    // Сохраняем статистику\n    self.save_statistics(context).await?;\n\n    // Очистка временных файлов\n    if !context.is_cancelled() {\n      log::info!(\"Очистка временных файлов\");\n      context.cleanup().await?;\n    } else {\n      log::warn!(\"Пропуск очистки временных файлов из-за отмены\");\n    }\n\n    context.statistics.finalization_time = SystemTime::now();\n    log::info!(\"Финализация завершена успешно\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Finalization\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(5)\n  }\n}\n\nimpl FinalizationStage {\n  /// Добавление метаданных к выходному файлу\n  async fn add_metadata(\u0026self, context: \u0026PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    // Создаем временные строки для метаданных\n    let title_meta = format!(\"title={}\", context.project.metadata.name);\n    let artist_meta = \"artist=Timeline Studio\".to_string();\n    let date_meta = format!(\"date={}\", chrono::Utc::now().format(\"%Y-%m-%d\"));\n    let comment_meta = format!(\n      \"comment=Created with Timeline Studio v{}\",\n      context.project.version\n    );\n    let tmp_file = format!(\"{}.tmp\", context.output_path.to_string_lossy());\n\n    let metadata_args = vec![\n      \"-i\",\n      context.output_path.to_str().unwrap(),\n      \"-c\",\n      \"copy\",\n      \"-metadata\",\n      \u0026title_meta,\n      \"-metadata\",\n      \u0026artist_meta,\n      \"-metadata\",\n      \u0026date_meta,\n      \"-metadata\",\n      \u0026comment_meta,\n      \"-y\", // Перезаписать\n      \u0026tmp_file,\n    ];\n\n    let output = Command::new(\"ffmpeg\")\n      .args(\u0026metadata_args)\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось добавить метаданные: {}\", e),\n          \"add metadata\".to_string(),\n        )\n      })?;\n\n    if output.status.success() {\n      // Заменяем оригинальный файл\n      tokio::fs::rename(\u0026tmp_file, \u0026context.output_path)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(format!(\"Не удалось заменить файл: {}\", e)))?;\n\n      log::info!(\"Метаданные добавлены к выходному файлу\");\n    } else {\n      log::warn!(\"Не удалось добавить метаданные, но файл создан\");\n    }\n\n    Ok(())\n  }\n\n  /// Сохранение статистики рендеринга\n  async fn save_statistics(\u0026self, context: \u0026PipelineContext) -\u003e Result\u003c()\u003e {\n    let stats_path = context.output_path.with_extension(\"stats.json\");\n\n    let stats_json = serde_json::json!({\n      \"project_name\": context.project.metadata.name,\n      \"output_file\": context.output_path.to_string_lossy(),\n      \"total_duration\": context.statistics.total_duration().as_secs(),\n      \"frames_processed\": context.statistics.frames_processed,\n      \"memory_used\": context.statistics.memory_used,\n      \"error_count\": context.statistics.error_count,\n      \"warning_count\": context.statistics.warning_count,\n      \"render_date\": chrono::Utc::now().to_rfc3339(),\n      \"timeline_studio_version\": context.project.version,\n    });\n\n    let stats_string = serde_json::to_string_pretty(\u0026stats_json).map_err(|e| {\n      VideoCompilerError::IoError(format!(\"Не удалось сериализовать статистику: {}\", e))\n    })?;\n\n    tokio::fs::write(\u0026stats_path, stats_string)\n      .await\n      .map_err(|e| {\n        VideoCompilerError::IoError(format!(\"Не удалось сохранить статистику: {}\", e))\n      })?;\n\n    log::info!(\"Статистика рендеринга сохранена в {:?}\", stats_path);\n    Ok(())\n  }\n}\n\n/// Статистика выполнения конвейера\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineStatistics {\n  /// Время начала валидации\n  pub validation_time: SystemTime,\n  /// Время начала предобработки\n  pub preprocessing_time: SystemTime,\n  /// Время начала композиции\n  pub composition_time: SystemTime,\n  /// Время начала кодирования\n  pub encoding_time: SystemTime,\n  /// Время финализации\n  pub finalization_time: SystemTime,\n  /// Количество обработанных кадров\n  pub frames_processed: u64,\n  /// Использованная память (байты)\n  pub memory_used: u64,\n  /// Количество ошибок\n  pub error_count: u32,\n  /// Количество предупреждений\n  pub warning_count: u32,\n}\n\nimpl Default for PipelineStatistics {\n  fn default() -\u003e Self {\n    let now = SystemTime::now();\n    Self {\n      validation_time: now,\n      preprocessing_time: now,\n      composition_time: now,\n      encoding_time: now,\n      finalization_time: now,\n      frames_processed: 0,\n      memory_used: 0,\n      error_count: 0,\n      warning_count: 0,\n    }\n  }\n}\n\nimpl PipelineStatistics {\n  /// Получить общее время выполнения\n  pub fn total_duration(\u0026self) -\u003e Duration {\n    if let Ok(duration) = self.finalization_time.duration_since(self.validation_time) {\n      duration\n    } else {\n      Duration::ZERO\n    }\n  }\n\n  /// Добавить ошибку\n  pub fn add_error(\u0026mut self) {\n    self.error_count += 1;\n  }\n\n  /// Добавить предупреждение\n  pub fn add_warning(\u0026mut self) {\n    self.warning_count += 1;\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::progress::ProgressUpdate;\n  use crate::video_compiler::schema::ProjectSchema;\n  use tokio::sync::mpsc;\n\n  async fn create_test_pipeline() -\u003e RenderPipeline {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    let (tx, _rx) = mpsc::unbounded_channel::\u003cProgressUpdate\u003e();\n    let progress_tracker = Arc::new(ProgressTracker::new(tx));\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let output_path = PathBuf::from(\"/tmp/test_output.mp4\");\n\n    RenderPipeline::new(project, progress_tracker, settings, output_path)\n      .await\n      .unwrap()\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_creation() {\n    let pipeline = create_test_pipeline().await;\n    assert_eq!(pipeline.stages.len(), 5); // 5 стандартных этапов\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_context() {\n    let project = ProjectSchema::new(\"Test\".to_string());\n    let output_path = PathBuf::from(\"/tmp/test.mp4\");\n    let mut context = PipelineContext::new(project, output_path);\n\n    // Тест добавления промежуточного файла\n    let temp_file = PathBuf::from(\"/tmp/temp.mp4\");\n    context.add_intermediate_file(\"temp\".to_string(), temp_file.clone());\n\n    assert_eq!(context.get_intermediate_file(\"temp\"), Some(\u0026temp_file));\n    assert_eq!(context.get_intermediate_file(\"nonexistent\"), None);\n  }\n\n  #[tokio::test]\n  async fn test_validation_stage() {\n    let stage = ValidationStage::new();\n    assert_eq!(stage.name(), \"Validation\");\n    assert!(!stage.can_skip(\u0026PipelineContext::new(\n      ProjectSchema::new(\"Test\".to_string()),\n      PathBuf::from(\"/tmp/test.mp4\")\n    )));\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_statistics() {\n    let mut stats = PipelineStatistics::default();\n\n    assert_eq!(stats.error_count, 0);\n    assert_eq!(stats.warning_count, 0);\n\n    stats.add_error();\n    stats.add_warning();\n\n    assert_eq!(stats.error_count, 1);\n    assert_eq!(stats.warning_count, 1);\n  }\n\n  #[tokio::test]\n  async fn test_stage_estimated_duration() {\n    let validation_stage = ValidationStage::new();\n    let preprocessing_stage = PreprocessingStage::new();\n    let composition_stage = CompositionStage::new();\n    let encoding_stage = EncodingStage::new();\n    let finalization_stage = FinalizationStage::new();\n\n    assert_eq!(\n      validation_stage.estimated_duration(),\n      Duration::from_secs(5)\n    );\n    assert_eq!(\n      preprocessing_stage.estimated_duration(),\n      Duration::from_secs(30)\n    );\n    assert_eq!(\n      composition_stage.estimated_duration(),\n      Duration::from_secs(120)\n    );\n    assert_eq!(\n      encoding_stage.estimated_duration(),\n      Duration::from_secs(300)\n    );\n    assert_eq!(\n      finalization_stage.estimated_duration(),\n      Duration::from_secs(5)\n    );\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_cancel() {\n    let mut pipeline = create_test_pipeline().await;\n\n    let result = pipeline.cancel().await;\n    assert!(result.is_ok());\n    assert!(pipeline.context.is_cancelled());\n  }\n\n  #[tokio::test]\n  async fn test_context_temp_dir_creation() {\n    let project = ProjectSchema::new(\"Test\".to_string());\n    let output_path = PathBuf::from(\"/tmp/test.mp4\");\n    let context = PipelineContext::new(project, output_path);\n\n    // Проверяем, что временная директория содержит нужные компоненты\n    let temp_dir_str = context.temp_dir.to_string_lossy();\n    assert!(temp_dir_str.contains(\"timeline-studio\"));\n    assert!(temp_dir_str.contains(\"pipeline\"));\n  }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":3}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":238,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":244,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":294,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":5}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":4}},{"line":400,"address":[],"length":0,"stats":{"Line":4}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":424,"address":[],"length":0,"stats":{"Line":1}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":1}},{"line":510,"address":[],"length":0,"stats":{"Line":1}},{"line":512,"address":[],"length":0,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":1}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":1}},{"line":539,"address":[],"length":0,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":1}},{"line":542,"address":[],"length":0,"stats":{"Line":1}},{"line":544,"address":[],"length":0,"stats":{"Line":1}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":4}},{"line":566,"address":[],"length":0,"stats":{"Line":4}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":2}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":1}},{"line":594,"address":[],"length":0,"stats":{"Line":1}},{"line":597,"address":[],"length":0,"stats":{"Line":1}},{"line":598,"address":[],"length":0,"stats":{"Line":1}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":1}},{"line":608,"address":[],"length":0,"stats":{"Line":1}},{"line":609,"address":[],"length":0,"stats":{"Line":1}},{"line":611,"address":[],"length":0,"stats":{"Line":2}},{"line":614,"address":[],"length":0,"stats":{"Line":1}},{"line":615,"address":[],"length":0,"stats":{"Line":1}},{"line":616,"address":[],"length":0,"stats":{"Line":1}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":4}},{"line":818,"address":[],"length":0,"stats":{"Line":4}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":1}},{"line":847,"address":[],"length":0,"stats":{"Line":1}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":4}},{"line":1018,"address":[],"length":0,"stats":{"Line":4}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":1}},{"line":1072,"address":[],"length":0,"stats":{"Line":1}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":7}},{"line":1190,"address":[],"length":0,"stats":{"Line":7}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":1}},{"line":1217,"address":[],"length":0,"stats":{"Line":1}},{"line":1221,"address":[],"length":0,"stats":{"Line":1}},{"line":1222,"address":[],"length":0,"stats":{"Line":1}}],"covered":147,"coverable":458},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","preview","tests.rs"],"content":"//! Тесты для модуля генерации превью\n\nuse super::*;\nuse crate::video_compiler::cache::RenderCache;\nuse std::sync::Arc;\nuse std::time::SystemTime;\nuse tempfile::TempDir;\nuse tokio::sync::RwLock;\n\n// Создаем mock FFmpeg команду для тестов\nfn create_test_preview_generator() -\u003e PreviewGenerator {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    PreviewGenerator::new(cache)\n}\n\n#[test]\nfn test_preview_settings_default() {\n    let settings = PreviewSettings::default();\n    assert_eq!(settings.default_resolution, (640, 360));\n    assert_eq!(settings.default_quality, 75);\n    assert_eq!(settings.timeline_resolution, (160, 90));\n    assert_eq!(settings.timeline_quality, 60);\n    assert!(matches!(settings.format, PreviewFormat::Jpeg));\n    assert!(!settings.hardware_acceleration);\n    assert_eq!(settings.timeout_seconds, 30);\n    assert!(settings.supported_formats.contains(\u0026\"mp4\".to_string()));\n    assert!(settings.supported_formats.contains(\u0026\"mkv\".to_string()));\n}\n\n#[test]\nfn test_preview_settings_clone() {\n    let settings = PreviewSettings {\n        default_resolution: (1920, 1080),\n        default_quality: 90,\n        timeline_resolution: (320, 180),\n        timeline_quality: 70,\n        format: PreviewFormat::Png,\n        hardware_acceleration: true,\n        timeout_seconds: 60,\n        supported_formats: vec![\"mp4\".to_string(), \"avi\".to_string()],\n    };\n    \n    let cloned = settings.clone();\n    assert_eq!(cloned.default_resolution, settings.default_resolution);\n    assert_eq!(cloned.default_quality, settings.default_quality);\n    assert_eq!(cloned.hardware_acceleration, settings.hardware_acceleration);\n}\n\n#[test]\nfn test_preview_format_serialization() {\n    let formats = vec![\n        PreviewFormat::Jpeg,\n        PreviewFormat::Png,\n        PreviewFormat::WebP,\n    ];\n    \n    for format in formats {\n        let json = serde_json::to_string(\u0026format).unwrap();\n        let deserialized: PreviewFormat = serde_json::from_str(\u0026json).unwrap();\n        assert!(matches!(\n            (\u0026format, \u0026deserialized),\n            (PreviewFormat::Jpeg, PreviewFormat::Jpeg) |\n            (PreviewFormat::Png, PreviewFormat::Png) |\n            (PreviewFormat::WebP, PreviewFormat::WebP)\n        ));\n    }\n}\n\n#[test]\nfn test_video_info_serialization() {\n    let info = VideoInfo {\n        duration: 120.5,\n        resolution: Some((1920, 1080)),\n        fps: Some(30.0),\n        bitrate: Some(8000000),\n        video_codec: Some(\"h264\".to_string()),\n        audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let json = serde_json::to_string(\u0026info).unwrap();\n    assert!(json.contains(\"120.5\"));\n    assert!(json.contains(\"1920\"));\n    assert!(json.contains(\"h264\"));\n    \n    let deserialized: VideoInfo = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.duration, info.duration);\n    assert_eq!(deserialized.resolution, info.resolution);\n}\n\n#[test]\nfn test_preview_request_serialization() {\n    let request = PreviewRequest {\n        video_path: \"/test/video.mp4\".to_string(),\n        timestamp: 10.5,\n        resolution: Some((640, 360)),\n        quality: Some(80),\n    };\n    \n    let json = serde_json::to_string(\u0026request).unwrap();\n    assert!(json.contains(\"/test/video.mp4\"));\n    assert!(json.contains(\"10.5\"));\n    \n    let deserialized: PreviewRequest = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.video_path, request.video_path);\n    assert_eq!(deserialized.timestamp, request.timestamp);\n}\n\n#[test]\nfn test_preview_result_creation() {\n    let result = PreviewResult {\n        timestamp: 5.0,\n        result: Ok(vec![1, 2, 3, 4, 5]),\n    };\n    \n    assert_eq!(result.timestamp, 5.0);\n    assert!(result.result.is_ok());\n    assert_eq!(result.result.unwrap().len(), 5);\n}\n\n#[test]\nfn test_serializable_preview_result_serialization() {\n    let result = SerializablePreviewResult {\n        timestamp: 15.5,\n        image_data: Some(\"base64encodeddata\".to_string()),\n        error: None,\n    };\n    \n    let json = serde_json::to_string(\u0026result).unwrap();\n    assert!(json.contains(\"15.5\"));\n    assert!(json.contains(\"base64encodeddata\"));\n    \n    let deserialized: SerializablePreviewResult = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.timestamp, result.timestamp);\n    assert_eq!(deserialized.image_data, result.image_data);\n}\n\n#[test]\nfn test_timeline_preview_creation() {\n    let preview = TimelinePreview {\n        timestamp: 20.0,\n        image_data: Some(vec![10, 20, 30]),\n    };\n    \n    assert_eq!(preview.timestamp, 20.0);\n    assert!(preview.image_data.is_some());\n    assert_eq!(preview.image_data.unwrap().len(), 3);\n}\n\n#[tokio::test]\nasync fn test_preview_generator_creation() {\n    let generator = create_test_preview_generator();\n    assert_eq!(generator.ffmpeg_path, \"ffmpeg\");\n}\n\n#[tokio::test]\nasync fn test_preview_generator_with_settings() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let settings = PreviewSettings {\n        default_resolution: (1280, 720),\n        default_quality: 85,\n        ..Default::default()\n    };\n    \n    let generator = PreviewGenerator::with_settings(cache, settings.clone());\n    assert_eq!(generator.settings.default_resolution, (1280, 720));\n    assert_eq!(generator.settings.default_quality, 85);\n}\n\n#[tokio::test]\nasync fn test_set_ffmpeg_path() {\n    let mut generator = create_test_preview_generator();\n    generator.set_ffmpeg_path(\"/usr/local/bin/ffmpeg\");\n    assert_eq!(generator.ffmpeg_path, \"/usr/local/bin/ffmpeg\");\n}\n\n#[tokio::test]\nasync fn test_quality_to_qscale() {\n    let generator = create_test_preview_generator();\n    assert_eq!(generator.quality_to_qscale(100), 2);\n    assert_eq!(generator.quality_to_qscale(0), 31);\n    assert_eq!(generator.quality_to_qscale(50), 16); // (100-50)*29/100 + 2 = 16.45 ≈ 16\n    \n    // Edge cases\n    assert_eq!(generator.quality_to_qscale(150), 2); // Above 100, clamped to 100\n}\n\n#[tokio::test]\nasync fn test_get_extension() {\n    let generator = create_test_preview_generator();\n    \n    match generator.settings.format {\n        PreviewFormat::Jpeg =\u003e assert_eq!(generator.get_file_extension(), \"jpg\"),\n        PreviewFormat::Png =\u003e assert_eq!(generator.get_file_extension(), \"png\"),\n        PreviewFormat::WebP =\u003e assert_eq!(generator.get_file_extension(), \"webp\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_create_temp_output_path() {\n    let generator = create_test_preview_generator();\n    let path = generator.create_temp_output_path().await.unwrap();\n    \n    // Проверяем что путь оканчивается на правильное расширение\n    assert!(path.ends_with(\".jpg\"));\n    \n    // Проверяем что файл пока не существует\n    assert!(!Path::new(\u0026path).exists());\n}\n\n#[tokio::test]\nasync fn test_validate_input_success() {\n    let generator = create_test_preview_generator();\n    let temp_dir = TempDir::new().unwrap();\n    let video_path = temp_dir.path().join(\"test_video.mp4\");\n    \n    // Создаем тестовый файл\n    std::fs::write(\u0026video_path, b\"dummy video data\").unwrap();\n    \n    // Должно пройти валидацию\n    let result = generator.validate_input(\u0026video_path, 10.0);\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_validate_input_file_not_found() {\n    let generator = create_test_preview_generator();\n    let video_path = Path::new(\"/nonexistent/video.mp4\");\n    \n    let result = generator.validate_input(video_path, 10.0);\n    assert!(result.is_err());\n    \n    if let Err(e) = result {\n        assert!(matches!(e, VideoCompilerError::MediaFileError { .. }));\n    }\n}\n\n#[tokio::test]\nasync fn test_validate_input_negative_timestamp() {\n    let generator = create_test_preview_generator();\n    let temp_dir = TempDir::new().unwrap();\n    let video_path = temp_dir.path().join(\"test_video.mp4\");\n    std::fs::write(\u0026video_path, b\"dummy video data\").unwrap();\n    \n    let result = generator.validate_input(\u0026video_path, -5.0);\n    assert!(result.is_err());\n    \n    if let Err(e) = result {\n        assert!(matches!(e, VideoCompilerError::ValidationError(_)));\n    }\n}\n\n#[tokio::test]\nasync fn test_validate_input_unsupported_format() {\n    let generator = create_test_preview_generator();\n    let temp_dir = TempDir::new().unwrap();\n    let video_path = temp_dir.path().join(\"test_file.xyz\");\n    std::fs::write(\u0026video_path, b\"dummy data\").unwrap();\n    \n    let result = generator.validate_input(\u0026video_path, 10.0);\n    assert!(result.is_err());\n    \n    if let Err(e) = result {\n        assert!(matches!(e, VideoCompilerError::UnsupportedFormat { .. }));\n    }\n}\n\n#[tokio::test]\nasync fn test_parse_video_info_valid() {\n    let generator = create_test_preview_generator();\n    let ffmpeg_output = r#\"\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'test.mp4':\n  Duration: 00:02:30.50, start: 0.000000, bitrate: 8000 kb/s\n    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1920x1080 [SAR 1:1 DAR 16:9], 7500 kb/s, 30 fps, 30 tbr, 15360 tbn, 60 tbc (default)\n    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 192 kb/s (default)\n    \"#;\n    \n    let info = generator.parse_video_info(ffmpeg_output).unwrap();\n    assert_eq!(info.duration, 150.5);\n    assert_eq!(info.resolution, Some((1920, 1080)));\n    assert_eq!(info.fps, Some(30.0));\n    assert_eq!(info.bitrate, Some(8000));\n    assert_eq!(info.video_codec, Some(\"h264\".to_string()));\n    assert_eq!(info.audio_codec, Some(\"aac\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_parse_video_info_minimal() {\n    let generator = create_test_preview_generator();\n    let ffmpeg_output = r#\"\nInput #0, matroska,webm, from 'test.mkv':\n  Duration: 00:01:00.00, start: 0.000000\n    \"#;\n    \n    let info = generator.parse_video_info(ffmpeg_output).unwrap();\n    assert_eq!(info.duration, 60.0);\n    assert_eq!(info.resolution, None);\n    assert_eq!(info.fps, None);\n    assert_eq!(info.bitrate, None);\n    assert_eq!(info.video_codec, None);\n    assert_eq!(info.audio_codec, None);\n}\n\n#[tokio::test]\nasync fn test_parse_video_info_no_duration() {\n    let generator = create_test_preview_generator();\n    let ffmpeg_output = \"Some invalid output without duration\";\n    \n    let result = generator.parse_video_info(ffmpeg_output);\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_clear_cache_for_file() {\n    let generator = create_test_preview_generator();\n    \n    // Добавляем что-то в кэш\n    {\n        let mut cache = generator.cache.write().await;\n        let key = PreviewKey::new(\"/test.mp4\".to_string(), 5.0, (640, 360), 75);\n        cache.store_preview(key.clone(), vec![1, 2, 3]).await.unwrap();\n        \n        // Проверяем что есть в кэше\n        assert!(cache.get_preview(\u0026key).await.is_some());\n    }\n    \n    // Очищаем кэш\n    generator.clear_cache_for_file().await.unwrap();\n    \n    // Проверяем что кэш пуст\n    {\n        let mut cache = generator.cache.write().await;\n        let key = PreviewKey::new(\"/test.mp4\".to_string(), 5.0, (640, 360), 75);\n        assert!(cache.get_preview(\u0026key).await.is_none());\n    }\n}\n\n#[test]\nfn test_preview_generator_debug() {\n    let generator = create_test_preview_generator();\n    let debug_str = format!(\"{:?}\", generator);\n    assert!(debug_str.contains(\"PreviewGenerator\"));\n}\n\n#[test]\nfn test_timeline_preview_serialization() {\n    let preview = TimelinePreview {\n        timestamp: 25.5,\n        image_data: Some(vec![5, 10, 15]),\n    };\n    \n    let json = serde_json::to_string(\u0026preview).unwrap();\n    assert!(json.contains(\"25.5\"));\n    \n    let deserialized: TimelinePreview = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.timestamp, preview.timestamp);\n    assert_eq!(deserialized.image_data, preview.image_data);\n}\n\n#[tokio::test]\nasync fn test_preview_batch_result_empty() {\n    let generator = create_test_preview_generator();\n    let results = generator.generate_preview_batch(vec![]).await.unwrap();\n    assert!(results.is_empty());\n}\n\n#[test]\nfn test_all_supported_formats() {\n    let settings = PreviewSettings::default();\n    let expected_formats = vec![\n        \"mp4\", \"mkv\", \"avi\", \"mov\", \"webm\", \"flv\", \"wmv\", \"mpg\", \"mpeg\", \n        \"m4v\", \"3gp\", \"ogv\", \"mxf\", \"ts\", \"vob\"\n    ];\n    \n    for format in expected_formats {\n        assert!(settings.supported_formats.contains(\u0026format.to_string()));\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","preview.rs"],"content":"//! Preview - Модуль генерации превью кадров\n//!\n//! Этот модуль реализует генерацию превью кадров из видео файлов с использованием FFmpeg,\n//! включая кэширование, оптимизацию производительности и поддержку различных форматов.\n\nuse crate::video_compiler::cache::{PreviewKey, RenderCache};\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::schema::PreviewFormat;\nuse base64::engine::general_purpose::STANDARD as BASE64;\nuse base64::Engine as _;\nuse serde::{Deserialize, Serialize};\nuse std::path::{Path, PathBuf};\nuse std::process::Stdio;\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::process::Command;\nuse tokio::sync::RwLock;\n\n/// Генератор превью кадров\n#[derive(Debug)]\npub struct PreviewGenerator {\n  /// Кэш превью\n  cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n  /// Настройки генератора\n  settings: PreviewSettings,\n  /// Путь к FFmpeg\n  ffmpeg_path: String,\n}\n\nimpl PreviewGenerator {\n  /// Создать новый генератор превью\n  pub fn new(cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e) -\u003e Self {\n    Self {\n      cache,\n      settings: PreviewSettings::default(),\n      ffmpeg_path: \"ffmpeg\".to_string(),\n    }\n  }\n\n  /// Создать генератор с настройками\n  pub fn with_settings(cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e, settings: PreviewSettings) -\u003e Self {\n    Self {\n      cache,\n      settings,\n      ffmpeg_path: \"ffmpeg\".to_string(),\n    }\n  }\n\n  /// Установить путь к FFmpeg\n  pub fn set_ffmpeg_path\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, path: P) {\n    self.ffmpeg_path = path.as_ref().to_string_lossy().to_string();\n  }\n\n  /// Сгенерировать превью кадр\n  pub async fn generate_preview(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamp: f64,\n    resolution: Option\u003c(u32, u32)\u003e,\n    quality: Option\u003cu8\u003e,\n  ) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let resolution = resolution.unwrap_or(self.settings.default_resolution);\n    let quality = quality.unwrap_or(self.settings.default_quality);\n\n    // Создаем ключ кэша\n    let cache_key = PreviewKey::new(\n      video_path.to_string_lossy().to_string(),\n      timestamp,\n      resolution,\n      quality,\n    );\n\n    // Проверяем кэш\n    {\n      let mut cache = self.cache.write().await;\n      if let Some(cached_data) = cache.get_preview(\u0026cache_key).await {\n        log::debug!(\"Превью найдено в кэше: {:?} at {}s\", video_path, timestamp);\n        return Ok(cached_data.image_data);\n      }\n    }\n\n    log::debug!(\"Генерация превью: {:?} at {}s\", video_path, timestamp);\n\n    // Валидация входных данных\n    self.validate_input(video_path, timestamp)?;\n\n    // Генерируем превью\n    let image_data = self\n      .generate_preview_internal(video_path, timestamp, resolution, quality)\n      .await?;\n\n    // Сохраняем в кэш\n    {\n      let mut cache = self.cache.write().await;\n      cache.store_preview(cache_key, image_data.clone()).await?;\n    }\n\n    Ok(image_data)\n  }\n\n  /// Генерировать несколько превью одновременно для одного файла\n  pub async fn generate_preview_batch_for_file(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamps: Vec\u003cf64\u003e,\n    resolution: Option\u003c(u32, u32)\u003e,\n    quality: Option\u003cu8\u003e,\n  ) -\u003e Result\u003cVec\u003cPreviewResult\u003e\u003e {\n    let resolution = resolution.unwrap_or(self.settings.default_resolution);\n    let quality = quality.unwrap_or(self.settings.default_quality);\n\n    let mut results = Vec::new();\n    let mut tasks = Vec::new();\n\n    // Создаем задачи для параллельной генерации\n    for timestamp in timestamps {\n      let video_path = video_path.to_owned();\n      let cache = self.cache.clone();\n      let settings = self.settings.clone();\n      let ffmpeg_path = self.ffmpeg_path.clone();\n\n      let task = tokio::spawn(async move {\n        let generator = PreviewGenerator {\n          cache,\n          settings,\n          ffmpeg_path,\n        };\n\n        let result = generator\n          .generate_preview(\u0026video_path, timestamp, Some(resolution), Some(quality))\n          .await;\n        PreviewResult { timestamp, result }\n      });\n\n      tasks.push(task);\n    }\n\n    // Ждем завершения всех задач\n    for task in tasks {\n      match task.await {\n        Ok(result) =\u003e results.push(result),\n        Err(e) =\u003e {\n          log::error!(\"Ошибка в задаче генерации превью: {:?}\", e);\n        }\n      }\n    }\n\n    Ok(results)\n  }\n\n  /// Генерировать несколько превью для разных файлов\n  pub async fn generate_preview_batch(\n    \u0026self,\n    requests: Vec\u003cPreviewRequest\u003e,\n  ) -\u003e Result\u003cVec\u003cSerializablePreviewResult\u003e\u003e {\n    let mut results = Vec::new();\n    let mut tasks = Vec::new();\n\n    // Создаем задачи для параллельной генерации\n    for request in requests {\n      let cache = self.cache.clone();\n      let settings = self.settings.clone();\n      let ffmpeg_path = self.ffmpeg_path.clone();\n\n      let task = tokio::spawn(async move {\n        let generator = PreviewGenerator {\n          cache,\n          settings,\n          ffmpeg_path,\n        };\n\n        let path = Path::new(\u0026request.video_path);\n        let result = generator\n          .generate_preview(path, request.timestamp, request.resolution, request.quality)\n          .await;\n\n        match result {\n          Ok(image_data) =\u003e SerializablePreviewResult {\n            timestamp: request.timestamp,\n            image_data: Some(BASE64.encode(\u0026image_data)),\n            error: None,\n          },\n          Err(e) =\u003e SerializablePreviewResult {\n            timestamp: request.timestamp,\n            image_data: None,\n            error: Some(e.to_string()),\n          },\n        }\n      });\n\n      tasks.push(task);\n    }\n\n    // Ждем завершения всех задач\n    for task in tasks {\n      match task.await {\n        Ok(result) =\u003e results.push(result),\n        Err(e) =\u003e {\n          log::error!(\"Ошибка в задаче генерации превью: {:?}\", e);\n        }\n      }\n    }\n\n    Ok(results)\n  }\n\n  /// Генерировать превью для timeline (полоса превью)\n  pub async fn generate_timeline_previews(\n    \u0026self,\n    video_path: \u0026Path,\n    duration: f64,\n    interval: f64,\n  ) -\u003e Result\u003cVec\u003cTimelinePreview\u003e\u003e {\n    let mut previews = Vec::new();\n    let mut current_time = 0.0;\n\n    while current_time \u003c duration {\n      let result = self\n        .generate_preview(\n          video_path,\n          current_time,\n          Some(self.settings.timeline_resolution),\n          Some(self.settings.timeline_quality),\n        )\n        .await;\n\n      let preview = TimelinePreview {\n        timestamp: current_time,\n        image_data: result.ok(),\n      };\n\n      previews.push(preview);\n      current_time += interval;\n    }\n\n    Ok(previews)\n  }\n\n  /// Очистить кэш превью для конкретного файла\n  pub async fn clear_cache_for_file(\u0026self) -\u003e Result\u003c()\u003e {\n    let mut cache = self.cache.write().await;\n    cache.clear_previews().await;\n    Ok(())\n  }\n\n  /// Получить информацию о видео файле\n  pub async fn get_video_info(\u0026self, video_path: \u0026Path) -\u003e Result\u003cVideoInfo\u003e {\n    let mut cmd = Command::new(\u0026self.ffmpeg_path);\n    cmd.args([\n      \"-i\",\n      \u0026video_path.to_string_lossy(),\n      \"-hide_banner\",\n      \"-f\",\n      \"null\",\n      \"-\",\n    ]);\n    cmd.stdout(Stdio::null());\n    cmd.stderr(Stdio::piped());\n\n    let output = cmd.output().await.map_err(|e| {\n      VideoCompilerError::ffmpeg(\n        None,\n        format!(\"Не удалось запустить FFmpeg: {}\", e),\n        \"ffprobe\".to_string(),\n      )\n    })?;\n\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n    self.parse_video_info(\u0026stderr)\n  }\n\n  /// Внутренняя генерация превью\n  async fn generate_preview_internal(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamp: f64,\n    resolution: (u32, u32),\n    quality: u8,\n  ) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let temp_output = self.create_temp_output_path().await?;\n\n    let mut cmd = Command::new(\u0026self.ffmpeg_path);\n\n    // Настройка команды FFmpeg\n    cmd.args([\n      \"-ss\",\n      \u0026timestamp.to_string(),\n      \"-i\",\n      \u0026video_path.to_string_lossy(),\n      \"-vframes\",\n      \"1\",\n      \"-vf\",\n      \u0026format!(\"scale={}:{}\", resolution.0, resolution.1),\n      \"-q:v\",\n      \u0026self.quality_to_qscale(quality).to_string(),\n      \"-y\",\n    ]);\n\n    // Выбираем формат вывода\n    match self.settings.format {\n      PreviewFormat::Jpeg =\u003e {\n        cmd.args([\"-f\", \"image2\", \"-c:v\", \"mjpeg\"]);\n      }\n      PreviewFormat::Png =\u003e {\n        cmd.args([\"-f\", \"image2\", \"-c:v\", \"png\"]);\n      }\n      PreviewFormat::WebP =\u003e {\n        cmd.args([\"-f\", \"image2\", \"-c:v\", \"libwebp\"]);\n      }\n    }\n\n    cmd.arg(\u0026temp_output);\n    cmd.stdout(Stdio::null());\n    cmd.stderr(Stdio::piped());\n\n    log::debug!(\"Выполнение команды FFmpeg: {:?}\", cmd);\n\n    let output = cmd.output().await.map_err(|e| {\n      let error = VideoCompilerError::ffmpeg(\n        None,\n        format!(\"Не удалось запустить FFmpeg: {}\", e),\n        \"generate_preview\".to_string(),\n      );\n      log::error!(\"Ошибка FFmpeg: {}\", error);\n      log::error!(\"  Код ошибки: {}\", error.error_code());\n      log::error!(\n        \"  Критическая: {}\",\n        if error.is_critical() {\n          \"да\"\n        } else {\n          \"нет\"\n        }\n      );\n      error\n    })?;\n\n    if !output.status.success() {\n      let stderr = String::from_utf8_lossy(\u0026output.stderr);\n      let error = VideoCompilerError::ffmpeg(\n        output.status.code(),\n        stderr.to_string(),\n        format!(\"ffmpeg generate preview at {}s\", timestamp),\n      );\n      log::error!(\"Ошибка выполнения FFmpeg: {}\", error);\n      log::error!(\"  Код ошибки: {}\", error.error_code());\n      log::error!(\n        \"  Можно повторить: {}\",\n        if error.is_retryable() {\n          \"да\"\n        } else {\n          \"нет\"\n        }\n      );\n      return Err(error);\n    }\n\n    // Читаем сгенерированный файл\n    let image_data = tokio::fs::read(\u0026temp_output).await.map_err(|e| {\n      VideoCompilerError::preview(\n        timestamp,\n        format!(\"Не удалось прочитать превью файл: {}\", e),\n      )\n    })?;\n\n    // Удаляем временный файл\n    if let Err(e) = tokio::fs::remove_file(\u0026temp_output).await {\n      log::warn!(\"Не удалось удалить временный файл превью: {}\", e);\n    }\n    log::debug!(\n      \"Превью успешно сгенерировано: {:?} at {}s\",\n      video_path,\n      timestamp\n    );\n    Ok(image_data)\n  }\n\n  /// Валидация входных данных\n  fn validate_input(\u0026self, video_path: \u0026Path, timestamp: f64) -\u003e Result\u003c()\u003e {\n    if !video_path.exists() {\n      return Err(VideoCompilerError::media_file(\n        video_path.to_string_lossy(),\n        \"Файл не найден\",\n      ));\n    }\n\n    if timestamp \u003c 0.0 {\n      return Err(VideoCompilerError::validation(\n        \"Временная метка не может быть отрицательной\",\n      ));\n    }\n\n    // Проверка расширения файла\n    if let Some(extension) = video_path.extension() {\n      let ext = extension.to_string_lossy().to_lowercase();\n      if !self.settings.supported_formats.contains(\u0026ext) {\n        return Err(VideoCompilerError::unsupported_format(\n          ext,\n          video_path.to_string_lossy(),\n        ));\n      }\n    }\n\n    Ok(())\n  }\n\n  /// Создать путь для временного файла\n  async fn create_temp_output_path(\u0026self) -\u003e Result\u003cPathBuf\u003e {\n    let temp_dir = std::env::temp_dir();\n    let filename = format!(\n      \"timeline_preview_{}_{}.{}\",\n      SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap_or(Duration::ZERO)\n        .as_millis(),\n      uuid::Uuid::new_v4(),\n      self.get_file_extension()\n    );\n\n    Ok(temp_dir.join(filename))\n  }\n\n  /// Получить расширение файла для текущего формата\n  fn get_file_extension(\u0026self) -\u003e \u0026'static str {\n    match self.settings.format {\n      PreviewFormat::Jpeg =\u003e \"jpg\",\n      PreviewFormat::Png =\u003e \"png\",\n      PreviewFormat::WebP =\u003e \"webp\",\n    }\n  }\n\n  /// Конвертировать качество (0-100) в qscale для FFmpeg (2-31)\n  fn quality_to_qscale(\u0026self, quality: u8) -\u003e u8 {\n    // Инвертируем шкалу: высокое качество = низкий qscale\n    let quality = quality.min(100) as u32;\n    let qscale = 2 + ((100 - quality) * 29 / 100);\n    qscale.min(31) as u8\n  }\n\n  /// Парсинг информации о видео из вывода FFmpeg\n  fn parse_video_info(\u0026self, ffmpeg_output: \u0026str) -\u003e Result\u003cVideoInfo\u003e {\n    let mut info = VideoInfo::default();\n\n    for line in ffmpeg_output.lines() {\n      // Парсим длительность: Duration: 00:02:30.45\n      if line.contains(\"Duration:\") {\n        if let Some(duration_str) = line.split(\"Duration: \").nth(1) {\n          if let Some(duration_part) = duration_str.split(',').next() {\n            info.duration = parse_duration(duration_part);\n          }\n        }\n      }\n\n      // Парсим видео стрим: Stream #0:0: Video: h264 (avc1), yuv420p, 1920x1080, 30 fps\n      if line.contains(\"Video:\") \u0026\u0026 line.contains(\"Stream\") {\n        // Парсим разрешение\n        if let Some(resolution) = extract_resolution(line) {\n          info.resolution = Some(resolution);\n        }\n\n        // Парсим FPS\n        if let Some(fps) = extract_fps(line) {\n          info.fps = Some(fps);\n        }\n\n        // Парсим кодек\n        if let Some(codec) = extract_video_codec(line) {\n          info.video_codec = Some(codec);\n        }\n      }\n\n      // Парсим аудио стрим\n      if line.contains(\"Audio:\") \u0026\u0026 line.contains(\"Stream\") {\n        if let Some(codec) = extract_audio_codec(line) {\n          info.audio_codec = Some(codec);\n        }\n      }\n\n      // Парсим битрейт\n      if line.contains(\"bitrate:\") {\n        if let Some(bitrate) = extract_bitrate(line) {\n          info.bitrate = Some(bitrate);\n        }\n      }\n    }\n\n    Ok(info)\n  }\n}\n\n/// Настройки генератора превью\n#[derive(Debug, Clone)]\npub struct PreviewSettings {\n  /// Разрешение по умолчанию\n  pub default_resolution: (u32, u32),\n  /// Качество по умолчанию (0-100)\n  pub default_quality: u8,\n  /// Формат превью\n  pub format: PreviewFormat,\n  /// Разрешение для timeline превью\n  pub timeline_resolution: (u32, u32),\n  /// Качество для timeline превью\n  pub timeline_quality: u8,\n  /// Поддерживаемые форматы видео\n  pub supported_formats: Vec\u003cString\u003e,\n  /// Максимальное время ожидания (секунды)\n  pub timeout_seconds: u64,\n  /// Использовать аппаратное ускорение\n  pub hardware_acceleration: bool,\n}\n\nimpl Default for PreviewSettings {\n  fn default() -\u003e Self {\n    Self {\n      default_resolution: (640, 360),\n      default_quality: 75,\n      format: PreviewFormat::Jpeg,\n      timeline_resolution: (160, 90),\n      timeline_quality: 60,\n      supported_formats: vec![\n        \"mp4\".to_string(),\n        \"avi\".to_string(),\n        \"mov\".to_string(),\n        \"mkv\".to_string(),\n        \"webm\".to_string(),\n        \"flv\".to_string(),\n        \"wmv\".to_string(),\n        \"m4v\".to_string(),\n      ],\n      timeout_seconds: 30,\n      hardware_acceleration: false,\n    }\n  }\n}\n\n/// Запрос на генерацию превью\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PreviewRequest {\n  /// Путь к видео файлу\n  pub video_path: String,\n  /// Временная метка\n  pub timestamp: f64,\n  /// Разрешение (опционально)\n  pub resolution: Option\u003c(u32, u32)\u003e,\n  /// Качество (опционально)\n  pub quality: Option\u003cu8\u003e,\n}\n\n/// Результат генерации превью\n#[derive(Debug, Clone)]\npub struct PreviewResult {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Результат генерации\n  pub result: Result\u003cVec\u003cu8\u003e\u003e,\n}\n\n/// Результат генерации превью для сериализации\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SerializablePreviewResult {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные изображения (base64)\n  pub image_data: Option\u003cString\u003e,\n  /// Ошибка если была\n  pub error: Option\u003cString\u003e,\n}\n\n/// Превью для timeline\n#[derive(Debug, Clone)]\npub struct TimelinePreview {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные изображения (None если ошибка)\n  pub image_data: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\n/// Информация о видео файле\n#[derive(Debug, Default, Clone, Serialize, Deserialize)]\npub struct VideoInfo {\n  /// Длительность в секундах\n  pub duration: f64,\n  /// Разрешение видео\n  pub resolution: Option\u003c(u32, u32)\u003e,\n  /// FPS\n  pub fps: Option\u003cf32\u003e,\n  /// Битрейт (bps)\n  pub bitrate: Option\u003cu32\u003e,\n  /// Видео кодек\n  pub video_codec: Option\u003cString\u003e,\n  /// Аудио кодек\n  pub audio_codec: Option\u003cString\u003e,\n}\n\n/// Парсинг длительности из строки формата HH:MM:SS.ss\nfn parse_duration(duration_str: \u0026str) -\u003e f64 {\n  let parts: Vec\u003c\u0026str\u003e = duration_str.trim().split(':').collect();\n  if parts.len() == 3 {\n    let hours: f64 = parts[0].parse().unwrap_or(0.0);\n    let minutes: f64 = parts[1].parse().unwrap_or(0.0);\n    let seconds: f64 = parts[2].parse().unwrap_or(0.0);\n    hours * 3600.0 + minutes * 60.0 + seconds\n  } else {\n    0.0\n  }\n}\n\n/// Извлечение разрешения из строки FFmpeg\nfn extract_resolution(line: \u0026str) -\u003e Option\u003c(u32, u32)\u003e {\n  // Ищем паттерн вида \"1920x1080\"\n  let re = regex::Regex::new(r\"(\\d+)x(\\d+)\").ok()?;\n  let caps = re.captures(line)?;\n  let width: u32 = caps.get(1)?.as_str().parse().ok()?;\n  let height: u32 = caps.get(2)?.as_str().parse().ok()?;\n  Some((width, height))\n}\n\n/// Извлечение FPS из строки FFmpeg\nfn extract_fps(line: \u0026str) -\u003e Option\u003cf32\u003e {\n  // Ищем паттерн вида \"30 fps\" или \"29.97 fps\"\n  let re = regex::Regex::new(r\"(\\d+(?:\\.\\d+)?)\\s*fps\").ok()?;\n  let caps = re.captures(line)?;\n  caps.get(1)?.as_str().parse().ok()\n}\n\n/// Извлечение видео кодека\nfn extract_video_codec(line: \u0026str) -\u003e Option\u003cString\u003e {\n  // Ищем кодек после \"Video:\"\n  if let Some(start) = line.find(\"Video: \") {\n    let codec_part = \u0026line[start + 7..];\n    // Находим конец кодека - либо пробел, либо запятая\n    let end = codec_part.find([' ', ',']).unwrap_or(codec_part.len());\n    Some(codec_part[..end].to_string())\n  } else {\n    None\n  }\n}\n\n/// Извлечение аудио кодека\nfn extract_audio_codec(line: \u0026str) -\u003e Option\u003cString\u003e {\n  // Ищем кодек после \"Audio:\"\n  if let Some(start) = line.find(\"Audio: \") {\n    let codec_part = \u0026line[start + 7..];\n    // Находим конец кодека - либо пробел, либо запятая\n    let end = codec_part.find([' ', ',']).unwrap_or(codec_part.len());\n    Some(codec_part[..end].to_string())\n  } else {\n    None\n  }\n}\n\n/// Извлечение битрейта\nfn extract_bitrate(line: \u0026str) -\u003e Option\u003cu32\u003e {\n  // Ищем паттерн вида \"bitrate: 1234 kb/s\"\n  let re = regex::Regex::new(r\"bitrate:\\s*(\\d+)\\s*kb/s\").ok()?;\n  let caps = re.captures(line)?;\n  let bitrate_kbps: u32 = caps.get(1)?.as_str().parse().ok()?;\n  Some(bitrate_kbps * 1000) // Конвертируем в bps\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::cache::RenderCache;\n  use std::path::PathBuf;\n  use tokio::sync::RwLock;\n\n  fn create_test_generator() -\u003e PreviewGenerator {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    PreviewGenerator::new(cache)\n  }\n\n  #[test]\n  fn test_preview_settings_default() {\n    let settings = PreviewSettings::default();\n    assert_eq!(settings.default_resolution, (640, 360));\n    assert_eq!(settings.default_quality, 75);\n    assert!(settings.supported_formats.contains(\u0026\"mp4\".to_string()));\n  }\n\n  #[test]\n  fn test_quality_to_qscale() {\n    let generator = create_test_generator();\n\n    // Высокое качество = низкий qscale\n    assert_eq!(generator.quality_to_qscale(100), 2);\n    assert_eq!(generator.quality_to_qscale(0), 31);\n    assert_eq!(generator.quality_to_qscale(50), 16); // Примерно средний\n  }\n\n  #[test]\n  fn test_file_extension() {\n    let mut settings = PreviewSettings::default();\n\n    settings.format = PreviewFormat::Jpeg;\n    let generator =\n      PreviewGenerator::with_settings(Arc::new(RwLock::new(RenderCache::new())), settings.clone());\n    assert_eq!(generator.get_file_extension(), \"jpg\");\n\n    settings.format = PreviewFormat::Png;\n    let generator =\n      PreviewGenerator::with_settings(Arc::new(RwLock::new(RenderCache::new())), settings.clone());\n    assert_eq!(generator.get_file_extension(), \"png\");\n\n    settings.format = PreviewFormat::WebP;\n    let generator =\n      PreviewGenerator::with_settings(Arc::new(RwLock::new(RenderCache::new())), settings);\n    assert_eq!(generator.get_file_extension(), \"webp\");\n  }\n\n  #[test]\n  fn test_parse_duration() {\n    assert_eq!(parse_duration(\"01:23:45.67\"), 3600.0 + 23.0 * 60.0 + 45.67);\n    assert_eq!(parse_duration(\"00:00:30.50\"), 30.5);\n    assert_eq!(parse_duration(\"02:00:00.00\"), 7200.0);\n    assert_eq!(parse_duration(\"invalid\"), 0.0);\n  }\n\n  #[test]\n  fn test_extract_resolution() {\n    let line = \"Stream #0:0: Video: h264, yuv420p, 1920x1080, 30 fps\";\n    assert_eq!(extract_resolution(line), Some((1920, 1080)));\n\n    let line = \"Stream #0:0: Video: h264, yuv420p, 640x480, 25 fps\";\n    assert_eq!(extract_resolution(line), Some((640, 480)));\n\n    let line = \"No resolution here\";\n    assert_eq!(extract_resolution(line), None);\n  }\n\n  #[test]\n  fn test_extract_fps() {\n    let line = \"Stream #0:0: Video: h264, yuv420p, 1920x1080, 30 fps\";\n    assert_eq!(extract_fps(line), Some(30.0));\n\n    let line = \"Stream #0:0: Video: h264, yuv420p, 1920x1080, 29.97 fps\";\n    assert_eq!(extract_fps(line), Some(29.97));\n\n    let line = \"No fps here\";\n    assert_eq!(extract_fps(line), None);\n  }\n\n  #[test]\n  fn test_extract_video_codec() {\n    let line = \"Stream #0:0: Video: h264 (avc1), yuv420p, 1920x1080\";\n    assert_eq!(extract_video_codec(line), Some(\"h264\".to_string()));\n\n    let line = \"Stream #0:0: Video: vp9, yuv420p, 1920x1080\";\n    assert_eq!(extract_video_codec(line), Some(\"vp9\".to_string()));\n\n    let line = \"No video codec here\";\n    assert_eq!(extract_video_codec(line), None);\n  }\n\n  #[test]\n  fn test_extract_audio_codec() {\n    let line = \"Stream #0:1: Audio: aac (mp4a), 48000 Hz, stereo\";\n    assert_eq!(extract_audio_codec(line), Some(\"aac\".to_string()));\n\n    let line = \"Stream #0:1: Audio: mp3, 44100 Hz, stereo\";\n    assert_eq!(extract_audio_codec(line), Some(\"mp3\".to_string()));\n\n    let line = \"No audio codec here\";\n    assert_eq!(extract_audio_codec(line), None);\n  }\n\n  #[test]\n  fn test_extract_bitrate() {\n    let line = \"Duration: 00:02:30.45, start: 0.000000, bitrate: 8000 kb/s\";\n    assert_eq!(extract_bitrate(line), Some(8000000)); // 8000 kbps = 8000000 bps\n\n    let line = \"bitrate: 1500 kb/s\";\n    assert_eq!(extract_bitrate(line), Some(1500000));\n\n    let line = \"No bitrate here\";\n    assert_eq!(extract_bitrate(line), None);\n  }\n\n  #[tokio::test]\n  async fn test_video_info_parsing() {\n    let generator = create_test_generator();\n    let ffmpeg_output = r#\"\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'test.mp4':\n  Duration: 00:02:30.45, start: 0.000000, bitrate: 8000 kb/s\n    Stream #0:0(und): Video: h264 (avc1), yuv420p, 1920x1080, 7500 kb/s, 30 fps\n    Stream #0:1(und): Audio: aac (mp4a), 48000 Hz, stereo, fltp, 128 kb/s\n\"#;\n\n    let info = generator.parse_video_info(ffmpeg_output).unwrap();\n    assert_eq!(info.duration, 150.45); // 2:30.45 = 150.45 seconds\n    assert_eq!(info.resolution, Some((1920, 1080)));\n    assert_eq!(info.fps, Some(30.0));\n    assert_eq!(info.video_codec, Some(\"h264\".to_string()));\n    assert_eq!(info.audio_codec, Some(\"aac\".to_string()));\n    assert_eq!(info.bitrate, Some(8000000));\n  }\n\n  #[tokio::test]\n  async fn test_preview_key_creation() {\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n\n    assert_eq!(key.file_path, \"/test/video.mp4\");\n    assert_eq!(key.timestamp, 10500); // 10.5 * 1000\n    assert_eq!(key.resolution, (640, 360));\n    assert_eq!(key.quality, 75);\n  }\n\n  #[tokio::test]\n  async fn test_temp_output_path() {\n    let generator = create_test_generator();\n    let path = generator.create_temp_output_path().await.unwrap();\n\n    assert!(path.to_string_lossy().contains(\"timeline_preview_\"));\n    assert!(path.to_string_lossy().ends_with(\".jpg\")); // default format\n  }\n\n  #[test]\n  fn test_input_validation() {\n    let generator = create_test_generator();\n\n    // Негативная временная метка\n    let result = generator.validate_input(\u0026PathBuf::from(\"/nonexistent\"), -1.0);\n    assert!(result.is_err());\n\n    // Несуществующий файл\n    let result = generator.validate_input(\u0026PathBuf::from(\"/nonexistent/file.mp4\"), 10.0);\n    assert!(result.is_err());\n  }\n\n  #[tokio::test]\n  async fn test_timeline_preview_generation() {\n    let generator = create_test_generator();\n\n    // Создаем мок видео файл (в реальности нужен настоящий файл)\n    let video_path = PathBuf::from(\"/nonexistent/test.mp4\");\n\n    // Этот тест не пройдет без реального видео файла, но структура правильная\n    let _result = generator\n      .generate_timeline_previews(\u0026video_path, 60.0, 10.0)\n      .await;\n\n    // В реальном тесте здесь были бы проверки на количество превью\n    // assert_eq!(result.unwrap().len(), 6); // 60 секунд / 10 секунд интервал\n  }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":7}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":6}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":6}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":8}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":8}},{"line":381,"address":[],"length":0,"stats":{"Line":8}},{"line":382,"address":[],"length":0,"stats":{"Line":8}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":424,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":3}},{"line":434,"address":[],"length":0,"stats":{"Line":3}},{"line":435,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[],"length":0,"stats":{"Line":3}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":466,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":1}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":480,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":1}},{"line":512,"address":[],"length":0,"stats":{"Line":12}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":517,"address":[],"length":0,"stats":{"Line":12}},{"line":519,"address":[],"length":0,"stats":{"Line":12}},{"line":595,"address":[],"length":0,"stats":{"Line":5}},{"line":596,"address":[],"length":0,"stats":{"Line":5}},{"line":597,"address":[],"length":0,"stats":{"Line":5}},{"line":598,"address":[],"length":0,"stats":{"Line":4}},{"line":599,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":4}},{"line":601,"address":[],"length":0,"stats":{"Line":4}},{"line":603,"address":[],"length":0,"stats":{"Line":1}},{"line":608,"address":[],"length":0,"stats":{"Line":4}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":611,"address":[],"length":0,"stats":{"Line":4}},{"line":612,"address":[],"length":0,"stats":{"Line":6}},{"line":613,"address":[],"length":0,"stats":{"Line":6}},{"line":618,"address":[],"length":0,"stats":{"Line":4}},{"line":620,"address":[],"length":0,"stats":{"Line":8}},{"line":621,"address":[],"length":0,"stats":{"Line":4}},{"line":622,"address":[],"length":0,"stats":{"Line":3}},{"line":626,"address":[],"length":0,"stats":{"Line":4}},{"line":628,"address":[],"length":0,"stats":{"Line":7}},{"line":634,"address":[],"length":0,"stats":{"Line":1}},{"line":639,"address":[],"length":0,"stats":{"Line":4}},{"line":641,"address":[],"length":0,"stats":{"Line":7}},{"line":647,"address":[],"length":0,"stats":{"Line":1}},{"line":652,"address":[],"length":0,"stats":{"Line":4}},{"line":654,"address":[],"length":0,"stats":{"Line":8}},{"line":655,"address":[],"length":0,"stats":{"Line":4}},{"line":656,"address":[],"length":0,"stats":{"Line":6}}],"covered":95,"coverable":233},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","progress.rs"],"content":"//! Progress - Модуль отслеживания прогресса рендеринга\n//!\n//! Этот модуль реализует систему отслеживания прогресса рендеринга видео,\n//! включая парсинг вывода FFmpeg, расчет прогресса и уведомления через WebSocket.\n\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::sync::{mpsc, RwLock};\nuse uuid::Uuid;\n\n/// Основной трекер прогресса рендеринга\n#[derive(Debug)]\npub struct ProgressTracker {\n  /// Активные задачи рендеринга\n  active_jobs: Arc\u003cRwLock\u003cHashMap\u003cString, RenderJob\u003e\u003e\u003e,\n  /// Канал для отправки обновлений прогресса\n  progress_sender: mpsc::UnboundedSender\u003cProgressUpdate\u003e,\n  /// Настройки трекера\n  settings: ProgressSettings,\n}\n\nimpl ProgressTracker {\n  /// Создать новый трекер прогресса\n  pub fn new(progress_sender: mpsc::UnboundedSender\u003cProgressUpdate\u003e) -\u003e Self {\n    Self {\n      active_jobs: Arc::new(RwLock::new(HashMap::new())),\n      progress_sender,\n      settings: ProgressSettings::default(),\n    }\n  }\n\n  /// Создать новую задачу рендеринга\n  pub async fn create_job(\n    \u0026self,\n    project_name: String,\n    output_path: String,\n    total_frames: u64,\n  ) -\u003e Result\u003cString\u003e {\n    let job_id = Uuid::new_v4().to_string();\n    let job = RenderJob::new(job_id.clone(), project_name, output_path, total_frames);\n\n    let mut jobs = self.active_jobs.write().await;\n    jobs.insert(job_id.clone(), job);\n\n    // Отправляем уведомление о начале\n    let update = ProgressUpdate::JobStarted {\n      job_id: job_id.clone(),\n    };\n    let _ = self.progress_sender.send(update);\n\n    log::info!(\"Создана новая задача рендеринга: {}\", job_id);\n    Ok(job_id)\n  }\n\n  /// Обновить прогресс задачи\n  pub async fn update_progress(\n    \u0026self,\n    job_id: \u0026str,\n    current_frame: u64,\n    stage: String,\n    message: Option\u003cString\u003e,\n  ) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(job) = jobs.get_mut(job_id) {\n      job.update_progress(current_frame, stage, message)?;\n\n      // Отправляем обновление прогресса\n      let update = ProgressUpdate::ProgressChanged {\n        job_id: job_id.to_string(),\n        progress: job.get_progress(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::debug!(\n        \"Обновлен прогресс задачи {}: {:.1}%\",\n        job_id,\n        job.get_progress().percentage\n      );\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"update_progress\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Завершить задачу успешно\n  pub async fn complete_job(\u0026self, job_id: \u0026str, output_path: String) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(mut job) = jobs.remove(job_id) {\n      job.complete(output_path.clone())?;\n\n      // Отправляем уведомление о завершении\n      let update = ProgressUpdate::JobCompleted {\n        job_id: job_id.to_string(),\n        output_path,\n        duration: job.get_elapsed_time(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::info!(\n        \"Задача {} завершена успешно за {:?}\",\n        job_id,\n        job.get_elapsed_time()\n      );\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"complete_job\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Завершить задачу с ошибкой\n  pub async fn fail_job(\u0026self, job_id: \u0026str, error: String) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(mut job) = jobs.remove(job_id) {\n      job.fail(error.clone())?;\n\n      // Отправляем уведомление об ошибке\n      let update = ProgressUpdate::JobFailed {\n        job_id: job_id.to_string(),\n        error: error.clone(),\n        duration: job.get_elapsed_time(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::error!(\"Задача {} завершена с ошибкой: {}\", job_id, error);\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"fail_job\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Отменить задачу\n  pub async fn cancel_job(\u0026self, job_id: \u0026str) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(mut job) = jobs.remove(job_id) {\n      job.cancel()?;\n\n      // Отправляем уведомление об отмене\n      let update = ProgressUpdate::JobCancelled {\n        job_id: job_id.to_string(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::info!(\"Задача {} отменена\", job_id);\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"cancel_job\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Получить информацию о задаче\n  pub async fn get_job(\u0026self, job_id: \u0026str) -\u003e Option\u003cRenderJob\u003e {\n    let jobs = self.active_jobs.read().await;\n    jobs.get(job_id).cloned()\n  }\n\n  /// Получить все активные задачи\n  pub async fn get_active_jobs(\u0026self) -\u003e Vec\u003cRenderJob\u003e {\n    let jobs = self.active_jobs.read().await;\n    jobs.values().cloned().collect()\n  }\n\n  /// Парсинг вывода FFmpeg для получения прогресса\n  pub fn parse_ffmpeg_progress(\u0026self, output: \u0026str) -\u003e Option\u003cFFmpegProgress\u003e {\n    // Ищем строки с прогрессом FFmpeg\n    for line in output.lines() {\n      if line.starts_with(\"frame=\") {\n        return self.parse_progress_line(line);\n      }\n    }\n    None\n  }\n\n  /// Парсинг строки прогресса FFmpeg\n  fn parse_progress_line(\u0026self, line: \u0026str) -\u003e Option\u003cFFmpegProgress\u003e {\n    let mut progress = FFmpegProgress::default();\n\n    // Парсим различные поля из строки прогресса\n    // Пример: frame= 1234 fps=30 q=28.0 size= 1024kB time=00:00:41.40 bitrate=8000.0kbits/s\n    // Используем более гибкий парсинг для обработки пробелов после знака равенства\n\n    // Парсим frame\n    if let Some(pos) = line.find(\"frame=\") {\n      let start = pos + 6;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.frame = remaining[..end].parse().unwrap_or(0);\n      }\n    }\n\n    // Парсим fps\n    if let Some(pos) = line.find(\"fps=\") {\n      let start = pos + 4;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.fps = remaining[..end].parse().unwrap_or(0.0);\n      }\n    }\n\n    // Парсим q\n    if let Some(pos) = line.find(\"q=\") {\n      let start = pos + 2;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.quality = remaining[..end].parse().unwrap_or(0.0);\n      }\n    }\n\n    // Парсим size\n    if let Some(pos) = line.find(\"size=\") {\n      let start = pos + 5;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.size = parse_size(\u0026remaining[..end]);\n      }\n    }\n\n    // Парсим time\n    if let Some(pos) = line.find(\"time=\") {\n      let start = pos + 5;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.time = parse_time(\u0026remaining[..end]);\n      }\n    }\n\n    // Парсим bitrate\n    if let Some(pos) = line.find(\"bitrate=\") {\n      let start = pos + 8;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.bitrate = parse_bitrate(\u0026remaining[..end]);\n      } else {\n        // Если это последнее поле\n        progress.bitrate = parse_bitrate(remaining);\n      }\n    }\n\n    // Парсим speed\n    if let Some(pos) = line.find(\"speed=\") {\n      let start = pos + 6;\n      let remaining = \u0026line[start..].trim_start();\n      let speed_str = if let Some(end) = remaining.find(char::is_whitespace) {\n        \u0026remaining[..end]\n      } else {\n        remaining\n      };\n      progress.speed = speed_str.trim_end_matches('x').parse().unwrap_or(0.0);\n    }\n\n    Some(progress)\n  }\n}\n\n/// Задача рендеринга\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RenderJob {\n  /// Уникальный идентификатор задачи\n  pub id: String,\n  /// Название проекта\n  pub project_name: String,\n  /// Путь к выходному файлу\n  pub output_path: String,\n  /// Статус задачи\n  pub status: RenderStatus,\n  /// Общее количество кадров\n  pub total_frames: u64,\n  /// Текущий кадр\n  pub current_frame: u64,\n  /// Текущий этап рендеринга\n  pub current_stage: String,\n  /// Время создания задачи\n  pub created_at: SystemTime,\n  /// Время начала рендеринга\n  pub started_at: Option\u003cSystemTime\u003e,\n  /// Время завершения рендеринга\n  pub completed_at: Option\u003cSystemTime\u003e,\n  /// Сообщение о состоянии\n  pub message: Option\u003cString\u003e,\n  /// Ошибка (если есть)\n  pub error: Option\u003cString\u003e,\n}\n\nimpl RenderJob {\n  /// Создать новую задачу рендеринга\n  pub fn new(id: String, project_name: String, output_path: String, total_frames: u64) -\u003e Self {\n    Self {\n      id,\n      project_name,\n      output_path,\n      status: RenderStatus::Queued,\n      total_frames,\n      current_frame: 0,\n      current_stage: \"Queued\".to_string(),\n      created_at: SystemTime::now(),\n      started_at: None,\n      completed_at: None,\n      message: None,\n      error: None,\n    }\n  }\n\n  /// Начать выполнение задачи\n  pub fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if self.status != RenderStatus::Queued {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"start\",\n        \"Задача не в состоянии ожидания\",\n      ));\n    }\n\n    self.status = RenderStatus::Processing;\n    self.started_at = Some(SystemTime::now());\n    self.current_stage = \"Starting\".to_string();\n    Ok(())\n  }\n\n  /// Обновить прогресс задачи\n  pub fn update_progress(\n    \u0026mut self,\n    current_frame: u64,\n    stage: String,\n    message: Option\u003cString\u003e,\n  ) -\u003e Result\u003c()\u003e {\n    if self.status != RenderStatus::Processing {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"update_progress\",\n        \"Задача не выполняется\",\n      ));\n    }\n\n    self.current_frame = current_frame.min(self.total_frames);\n    self.current_stage = stage;\n    self.message = message;\n    Ok(())\n  }\n\n  /// Завершить задачу успешно\n  pub fn complete(\u0026mut self, final_output_path: String) -\u003e Result\u003c()\u003e {\n    if self.status != RenderStatus::Processing {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"complete\",\n        \"Задача не выполняется\",\n      ));\n    }\n\n    self.status = RenderStatus::Completed;\n    self.completed_at = Some(SystemTime::now());\n    self.output_path = final_output_path;\n    self.current_frame = self.total_frames;\n    self.current_stage = \"Completed\".to_string();\n    Ok(())\n  }\n\n  /// Завершить задачу с ошибкой\n  pub fn fail(\u0026mut self, error: String) -\u003e Result\u003c()\u003e {\n    if self.status == RenderStatus::Completed {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"fail\",\n        \"Задача уже завершена\",\n      ));\n    }\n\n    self.status = RenderStatus::Failed;\n    self.completed_at = Some(SystemTime::now());\n    self.error = Some(error);\n    self.current_stage = \"Failed\".to_string();\n    Ok(())\n  }\n\n  /// Отменить задачу\n  pub fn cancel(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if matches!(self.status, RenderStatus::Completed | RenderStatus::Failed) {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"cancel\",\n        \"Задача уже завершена\",\n      ));\n    }\n\n    self.status = RenderStatus::Cancelled;\n    self.completed_at = Some(SystemTime::now());\n    self.current_stage = \"Cancelled\".to_string();\n    Ok(())\n  }\n\n  /// Получить прогресс рендеринга\n  pub fn get_progress(\u0026self) -\u003e RenderProgress {\n    let percentage = if self.total_frames \u003e 0 {\n      (self.current_frame as f32 / self.total_frames as f32) * 100.0\n    } else {\n      0.0\n    };\n\n    let elapsed_time = self.get_elapsed_time();\n    let estimated_remaining = if percentage \u003e 0.0 \u0026\u0026 percentage \u003c 100.0 {\n      let total_estimated = elapsed_time.as_secs_f32() * (100.0 / percentage);\n      Some(Duration::from_secs_f32(\n        total_estimated - elapsed_time.as_secs_f32(),\n      ))\n    } else {\n      None\n    };\n\n    RenderProgress {\n      job_id: self.id.clone(),\n      stage: self.current_stage.clone(),\n      percentage,\n      current_frame: self.current_frame,\n      total_frames: self.total_frames,\n      elapsed_time,\n      estimated_remaining,\n      status: self.status.clone(),\n      message: self.message.clone(),\n    }\n  }\n\n  /// Получить время выполнения\n  pub fn get_elapsed_time(\u0026self) -\u003e Duration {\n    let start_time = self.started_at.unwrap_or(self.created_at);\n    let end_time = self.completed_at.unwrap_or_else(SystemTime::now);\n    end_time\n      .duration_since(start_time)\n      .unwrap_or(Duration::ZERO)\n  }\n}\n\n/// Статус рендеринга\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum RenderStatus {\n  /// В очереди\n  Queued,\n  /// Выполняется\n  Processing,\n  /// Завершено успешно\n  Completed,\n  /// Завершено с ошибкой\n  Failed,\n  /// Отменено\n  Cancelled,\n}\n\n/// Прогресс рендеринга\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct RenderProgress {\n  /// ID задачи\n  pub job_id: String,\n  /// Текущий этап\n  pub stage: String,\n  /// Процент выполнения (0.0 - 100.0)\n  pub percentage: f32,\n  /// Текущий кадр\n  pub current_frame: u64,\n  /// Общее количество кадров\n  pub total_frames: u64,\n  /// Прошедшее время\n  pub elapsed_time: Duration,\n  /// Оценочное оставшееся время\n  pub estimated_remaining: Option\u003cDuration\u003e,\n  /// Статус задачи\n  pub status: RenderStatus,\n  /// Дополнительное сообщение\n  pub message: Option\u003cString\u003e,\n}\n\n/// Обновления прогресса для WebSocket\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"type\")]\npub enum ProgressUpdate {\n  /// Задача начата\n  JobStarted { job_id: String },\n  /// Прогресс изменился\n  ProgressChanged {\n    job_id: String,\n    progress: RenderProgress,\n  },\n  /// Задача завершена\n  JobCompleted {\n    job_id: String,\n    output_path: String,\n    duration: Duration,\n  },\n  /// Задача завершилась с ошибкой\n  JobFailed {\n    job_id: String,\n    error: String,\n    duration: Duration,\n  },\n  /// Задача отменена\n  JobCancelled { job_id: String },\n}\n\n/// Настройки трекера прогресса\n#[derive(Debug, Clone)]\npub struct ProgressSettings {\n  /// Интервал обновления прогресса\n  pub update_interval: Duration,\n  /// Максимальное количество активных задач\n  pub max_concurrent_jobs: usize,\n  /// Таймаут для задач\n  pub job_timeout: Duration,\n}\n\nimpl Default for ProgressSettings {\n  fn default() -\u003e Self {\n    Self {\n      update_interval: Duration::from_millis(500),\n      max_concurrent_jobs: 3,\n      job_timeout: Duration::from_secs(3600), // 1 час\n    }\n  }\n}\n\n/// Прогресс FFmpeg\n#[derive(Debug, Default, Clone)]\npub struct FFmpegProgress {\n  /// Номер кадра\n  pub frame: u64,\n  /// FPS\n  pub fps: f32,\n  /// Качество\n  pub quality: f32,\n  /// Размер выходного файла\n  pub size: u64,\n  /// Время обработки\n  pub time: Duration,\n  /// Битрейт\n  pub bitrate: f32,\n  /// Скорость обработки\n  pub speed: f32,\n}\n\n/// Парсинг размера файла из строки FFmpeg\nfn parse_size(size_str: \u0026str) -\u003e u64 {\n  let size_str = size_str.trim();\n  if let Some(value_str) = size_str.strip_suffix(\"kB\") {\n    value_str.parse::\u003cf64\u003e().unwrap_or(0.0) as u64 * 1024\n  } else if let Some(value_str) = size_str.strip_suffix(\"MB\") {\n    value_str.parse::\u003cf64\u003e().unwrap_or(0.0) as u64 * 1024 * 1024\n  } else if let Some(value_str) = size_str.strip_suffix(\"GB\") {\n    value_str.parse::\u003cf64\u003e().unwrap_or(0.0) as u64 * 1024 * 1024 * 1024\n  } else {\n    size_str.parse().unwrap_or(0)\n  }\n}\n\n/// Парсинг времени из строки FFmpeg (формат HH:MM:SS.ss)\nfn parse_time(time_str: \u0026str) -\u003e Duration {\n  let parts: Vec\u003c\u0026str\u003e = time_str.split(':').collect();\n  if parts.len() == 3 {\n    let hours: f64 = parts[0].parse().unwrap_or(0.0);\n    let minutes: f64 = parts[1].parse().unwrap_or(0.0);\n    let seconds: f64 = parts[2].parse().unwrap_or(0.0);\n\n    let total_seconds = hours * 3600.0 + minutes * 60.0 + seconds;\n    Duration::from_secs_f64(total_seconds)\n  } else {\n    Duration::ZERO\n  }\n}\n\n/// Парсинг битрейта из строки FFmpeg\nfn parse_bitrate(bitrate_str: \u0026str) -\u003e f32 {\n  let bitrate_str = bitrate_str.trim();\n  if let Some(value_str) = bitrate_str.strip_suffix(\"kbits/s\") {\n    value_str.parse().unwrap_or(0.0)\n  } else if let Some(value_str) = bitrate_str.strip_suffix(\"Mbits/s\") {\n    value_str.parse::\u003cf32\u003e().unwrap_or(0.0) * 1000.0\n  } else {\n    bitrate_str.parse().unwrap_or(0.0)\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use tokio::sync::mpsc;\n\n  #[tokio::test]\n  async fn test_progress_tracker_creation() {\n    let (tx, _rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let jobs = tracker.get_active_jobs().await;\n    assert_eq!(jobs.len(), 0);\n  }\n\n  #[tokio::test]\n  async fn test_job_lifecycle() {\n    let (tx, mut rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    // Создаем задачу\n    let job_id = tracker\n      .create_job(\n        \"Test Project\".to_string(),\n        \"/test/output.mp4\".to_string(),\n        1000,\n      )\n      .await\n      .unwrap();\n\n    // Проверяем уведомление о создании\n    let update = rx.recv().await.unwrap();\n    assert!(matches!(update, ProgressUpdate::JobStarted { .. }));\n\n    // Запускаем задачу чтобы изменить статус на Processing\n    {\n      let mut jobs = tracker.active_jobs.write().await;\n      if let Some(job) = jobs.get_mut(\u0026job_id) {\n        job.start().unwrap();\n      }\n    }\n\n    // Обновляем прогресс\n    tracker\n      .update_progress(\u0026job_id, 500, \"Encoding\".to_string(), None)\n      .await\n      .unwrap();\n\n    // Проверяем уведомление о прогрессе\n    let update = rx.recv().await.unwrap();\n    if let ProgressUpdate::ProgressChanged { progress, .. } = update {\n      assert_eq!(progress.current_frame, 500);\n      assert_eq!(progress.percentage, 50.0);\n    } else {\n      panic!(\"Ожидалось ProgressChanged\");\n    }\n\n    // Завершаем задачу\n    tracker\n      .complete_job(\u0026job_id, \"/test/final.mp4\".to_string())\n      .await\n      .unwrap();\n\n    // Проверяем уведомление о завершении\n    let update = rx.recv().await.unwrap();\n    assert!(matches!(update, ProgressUpdate::JobCompleted { .. }));\n\n    // Задача должна быть удалена из активных\n    let jobs = tracker.get_active_jobs().await;\n    assert_eq!(jobs.len(), 0);\n  }\n\n  #[tokio::test]\n  async fn test_render_job() {\n    let mut job = RenderJob::new(\n      \"test-123\".to_string(),\n      \"Test Project\".to_string(),\n      \"/test/output.mp4\".to_string(),\n      1000,\n    );\n\n    assert_eq!(job.status, RenderStatus::Queued);\n\n    // Начинаем задачу\n    job.start().unwrap();\n    assert_eq!(job.status, RenderStatus::Processing);\n    assert!(job.started_at.is_some());\n\n    // Обновляем прогресс\n    job\n      .update_progress(250, \"Encoding\".to_string(), Some(\"Frame 250\".to_string()))\n      .unwrap();\n    assert_eq!(job.current_frame, 250);\n\n    let progress = job.get_progress();\n    assert_eq!(progress.percentage, 25.0);\n\n    // Завершаем задачу\n    job.complete(\"/test/final.mp4\".to_string()).unwrap();\n    assert_eq!(job.status, RenderStatus::Completed);\n    assert!(job.completed_at.is_some());\n  }\n\n  #[test]\n  fn test_ffmpeg_progress_parsing() {\n    let (tx, _rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let ffmpeg_output =\n      \"frame= 1234 fps=30.5 q=28.0 size= 2048kB time=00:01:23.45 bitrate=1500.0kbits/s speed=1.2x\";\n    let progress = tracker.parse_ffmpeg_progress(ffmpeg_output).unwrap();\n\n    assert_eq!(progress.frame, 1234);\n    assert_eq!(progress.fps, 30.5);\n    assert_eq!(progress.quality, 28.0);\n    assert_eq!(progress.size, 2048 * 1024);\n    assert_eq!(progress.bitrate, 1500.0);\n    assert_eq!(progress.speed, 1.2);\n  }\n\n  #[test]\n  fn test_size_parsing() {\n    assert_eq!(parse_size(\"1024kB\"), 1024 * 1024);\n    assert_eq!(parse_size(\"2MB\"), 2 * 1024 * 1024);\n    assert_eq!(parse_size(\"1GB\"), 1024 * 1024 * 1024);\n    assert_eq!(parse_size(\"512\"), 512);\n  }\n\n  #[test]\n  fn test_time_parsing() {\n    let duration = parse_time(\"01:23:45.67\");\n    assert_eq!(duration.as_secs(), 3600 + 23 * 60 + 45);\n\n    let duration = parse_time(\"00:00:30.50\");\n    assert_eq!(duration.as_secs_f64(), 30.5);\n  }\n\n  #[test]\n  fn test_bitrate_parsing() {\n    assert_eq!(parse_bitrate(\"1500.0kbits/s\"), 1500.0);\n    assert_eq!(parse_bitrate(\"1.5Mbits/s\"), 1500.0);\n    assert_eq!(parse_bitrate(\"8000\"), 8000.0);\n  }\n\n  #[tokio::test]\n  async fn test_job_error_handling() {\n    let (tx, mut rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let job_id = tracker\n      .create_job(\n        \"Error Test\".to_string(),\n        \"/test/output.mp4\".to_string(),\n        100,\n      )\n      .await\n      .unwrap();\n\n    // Пропускаем уведомление о создании\n    rx.recv().await;\n\n    // Завершаем с ошибкой\n    tracker\n      .fail_job(\u0026job_id, \"FFmpeg error\".to_string())\n      .await\n      .unwrap();\n\n    // Проверяем уведомление об ошибке\n    let update = rx.recv().await.unwrap();\n    if let ProgressUpdate::JobFailed { error, .. } = update {\n      assert_eq!(error, \"FFmpeg error\");\n    } else {\n      panic!(\"Ожидалось JobFailed\");\n    }\n  }\n\n  #[tokio::test]\n  async fn test_job_cancellation() {\n    let (tx, mut rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let job_id = tracker\n      .create_job(\n        \"Cancel Test\".to_string(),\n        \"/test/output.mp4\".to_string(),\n        100,\n      )\n      .await\n      .unwrap();\n\n    // Пропускаем уведомление о создании\n    rx.recv().await;\n\n    // Отменяем задачу\n    tracker.cancel_job(\u0026job_id).await.unwrap();\n\n    // Проверяем уведомление об отмене\n    let update = rx.recv().await.unwrap();\n    assert!(matches!(update, ProgressUpdate::JobCancelled { .. }));\n  }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":12}},{"line":185,"address":[],"length":0,"stats":{"Line":12}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":5}},{"line":320,"address":[],"length":0,"stats":{"Line":5}},{"line":321,"address":[],"length":0,"stats":{"Line":5}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":2}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":5}},{"line":352,"address":[],"length":0,"stats":{"Line":5}},{"line":353,"address":[],"length":0,"stats":{"Line":3}},{"line":354,"address":[],"length":0,"stats":{"Line":3}},{"line":355,"address":[],"length":0,"stats":{"Line":3}},{"line":356,"address":[],"length":0,"stats":{"Line":3}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":381,"address":[],"length":0,"stats":{"Line":2}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":2}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":397,"address":[],"length":0,"stats":{"Line":2}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":419,"address":[],"length":0,"stats":{"Line":4}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":6}},{"line":427,"address":[],"length":0,"stats":{"Line":2}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":440,"address":[],"length":0,"stats":{"Line":2}},{"line":443,"address":[],"length":0,"stats":{"Line":2}},{"line":444,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":5}},{"line":450,"address":[],"length":0,"stats":{"Line":5}},{"line":451,"address":[],"length":0,"stats":{"Line":5}},{"line":452,"address":[],"length":0,"stats":{"Line":5}},{"line":453,"address":[],"length":0,"stats":{"Line":5}},{"line":454,"address":[],"length":0,"stats":{"Line":5}},{"line":535,"address":[],"length":0,"stats":{"Line":12}},{"line":537,"address":[],"length":0,"stats":{"Line":12}},{"line":539,"address":[],"length":0,"stats":{"Line":12}},{"line":564,"address":[],"length":0,"stats":{"Line":5}},{"line":565,"address":[],"length":0,"stats":{"Line":5}},{"line":566,"address":[],"length":0,"stats":{"Line":7}},{"line":568,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":3}},{"line":579,"address":[],"length":0,"stats":{"Line":3}},{"line":580,"address":[],"length":0,"stats":{"Line":3}},{"line":581,"address":[],"length":0,"stats":{"Line":3}},{"line":582,"address":[],"length":0,"stats":{"Line":3}},{"line":583,"address":[],"length":0,"stats":{"Line":3}},{"line":585,"address":[],"length":0,"stats":{"Line":3}},{"line":586,"address":[],"length":0,"stats":{"Line":3}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":4}},{"line":594,"address":[],"length":0,"stats":{"Line":4}},{"line":595,"address":[],"length":0,"stats":{"Line":6}},{"line":597,"address":[],"length":0,"stats":{"Line":3}},{"line":600,"address":[],"length":0,"stats":{"Line":1}}],"covered":146,"coverable":196},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","renderer.rs"],"content":"//! Renderer - Основной модуль рендеринга видео\n//!\n//! Этот модуль реализует основную логику рендеринга видео проектов,\n//! включая управление задачами, интеграцию с FFmpeg и обработку ошибок.\n\nuse serde::{Deserialize, Serialize};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse tokio::sync::{mpsc, RwLock};\n\nuse crate::video_compiler::cache::RenderCache;\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::ffmpeg_builder::FFmpegBuilder;\nuse crate::video_compiler::pipeline::RenderPipeline;\nuse crate::video_compiler::progress::ProgressTracker;\nuse crate::video_compiler::schema::ProjectSchema;\nuse crate::video_compiler::CompilerSettings;\n\n/// Основной рендерер видео\n#[derive(Debug)]\npub struct VideoRenderer {\n  /// Схема проекта для рендеринга\n  project: ProjectSchema,\n  /// Настройки компилятора\n  settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n  /// Кэш рендеринга\n  cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n  /// Трекер прогресса\n  progress_tracker: Arc\u003cProgressTracker\u003e,\n  /// Построитель команд FFmpeg\n  ffmpeg_builder: FFmpegBuilder,\n}\n\nimpl VideoRenderer {\n  /// Создать новый рендерер\n  pub async fn new(\n    project: ProjectSchema,\n    settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n    cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n    progress_sender: mpsc::UnboundedSender\u003ccrate::video_compiler::progress::ProgressUpdate\u003e,\n  ) -\u003e Result\u003cSelf\u003e {\n    // Валидация проекта\n    project.validate().map_err(VideoCompilerError::validation)?;\n\n    let progress_tracker = Arc::new(ProgressTracker::new(progress_sender));\n    let ffmpeg_builder = FFmpegBuilder::new(project.clone());\n\n    Ok(Self {\n      project,\n      settings,\n      cache,\n      progress_tracker,\n      ffmpeg_builder,\n    })\n  }\n\n  /// Запустить рендеринг видео\n  pub async fn render(\u0026mut self, output_path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let job_id = self.create_render_job(output_path).await?;\n\n    // Запускаем рендеринг в отдельной задаче\n    let job_id_clone = job_id.clone();\n    let project = self.project.clone();\n    let output_path = output_path.to_owned();\n    let progress_tracker = self.progress_tracker.clone();\n    let ffmpeg_builder = self.ffmpeg_builder.clone();\n    let settings = self.settings.clone();\n\n    let progress_tracker_clone = progress_tracker.clone();\n    tokio::spawn(async move {\n      let result = Self::render_internal(\n        project,\n        output_path,\n        progress_tracker,\n        ffmpeg_builder,\n        settings,\n        job_id_clone.clone(), // Передаем job_id\n      )\n      .await;\n\n      match result {\n        Ok(final_path) =\u003e {\n          let _ = progress_tracker_clone\n            .complete_job(\u0026job_id_clone, final_path)\n            .await;\n        }\n        Err(e) =\u003e {\n          log::error!(\"Ошибка рендеринга: {}\", e);\n          log::error!(\"  Код ошибки: {}\", e.error_code());\n          log::error!(\n            \"  Критическая: {}\",\n            if e.is_critical() { \"да\" } else { \"нет\" }\n          );\n          log::error!(\n            \"  Можно повторить: {}\",\n            if e.is_retryable() { \"да\" } else { \"нет\" }\n          );\n\n          let _ = progress_tracker_clone\n            .fail_job(\u0026job_id_clone, e.to_string())\n            .await;\n        }\n      }\n    });\n\n    Ok(job_id)\n  }\n\n  /// Создать задачу рендеринга\n  async fn create_render_job(\u0026self, output_path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let total_frames = self.estimate_total_frames();\n\n    self\n      .progress_tracker\n      .create_job(\n        self.project.metadata.name.clone(),\n        output_path.to_string_lossy().to_string(),\n        total_frames,\n      )\n      .await\n  }\n\n  /// Оценить общее количество кадров\n  fn estimate_total_frames(\u0026self) -\u003e u64 {\n    let duration = self.project.get_duration();\n    let fps = self.project.timeline.fps as f64;\n    (duration * fps) as u64\n  }\n\n  /// Внутренняя логика рендеринга\n  async fn render_internal(\n    project: ProjectSchema,\n    output_path: PathBuf,\n    progress_tracker: Arc\u003cProgressTracker\u003e,\n    _ffmpeg_builder: FFmpegBuilder,\n    settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n    job_id: String, // Добавляем job_id как параметр\n  ) -\u003e Result\u003cString\u003e {\n    log::info!(\n      \"Начало рендеринга проекта: {} (job_id: {})\",\n      project.metadata.name,\n      job_id\n    );\n\n    // Создаем RenderPipeline\n    let mut pipeline = RenderPipeline::new(\n      project.clone(),\n      progress_tracker.clone(),\n      settings,\n      output_path.clone(),\n    )\n    .await?;\n\n    // Используем переданный job_id вместо поиска\n    // Это исправляет проблему с двойной системой отслеживания задач\n\n    // Запускаем pipeline\n    let final_output = pipeline.execute(\u0026job_id).await?;\n\n    log::info!(\"Рендеринг завершен: {:?}\", final_output);\n\n    Ok(final_output.to_string_lossy().to_string())\n  }\n\n  /// Отменить рендеринг\n  pub async fn cancel(\u0026mut self) -\u003e Result\u003c()\u003e {\n    // Получаем активные задачи и отменяем их\n    let jobs = self.progress_tracker.get_active_jobs().await;\n    for job in jobs {\n      self.progress_tracker.cancel_job(\u0026job.id).await?;\n    }\n    Ok(())\n  }\n\n  /// Получить текущий прогресс\n  pub async fn get_progress(\u0026self) -\u003e Option\u003ccrate::video_compiler::progress::RenderProgress\u003e {\n    let jobs = self.progress_tracker.get_active_jobs().await;\n    jobs.first().map(|job| job.get_progress())\n  }\n}\n\n/// Настройки рендеринга\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RenderSettings {\n  /// Использовать аппаратное ускорение\n  pub hardware_acceleration: bool,\n  /// Количество потоков FFmpeg\n  pub threads: Option\u003cu32\u003e,\n  /// Дополнительные параметры FFmpeg\n  pub extra_args: Vec\u003cString\u003e,\n  /// Таймаут рендеринга (секунды)\n  pub timeout_seconds: u64,\n}\n\nimpl Default for RenderSettings {\n  fn default() -\u003e Self {\n    Self {\n      hardware_acceleration: true,\n      threads: None, // Автоматическое определение\n      extra_args: Vec::new(),\n      timeout_seconds: 3600, // 1 час\n    }\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::cache::RenderCache;\n  use crate::video_compiler::progress::ProgressUpdate;\n  use std::sync::Arc;\n  use tokio::sync::{mpsc, RwLock};\n\n  async fn create_test_renderer() -\u003e VideoRenderer {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let (tx, _rx) = mpsc::unbounded_channel::\u003cProgressUpdate\u003e();\n\n    VideoRenderer::new(project, settings, cache, tx)\n      .await\n      .unwrap()\n  }\n\n  #[tokio::test]\n  async fn test_renderer_creation() {\n    let renderer = create_test_renderer().await;\n    assert_eq!(renderer.project.metadata.name, \"Test Project\");\n  }\n\n  #[tokio::test]\n  async fn test_estimate_total_frames() {\n    let renderer = create_test_renderer().await;\n    let frames = renderer.estimate_total_frames();\n    // Пустой проект должен иметь 0 кадров\n    assert_eq!(frames, 0);\n  }\n\n  #[tokio::test]\n  async fn test_render_settings_default() {\n    let settings = RenderSettings::default();\n    assert!(settings.hardware_acceleration);\n    assert_eq!(settings.timeout_seconds, 3600);\n    assert!(settings.extra_args.is_empty());\n  }\n\n  #[tokio::test]\n  async fn test_cancel_render() {\n    let mut renderer = create_test_renderer().await;\n\n    // Отмена рендеринга не должна вызывать ошибку, даже если нет активных задач\n    let result = renderer.cancel().await;\n    assert!(result.is_ok());\n  }\n\n  #[tokio::test]\n  async fn test_get_progress_empty() {\n    let renderer = create_test_renderer().await;\n\n    // Без активных задач прогресс должен быть None\n    let progress = renderer.get_progress().await;\n    assert!(progress.is_none());\n  }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":48,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":5}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}}],"covered":58,"coverable":70},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","schema.rs"],"content":"//! Schema - Схема данных проекта Timeline Studio\n//!\n//! Этот модуль определяет структуры данных для описания проектов видеомонтажа,\n//! включая timeline, треки, клипы, эффекты и настройки.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n/// Основная схема проекта Timeline Studio\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectSchema {\n  /// Версия схемы проекта для совместимости\n  pub version: String,\n  /// Метаданные проекта\n  pub metadata: ProjectMetadata,\n  /// Настройки timeline (fps, разрешение, длительность)\n  pub timeline: Timeline,\n  /// Список треков (видео, аудио, субтитры)\n  pub tracks: Vec\u003cTrack\u003e,\n  /// Глобальные эффекты проекта\n  pub effects: Vec\u003cEffect\u003e,\n  /// Переходы между клипами\n  pub transitions: Vec\u003cTransition\u003e,\n  /// Фильтры для визуальных эффектов\n  pub filters: Vec\u003cFilter\u003e,\n  /// Шаблоны многокамерных раскладок\n  pub templates: Vec\u003cTemplate\u003e,\n  /// Стильные шаблоны (интро, аутро, титры)\n  pub style_templates: Vec\u003cStyleTemplate\u003e,\n  /// Субтитры проекта\n  pub subtitles: Vec\u003cSubtitle\u003e,\n  /// Настройки проекта и экспорта\n  pub settings: ProjectSettings,\n}\n\nimpl ProjectSchema {\n  /// Создать новый пустой проект\n  pub fn new(name: String) -\u003e Self {\n    Self {\n      version: \"1.0.0\".to_string(),\n      metadata: ProjectMetadata {\n        name,\n        description: None,\n        created_at: Utc::now(),\n        modified_at: Utc::now(),\n        author: None,\n      },\n      timeline: Timeline::default(),\n      tracks: Vec::new(),\n      effects: Vec::new(),\n      transitions: Vec::new(),\n      filters: Vec::new(),\n      templates: Vec::new(),\n      style_templates: Vec::new(),\n      subtitles: Vec::new(),\n      settings: ProjectSettings::default(),\n    }\n  }\n\n  /// Валидация схемы проекта\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    // Проверка версии\n    if self.version.is_empty() {\n      return Err(\"Версия проекта не может быть пустой\".to_string());\n    }\n\n    // Проверка timeline\n    if self.timeline.fps == 0 {\n      return Err(\"FPS должен быть больше 0\".to_string());\n    }\n\n    if self.timeline.resolution.0 == 0 || self.timeline.resolution.1 == 0 {\n      return Err(\"Разрешение должно быть больше 0x0\".to_string());\n    }\n\n    // Проверка треков\n    for track in \u0026self.tracks {\n      track.validate()?;\n    }\n\n    // Проверка клипов на пересечения по времени в одном треке\n    for track in \u0026self.tracks {\n      let mut clips = track.clips.clone();\n      clips.sort_by(|a, b| a.start_time.partial_cmp(\u0026b.start_time).unwrap());\n\n      for i in 0..clips.len().saturating_sub(1) {\n        if clips[i].end_time \u003e clips[i + 1].start_time {\n          return Err(format!(\n            \"Клипы пересекаются по времени в треке '{}': {} и {}\",\n            track.name,\n            clips[i].id,\n            clips[i + 1].id\n          ));\n        }\n      }\n    }\n\n    Ok(())\n  }\n\n  /// Получить общую длительность проекта\n  pub fn get_duration(\u0026self) -\u003e f64 {\n    self\n      .tracks\n      .iter()\n      .flat_map(|track| \u0026track.clips)\n      .map(|clip| clip.end_time)\n      .fold(0.0, f64::max)\n  }\n\n  /// Обновить время модификации\n  pub fn touch(\u0026mut self) {\n    self.metadata.modified_at = Utc::now();\n  }\n}\n\n/// Метаданные проекта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectMetadata {\n  /// Название проекта\n  pub name: String,\n  /// Описание проекта\n  pub description: Option\u003cString\u003e,\n  /// Время создания\n  pub created_at: DateTime\u003cUtc\u003e,\n  /// Время последней модификации\n  pub modified_at: DateTime\u003cUtc\u003e,\n  /// Автор проекта\n  pub author: Option\u003cString\u003e,\n}\n\n/// Настройки timeline\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Timeline {\n  /// Общая продолжительность в секундах\n  pub duration: f64,\n  /// Кадры в секунду\n  pub fps: u32,\n  /// Разрешение видео (ширина, высота)\n  pub resolution: (u32, u32),\n  /// Частота дискретизации аудио\n  pub sample_rate: u32,\n  /// Соотношение сторон\n  pub aspect_ratio: AspectRatio,\n}\n\nimpl Default for Timeline {\n  fn default() -\u003e Self {\n    Self {\n      duration: 0.0,\n      fps: 30,\n      resolution: (1920, 1080),\n      sample_rate: 48000,\n      aspect_ratio: AspectRatio::Ratio16x9,\n    }\n  }\n}\n\n/// Соотношение сторон видео\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum AspectRatio {\n  Ratio16x9,   // 16:9 (широкоформатное)\n  Ratio4x3,    // 4:3 (стандартное)\n  Ratio21x9,   // 21:9 (ультраширокое)\n  Ratio1x1,    // 1:1 (квадратное)\n  Ratio9x16,   // 9:16 (вертикальное для мобильных)\n  Custom(f32), // Произвольное соотношение\n}\n\n/// Дорожка timeline (видео, аудио, субтитры)\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Track {\n  /// Уникальный идентификатор трека\n  pub id: String,\n  /// Тип трека\n  pub track_type: TrackType,\n  /// Название трека\n  pub name: String,\n  /// Включен ли трек\n  pub enabled: bool,\n  /// Громкость трека (0.0 - 1.0)\n  pub volume: f32,\n  /// Заблокирован ли трек для редактирования\n  pub locked: bool,\n  /// Список клипов в треке\n  pub clips: Vec\u003cClip\u003e,\n  /// ID эффектов, применяемых ко всему треку\n  pub effects: Vec\u003cString\u003e,\n  /// ID фильтров, применяемых ко всему треку\n  pub filters: Vec\u003cString\u003e,\n}\n\nimpl Track {\n  /// Создать новый трек\n  pub fn new(track_type: TrackType, name: String) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      track_type,\n      name,\n      enabled: true,\n      volume: 1.0,\n      locked: false,\n      clips: Vec::new(),\n      effects: Vec::new(),\n      filters: Vec::new(),\n    }\n  }\n\n  /// Валидация трека\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    if self.name.is_empty() {\n      return Err(\"Название трека не может быть пустым\".to_string());\n    }\n\n    if !(0.0..=1.0).contains(\u0026self.volume) {\n      return Err(\"Громкость должна быть в диапазоне 0.0-1.0\".to_string());\n    }\n\n    for clip in \u0026self.clips {\n      clip.validate()?;\n    }\n\n    Ok(())\n  }\n\n  /// Добавить клип в трек\n  pub fn add_clip(\u0026mut self, clip: Clip) -\u003e Result\u003c(), String\u003e {\n    // Проверяем, что клип не пересекается с существующими\n    for existing_clip in \u0026self.clips {\n      if !(clip.end_time \u003c= existing_clip.start_time || clip.start_time \u003e= existing_clip.end_time) {\n        return Err(format!(\n          \"Клип пересекается с существующим клипом {}\",\n          existing_clip.id\n        ));\n      }\n    }\n\n    self.clips.push(clip);\n    Ok(())\n  }\n}\n\n/// Тип дорожки\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TrackType {\n  /// Видео дорожка\n  Video,\n  /// Аудио дорожка\n  Audio,\n  /// Дорожка субтитров\n  Subtitle,\n}\n\n/// Клип медиа на дорожке\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Clip {\n  /// Уникальный идентификатор клипа\n  pub id: String,\n  /// Путь к исходному медиа файлу\n  pub source_path: PathBuf,\n  /// Время начала клипа на timeline (секунды)\n  pub start_time: f64,\n  /// Время окончания клипа на timeline (секунды)\n  pub end_time: f64,\n  /// Время начала в исходном файле (секунды)\n  pub source_start: f64,\n  /// Время окончания в исходном файле (секунды)\n  pub source_end: f64,\n  /// Скорость воспроизведения (1.0 = нормальная)\n  pub speed: f32,\n  /// Громкость клипа (0.0 - 1.0)\n  pub volume: f32,\n  /// Заблокирован ли клип\n  pub locked: bool,\n  /// ID эффектов, применяемых к клипу\n  pub effects: Vec\u003cString\u003e,\n  /// ID фильтров, применяемых к клипу\n  pub filters: Vec\u003cString\u003e,\n  /// ID шаблона для многокамерной раскладки\n  pub template_id: Option\u003cString\u003e,\n  /// Индекс ячейки в шаблоне (0-based)\n  pub template_cell: Option\u003cusize\u003e,\n  /// ID стильного шаблона (интро, аутро, титры)\n  pub style_template_id: Option\u003cString\u003e,\n  /// Дополнительные свойства клипа\n  pub properties: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Clip {\n  /// Создать новый клип\n  pub fn new(source_path: PathBuf, start_time: f64, duration: f64) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      source_path,\n      start_time,\n      end_time: start_time + duration,\n      source_start: 0.0,\n      source_end: duration,\n      speed: 1.0,\n      volume: 1.0,\n      locked: false,\n      effects: Vec::new(),\n      filters: Vec::new(),\n      template_id: None,\n      template_cell: None,\n      style_template_id: None,\n      properties: HashMap::new(),\n    }\n  }\n\n  /// Валидация клипа\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    if self.start_time \u003c 0.0 {\n      return Err(\"Время начала не может быть отрицательным\".to_string());\n    }\n\n    if self.end_time \u003c= self.start_time {\n      return Err(\"Время окончания должно быть больше времени начала\".to_string());\n    }\n\n    if self.source_start \u003c 0.0 {\n      return Err(\"Время начала в источнике не может быть отрицательным\".to_string());\n    }\n\n    if self.source_end \u003c= self.source_start {\n      return Err(\"Время окончания в источнике должно быть больше времени начала\".to_string());\n    }\n\n    if self.speed \u003c= 0.0 {\n      return Err(\"Скорость должна быть больше 0\".to_string());\n    }\n\n    if !(0.0..=1.0).contains(\u0026self.volume) {\n      return Err(\"Громкость должна быть в диапазоне 0.0-1.0\".to_string());\n    }\n\n    if !self.source_path.exists() {\n      return Err(format!(\"Исходный файл не найден: {:?}\", self.source_path));\n    }\n\n    Ok(())\n  }\n\n  /// Получить длительность клипа на timeline\n  pub fn get_timeline_duration(\u0026self) -\u003e f64 {\n    self.end_time - self.start_time\n  }\n\n  /// Получить длительность исходного материала\n  pub fn get_source_duration(\u0026self) -\u003e f64 {\n    self.source_end - self.source_start\n  }\n}\n\n/// Эффект, применяемый к клипу или треку\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Effect {\n  /// Уникальный идентификатор эффекта\n  pub id: String,\n  /// Тип эффекта (строка для расширяемости)\n  pub effect_type: EffectType,\n  /// Название эффекта\n  pub name: String,\n  /// Категория эффекта\n  pub category: Option\u003cEffectCategory\u003e,\n  /// Сложность эффекта\n  pub complexity: Option\u003cEffectComplexity\u003e,\n  /// Теги эффекта\n  pub tags: Vec\u003cEffectTag\u003e,\n  /// Описание эффекта (локализованное)\n  pub description: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Метки эффекта (локализованные)\n  pub labels: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Включен ли эффект\n  pub enabled: bool,\n  /// Параметры эффекта\n  pub parameters: HashMap\u003cString, EffectParameter\u003e,\n  /// Время начала эффекта (для анимации)\n  pub start_time: Option\u003cf64\u003e,\n  /// Время окончания эффекта (для анимации)\n  pub end_time: Option\u003cf64\u003e,\n  /// FFmpeg команда (в виде шаблона)\n  pub ffmpeg_command: Option\u003cString\u003e,\n  /// CSS фильтр (в виде шаблона)\n  pub css_filter: Option\u003cString\u003e,\n  /// Путь к превью\n  pub preview_path: Option\u003cString\u003e,\n  /// Пресеты эффекта\n  pub presets: Option\u003cHashMap\u003cString, EffectPreset\u003e\u003e,\n}\n\n/// Пресет эффекта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct EffectPreset {\n  /// Название пресета (локализованное)\n  pub name: HashMap\u003cString, String\u003e,\n  /// Параметры пресета\n  pub params: HashMap\u003cString, EffectParameter\u003e,\n  /// Описание пресета (локализованное)\n  pub description: HashMap\u003cString, String\u003e,\n}\n\nimpl Effect {\n  /// Создать новый эффект\n  pub fn new(effect_type: EffectType, name: String) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      effect_type,\n      name,\n      category: None,\n      complexity: None,\n      tags: Vec::new(),\n      description: None,\n      labels: None,\n      enabled: true,\n      parameters: HashMap::new(),\n      start_time: None,\n      end_time: None,\n      ffmpeg_command: None,\n      css_filter: None,\n      preview_path: None,\n      presets: None,\n    }\n  }\n}\n\n/// Тип эффекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectType {\n  /// Размытие\n  Blur,\n  /// Яркость\n  Brightness,\n  /// Контрастность\n  Contrast,\n  /// Скорость\n  Speed,\n  /// Реверс\n  Reverse,\n  /// Черно-белый\n  Grayscale,\n  /// Сепия\n  Sepia,\n  /// Насыщенность\n  Saturation,\n  /// Поворот оттенка\n  HueRotate,\n  /// Винтаж\n  Vintage,\n  /// Дуотон\n  Duotone,\n  /// Нуар\n  Noir,\n  /// Киберпанк\n  Cyberpunk,\n  /// Мечтательный\n  Dreamy,\n  /// Инфракрасный\n  Infrared,\n  /// Матрица\n  Matrix,\n  /// Арктический\n  Arctic,\n  /// Закат\n  Sunset,\n  /// Ломо\n  Lomo,\n  /// Сумерки\n  Twilight,\n  /// Неон\n  Neon,\n  /// Инверсия\n  Invert,\n  /// Виньетка\n  Vignette,\n  /// Зерно пленки\n  FilmGrain,\n  /// Хроматическая аберрация\n  ChromaticAberration,\n  /// Блик объектива\n  LensFlare,\n  /// Свечение\n  Glow,\n  /// Резкость\n  Sharpen,\n  /// Шумоподавление\n  NoiseReduction,\n  /// Стабилизация\n  Stabilization,\n  // Аудио эффекты\n  /// Плавное появление звука\n  AudioFadeIn,\n  /// Плавное затухание звука\n  AudioFadeOut,\n  /// Кроссфейд между аудио\n  AudioCrossfade,\n  /// Эквалайзер\n  AudioEqualizer,\n  /// Компрессор\n  AudioCompressor,\n  /// Реверберация\n  AudioReverb,\n  /// Задержка (эхо)\n  AudioDelay,\n  /// Хорус\n  AudioChorus,\n  /// Искажение\n  AudioDistortion,\n  /// Нормализация\n  AudioNormalize,\n  /// Шумоподавление\n  AudioDenoise,\n  /// Изменение высоты тона\n  AudioPitch,\n  /// Изменение темпа\n  AudioTempo,\n  /// Приглушение (дакинг)\n  AudioDucking,\n  /// Гейт\n  AudioGate,\n  /// Лимитер\n  AudioLimiter,\n  /// Экспандер\n  AudioExpander,\n  /// Панорамирование\n  AudioPan,\n  /// Ширина стерео\n  AudioStereoWidth,\n  /// Фильтр высоких частот\n  AudioHighpass,\n  /// Фильтр низких частот\n  AudioLowpass,\n  /// Полосовой фильтр\n  AudioBandpass,\n}\n\n/// Категория эффекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectCategory {\n  /// Цветокоррекция\n  ColorCorrection,\n  /// Художественные\n  Artistic,\n  /// Винтажные\n  Vintage,\n  /// Кинематографические\n  Cinematic,\n  /// Креативные\n  Creative,\n  /// Технические\n  Technical,\n  /// Движение и скорость\n  Motion,\n  /// Искажения\n  Distortion,\n}\n\n/// Сложность эффекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectComplexity {\n  /// Базовый\n  Basic,\n  /// Средний\n  Intermediate,\n  /// Продвинутый\n  Advanced,\n}\n\n/// Теги эффектов\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectTag {\n  /// Популярный\n  Popular,\n  /// Профессиональный\n  Professional,\n  /// Для начинающих\n  BeginnerFriendly,\n  /// Экспериментальный\n  Experimental,\n  /// Ретро\n  Retro,\n  /// Современный\n  Modern,\n  /// Драматический\n  Dramatic,\n  /// Тонкий\n  Subtle,\n  /// Интенсивный\n  Intense,\n}\n\n/// Параметр эффекта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum EffectParameter {\n  /// Число с плавающей точкой\n  Float(f32),\n  /// Целое число\n  Int(i32),\n  /// Строка\n  String(String),\n  /// Булево значение\n  Bool(bool),\n  /// Цвет в формате RGBA\n  Color(u32),\n  /// Массив чисел\n  FloatArray(Vec\u003cf32\u003e),\n  /// Путь к файлу\n  FilePath(PathBuf),\n}\n\n/// Фильтр для визуальных эффектов\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Filter {\n  /// Уникальный идентификатор фильтра\n  pub id: String,\n  /// Тип фильтра\n  pub filter_type: FilterType,\n  /// Название фильтра\n  pub name: String,\n  /// Включен ли фильтр\n  pub enabled: bool,\n  /// Параметры фильтра (числовые значения)\n  pub parameters: HashMap\u003cString, f64\u003e,\n  /// FFmpeg команда для применения фильтра\n  pub ffmpeg_command: Option\u003cString\u003e,\n}\n\nimpl Filter {\n  /// Создать новый фильтр\n  pub fn new(filter_type: FilterType, name: String) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      filter_type,\n      name,\n      enabled: true,\n      parameters: HashMap::new(),\n      ffmpeg_command: None,\n    }\n  }\n}\n\n/// Тип фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterType {\n  /// Яркость\n  Brightness,\n  /// Контрастность\n  Contrast,\n  /// Насыщенность\n  Saturation,\n  /// Гамма\n  Gamma,\n  /// Температура цвета\n  Temperature,\n  /// Оттенок\n  Tint,\n  /// Поворот цвета\n  Hue,\n  /// Живость цветов\n  Vibrance,\n  /// Тени\n  Shadows,\n  /// Светлые тона\n  Highlights,\n  /// Черные тона\n  Blacks,\n  /// Белые тона\n  Whites,\n  /// Четкость\n  Clarity,\n  /// Удаление дымки\n  Dehaze,\n  /// Виньетка\n  Vignette,\n  /// Зернистость\n  Grain,\n  /// Размытие\n  Blur,\n  /// Резкость\n  Sharpen,\n  /// Пользовательский фильтр\n  Custom,\n}\n\n/// Шаблон многокамерной раскладки\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Template {\n  /// Уникальный идентификатор шаблона\n  pub id: String,\n  /// Тип шаблона\n  pub template_type: TemplateType,\n  /// Название шаблона\n  pub name: String,\n  /// Количество видео в шаблоне\n  pub screens: usize,\n  /// Ячейки шаблона с позициями\n  pub cells: Vec\u003cTemplateCell\u003e,\n}\n\nimpl Template {\n  /// Создать новый шаблон\n  pub fn new(template_type: TemplateType, name: String, screens: usize) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      template_type,\n      name,\n      screens,\n      cells: Vec::new(),\n    }\n  }\n}\n\n/// Тип шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TemplateType {\n  /// Вертикальное разделение\n  Vertical,\n  /// Горизонтальное разделение\n  Horizontal,\n  /// Диагональное разделение\n  Diagonal,\n  /// Сетка\n  Grid,\n  /// Пользовательский\n  Custom,\n}\n\n/// Ячейка шаблона\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TemplateCell {\n  /// Индекс ячейки (0-based)\n  pub index: usize,\n  /// Позиция X в процентах (0-100)\n  pub x: f32,\n  /// Позиция Y в процентах (0-100)\n  pub y: f32,\n  /// Ширина в процентах (0-100)\n  pub width: f32,\n  /// Высота в процентах (0-100)\n  pub height: f32,\n  /// Режим масштабирования видео\n  pub fit_mode: FitMode,\n  /// Горизонтальное выравнивание\n  pub align_x: AlignX,\n  /// Вертикальное выравнивание\n  pub align_y: AlignY,\n  /// Дополнительное масштабирование (1.0 = 100%)\n  pub scale: Option\u003cf32\u003e,\n}\n\n/// Режим масштабирования видео в ячейке\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FitMode {\n  /// Вписать полностью с черными полосами\n  Contain,\n  /// Заполнить с обрезкой\n  Cover,\n  /// Растянуть на всю ячейку\n  Fill,\n}\n\n/// Горизонтальное выравнивание\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AlignX {\n  /// По левому краю\n  Left,\n  /// По центру\n  Center,\n  /// По правому краю\n  Right,\n}\n\n/// Вертикальное выравнивание\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AlignY {\n  /// По верхнему краю\n  Top,\n  /// По центру\n  Center,\n  /// По нижнему краю\n  Bottom,\n}\n\n/// Стильный шаблон (интро, аутро, титры)\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct StyleTemplate {\n  /// Уникальный идентификатор шаблона\n  pub id: String,\n  /// Название шаблона\n  pub name: String,\n  /// Категория шаблона\n  pub category: StyleTemplateCategory,\n  /// Стиль шаблона\n  pub style: StyleTemplateStyle,\n  /// Длительность в секундах\n  pub duration: f64,\n  /// Элементы шаблона\n  pub elements: Vec\u003cStyleTemplateElement\u003e,\n}\n\nimpl StyleTemplate {\n  /// Создать новый стильный шаблон\n  pub fn new(\n    name: String,\n    category: StyleTemplateCategory,\n    style: StyleTemplateStyle,\n    duration: f64,\n  ) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      name,\n      category,\n      style,\n      duration,\n      elements: Vec::new(),\n    }\n  }\n}\n\n/// Категория стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum StyleTemplateCategory {\n  /// Интро\n  Intro,\n  /// Аутро\n  Outro,\n  /// Нижняя треть\n  LowerThird,\n  /// Титры\n  Title,\n  /// Переход\n  Transition,\n  /// Наложение\n  Overlay,\n}\n\n/// Стиль шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum StyleTemplateStyle {\n  /// Современный\n  Modern,\n  /// Винтажный\n  Vintage,\n  /// Минимальный\n  Minimal,\n  /// Корпоративный\n  Corporate,\n  /// Креативный\n  Creative,\n  /// Кинематографический\n  Cinematic,\n}\n\n/// Элемент стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct StyleTemplateElement {\n  /// Уникальный идентификатор элемента\n  pub id: String,\n  /// Тип элемента\n  pub element_type: StyleElementType,\n  /// Название элемента\n  pub name: String,\n  /// Позиция элемента\n  pub position: Position2D,\n  /// Размер элемента\n  pub size: Size2D,\n  /// Временные параметры\n  pub timing: ElementTiming,\n  /// Свойства элемента\n  pub properties: StyleElementProperties,\n  /// Анимации элемента\n  pub animations: Vec\u003cElementAnimation\u003e,\n}\n\n/// Тип элемента стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum StyleElementType {\n  /// Текст\n  Text,\n  /// Фигура\n  Shape,\n  /// Изображение\n  Image,\n  /// Видео\n  Video,\n  /// Анимация\n  Animation,\n  /// Частицы\n  Particle,\n}\n\n/// Позиция в 2D пространстве\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Position2D {\n  /// Позиция X в процентах (0-100)\n  pub x: f32,\n  /// Позиция Y в процентах (0-100)\n  pub y: f32,\n}\n\n/// Размер в 2D пространстве\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Size2D {\n  /// Ширина в процентах (0-100)\n  pub width: f32,\n  /// Высота в процентах (0-100)\n  pub height: f32,\n}\n\n/// Временные параметры элемента\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ElementTiming {\n  /// Время начала в секундах\n  pub start: f64,\n  /// Время окончания в секундах\n  pub end: f64,\n}\n\n/// Свойства элемента стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct StyleElementProperties {\n  /// Прозрачность (0-1)\n  pub opacity: Option\u003cf32\u003e,\n  /// Поворот в градусах\n  pub rotation: Option\u003cf32\u003e,\n  /// Масштаб\n  pub scale: Option\u003cf32\u003e,\n\n  // Текстовые свойства\n  /// Текст\n  pub text: Option\u003cString\u003e,\n  /// Размер шрифта\n  pub font_size: Option\u003cf32\u003e,\n  /// Семейство шрифтов\n  pub font_family: Option\u003cString\u003e,\n  /// Цвет\n  pub color: Option\u003cString\u003e,\n  /// Выравнивание текста\n  pub text_align: Option\u003cTextAlign\u003e,\n  /// Толщина шрифта\n  pub font_weight: Option\u003cFontWeight\u003e,\n\n  // Свойства фигур\n  /// Цвет фона\n  pub background_color: Option\u003cString\u003e,\n  /// Цвет границы\n  pub border_color: Option\u003cString\u003e,\n  /// Толщина границы\n  pub border_width: Option\u003cf32\u003e,\n  /// Радиус скругления\n  pub border_radius: Option\u003cf32\u003e,\n\n  // Свойства изображений/видео\n  /// Источник\n  pub src: Option\u003cString\u003e,\n  /// Режим заполнения\n  pub object_fit: Option\u003cObjectFit\u003e,\n}\n\n/// Выравнивание текста\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TextAlign {\n  /// По левому краю\n  Left,\n  /// По центру\n  Center,\n  /// По правому краю\n  Right,\n}\n\n/// Толщина шрифта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FontWeight {\n  /// Обычный\n  Normal,\n  /// Жирный\n  Bold,\n  /// Тонкий\n  Light,\n}\n\n/// Режим заполнения объекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum ObjectFit {\n  /// Вписать с сохранением пропорций\n  Contain,\n  /// Заполнить с обрезкой\n  Cover,\n  /// Растянуть\n  Fill,\n}\n\n/// Анимация элемента\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ElementAnimation {\n  /// Уникальный идентификатор анимации\n  pub id: String,\n  /// Тип анимации\n  pub animation_type: AnimationType,\n  /// Длительность анимации в секундах\n  pub duration: f64,\n  /// Задержка перед началом\n  pub delay: Option\u003cf64\u003e,\n  /// Функция сглаживания\n  pub easing: Option\u003cAnimationEasing\u003e,\n  /// Направление анимации\n  pub direction: Option\u003cAnimationDirection\u003e,\n  /// Дополнительные свойства\n  pub properties: HashMap\u003cString, serde_json::Value\u003e,\n}\n\n/// Тип анимации\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AnimationType {\n  /// Появление\n  FadeIn,\n  /// Исчезновение\n  FadeOut,\n  /// Въезд\n  SlideIn,\n  /// Выезд\n  SlideOut,\n  /// Увеличение\n  ScaleIn,\n  /// Уменьшение\n  ScaleOut,\n  /// Прыжок\n  Bounce,\n  /// Тряска\n  Shake,\n}\n\n/// Функция сглаживания анимации\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AnimationEasing {\n  /// Линейная\n  Linear,\n  /// Плавная\n  Ease,\n  /// Плавный вход\n  EaseIn,\n  /// Плавный выход\n  EaseOut,\n  /// Плавный вход и выход\n  EaseInOut,\n}\n\n/// Направление анимации\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AnimationDirection {\n  /// Влево\n  Left,\n  /// Вправо\n  Right,\n  /// Вверх\n  Up,\n  /// Вниз\n  Down,\n}\n\n/// Переход между клипами\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Transition {\n  /// Уникальный идентификатор перехода\n  pub id: String,\n  /// Тип перехода (строка для расширяемости)\n  pub transition_type: TransitionType,\n  /// Название перехода\n  pub name: String,\n  /// Метки перехода (локализованные)\n  pub labels: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Описание перехода (локализованное)\n  pub description: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Категория перехода\n  pub category: Option\u003cTransitionCategory\u003e,\n  /// Сложность перехода\n  pub complexity: Option\u003cTransitionComplexity\u003e,\n  /// Теги перехода\n  pub tags: Vec\u003cTransitionTag\u003e,\n  /// Настройки длительности\n  pub duration: TransitionDuration,\n  /// Время начала перехода на timeline\n  pub start_time: f64,\n  /// ID клипа \"от\"\n  pub from_clip_id: String,\n  /// ID клипа \"к\"\n  pub to_clip_id: String,\n  /// Параметры перехода\n  pub parameters: HashMap\u003cString, EffectParameter\u003e,\n  /// FFmpeg команда (в виде шаблона)\n  pub ffmpeg_command: Option\u003cString\u003e,\n  /// Путь к превью\n  pub preview_path: Option\u003cString\u003e,\n}\n\n/// Настройки длительности перехода\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TransitionDuration {\n  /// Минимальная длительность в секундах\n  pub min: f64,\n  /// Максимальная длительность в секундах\n  pub max: f64,\n  /// Длительность по умолчанию\n  pub default: f64,\n  /// Текущая длительность\n  pub current: f64,\n}\n\n/// Фильтр видео\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct VideoFilter {\n  /// Уникальный идентификатор фильтра\n  pub id: String,\n  /// Название фильтра\n  pub name: String,\n  /// Категория фильтра\n  pub category: FilterCategory,\n  /// Сложность фильтра\n  pub complexity: FilterComplexity,\n  /// Теги фильтра\n  pub tags: Vec\u003cFilterTag\u003e,\n  /// Описание фильтра (локализованное)\n  pub description: HashMap\u003cString, String\u003e,\n  /// Метки фильтра (локализованные)\n  pub labels: HashMap\u003cString, String\u003e,\n  /// Параметры фильтра\n  pub params: HashMap\u003cString, f32\u003e,\n}\n\n/// Категория фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterCategory {\n  /// Цветокоррекция\n  ColorCorrection,\n  /// Технические\n  Technical,\n  /// Кинематографические\n  Cinematic,\n  /// Художественные\n  Artistic,\n  /// Креативные\n  Creative,\n  /// Винтажные\n  Vintage,\n}\n\n/// Сложность фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterComplexity {\n  /// Базовый\n  Basic,\n  /// Средний\n  Intermediate,\n  /// Продвинутый\n  Advanced,\n}\n\n/// Тег фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterTag {\n  /// Логарифмический\n  Log,\n  /// Профессиональный\n  Professional,\n  /// Стандартный\n  Standard,\n  /// Нейтральный\n  Neutral,\n  /// Кинематографический\n  Cinematic,\n  /// Портрет\n  Portrait,\n  /// Пейзаж\n  Landscape,\n  /// Винтажный\n  Vintage,\n  /// Теплый\n  Warm,\n  /// Холодный\n  Cold,\n  /// Драматический\n  Dramatic,\n  /// Мягкий\n  Soft,\n  /// Яркий\n  Vibrant,\n  /// Резервный\n  Fallback,\n}\n\n/// Тип перехода (расширяемый через строки)\npub type TransitionType = String;\n\n/// Категория перехода\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TransitionCategory {\n  /// Базовые\n  Basic,\n  /// Продвинутые\n  Advanced,\n  /// Креативные\n  Creative,\n  /// 3D\n  ThreeD,\n  /// Художественные\n  Artistic,\n  /// Кинематографические\n  Cinematic,\n}\n\n/// Сложность перехода\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TransitionComplexity {\n  /// Базовый\n  Basic,\n  /// Средний\n  Intermediate,\n  /// Продвинутый\n  Advanced,\n}\n\n/// Тег перехода\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TransitionTag {\n  /// Приближение\n  Zoom,\n  /// Масштаб\n  Scale,\n  /// Плавный\n  Smooth,\n  /// Затухание\n  Fade,\n  /// Прозрачность\n  Opacity,\n  /// Классический\n  Classic,\n  /// Слайд\n  Slide,\n  /// Движение\n  Movement,\n  /// Направление\n  Direction,\n  /// Размер\n  Size,\n  /// Трансформация\n  Transform,\n  /// Поворот\n  Rotate,\n  /// Вращение\n  Spin,\n  /// Переворот\n  Flip,\n  /// Зеркало\n  Mirror,\n  /// Выталкивание\n  Push,\n  /// Смещение\n  Displacement,\n  /// Сжатие\n  Squeeze,\n  /// Компрессия\n  Compress,\n  /// Эластичный\n  Elastic,\n  /// Диагональный\n  Diagonal,\n  /// Угол\n  Angle,\n  /// Спираль\n  Spiral,\n  /// Вращение\n  Rotation,\n  /// 3D\n  ThreeD,\n  /// Сложный\n  Complex,\n  /// Резервный\n  Fallback,\n  /// Шторка\n  Wipe,\n  /// Горизонтальный\n  Horizontal,\n  /// Вертикальный\n  Vertical,\n  /// Радиальный\n  Radial,\n  /// Круговой\n  Circular,\n  /// Центр\n  Center,\n  /// Куб\n  Cube,\n  /// Страница\n  Page,\n  /// Поворот\n  Turn,\n  /// Книга\n  Book,\n  /// Креативный\n  Creative,\n  /// Рябь\n  Ripple,\n  /// Вода\n  Water,\n  /// Волна\n  Wave,\n  /// Искажение\n  Distortion,\n  /// Пиксель\n  Pixel,\n  /// Цифровой\n  Digital,\n  /// Ретро\n  Retro,\n  /// 8-бит\n  EightBit,\n  /// Растворение\n  Dissolve,\n  /// Шум\n  Noise,\n  /// Морфинг\n  Morph,\n  /// Жидкий\n  Fluid,\n  /// Глитч\n  Glitch,\n  /// Современный\n  Modern,\n  /// Калейдоскоп\n  Kaleidoscope,\n  /// Геометрический\n  Geometric,\n  /// Артистический\n  Artistic,\n  /// Разбитие\n  Shatter,\n  /// Ломать\n  Break,\n  /// Стекло\n  Glass,\n  /// Драматический\n  Dramatic,\n  /// Горение\n  Burn,\n  /// Огонь\n  Fire,\n  /// Кинематографический\n  Cinematic,\n  /// Жалюзи\n  Blinds,\n  /// Полосы\n  Stripes,\n  /// Диафрагма\n  Iris,\n  /// Камера\n  Camera,\n  /// Водоворот\n  Swirl,\n  /// Закручивание\n  Twist,\n  /// Размытие\n  Blur,\n  /// Движение\n  Motion,\n  /// Скорость\n  Speed,\n  /// ТВ\n  Tv,\n  /// Помехи\n  Static,\n  /// Аналоговый\n  Analog,\n}\n\n/// Настройки проекта\n#[derive(Serialize, Deserialize, Debug, Clone, Default)]\npub struct ProjectSettings {\n  /// Настройки экспорта\n  pub export: ExportSettings,\n  /// Настройки превью\n  pub preview: PreviewSettings,\n  /// Пользовательские настройки\n  pub custom: HashMap\u003cString, serde_json::Value\u003e,\n}\n\n/// Настройки экспорта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ExportSettings {\n  /// Формат вывода\n  pub format: OutputFormat,\n  /// Качество (от 1 до 100)\n  pub quality: u8,\n  /// Битрейт видео (kbps)\n  pub video_bitrate: u32,\n  /// Битрейт аудио (kbps)\n  pub audio_bitrate: u32,\n  /// Использовать аппаратное ускорение\n  pub hardware_acceleration: bool,\n  /// Предпочитаемый GPU кодировщик (опционально)\n  pub preferred_gpu_encoder: Option\u003cString\u003e,\n  /// Дополнительные параметры FFmpeg\n  pub ffmpeg_args: Vec\u003cString\u003e,\n}\n\nimpl Default for ExportSettings {\n  fn default() -\u003e Self {\n    Self {\n      format: OutputFormat::Mp4,\n      quality: 85,\n      video_bitrate: 8000,\n      audio_bitrate: 192,\n      hardware_acceleration: true,\n      preferred_gpu_encoder: None,\n      ffmpeg_args: Vec::new(),\n    }\n  }\n}\n\n/// Формат вывода видео\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum OutputFormat {\n  Mp4,\n  Avi,\n  Mov,\n  Mkv,\n  WebM,\n  Gif,\n  Custom(String),\n}\n\n/// Настройки превью\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PreviewSettings {\n  /// Разрешение превью\n  pub resolution: (u32, u32),\n  /// Качество превью (от 1 до 100)\n  pub quality: u8,\n  /// FPS превью\n  pub fps: u32,\n  /// Формат превью\n  pub format: PreviewFormat,\n}\n\nimpl Default for PreviewSettings {\n  fn default() -\u003e Self {\n    Self {\n      resolution: (640, 360),\n      quality: 75,\n      fps: 15,\n      format: PreviewFormat::Jpeg,\n    }\n  }\n}\n\n/// Формат превью\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum PreviewFormat {\n  Jpeg,\n  Png,\n  WebP,\n}\n\n/// Субтитр\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Subtitle {\n  /// Уникальный идентификатор субтитра\n  pub id: String,\n  /// Текст субтитра\n  pub text: String,\n  /// Время начала в секундах\n  pub start_time: f64,\n  /// Время окончания в секундах\n  pub end_time: f64,\n  /// Позиция субтитра на экране\n  pub position: SubtitlePosition,\n  /// Стиль субтитра\n  pub style: SubtitleStyle,\n  /// Включен ли субтитр\n  pub enabled: bool,\n  /// Анимации субтитра\n  pub animations: Vec\u003cSubtitleAnimation\u003e,\n}\n\nimpl Subtitle {\n  /// Создать новый субтитр\n  pub fn new(text: String, start_time: f64, end_time: f64) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      text,\n      start_time,\n      end_time,\n      position: SubtitlePosition::default(),\n      style: SubtitleStyle::default(),\n      enabled: true,\n      animations: Vec::new(),\n    }\n  }\n\n  /// Проверить валидность субтитра\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    if self.text.is_empty() {\n      return Err(\"Текст субтитра не может быть пустым\".to_string());\n    }\n\n    if self.start_time \u003c 0.0 {\n      return Err(\"Время начала не может быть отрицательным\".to_string());\n    }\n\n    if self.end_time \u003c= self.start_time {\n      return Err(\"Время окончания должно быть больше времени начала\".to_string());\n    }\n\n    Ok(())\n  }\n\n  /// Получить длительность субтитра\n  pub fn get_duration(\u0026self) -\u003e f64 {\n    self.end_time - self.start_time\n  }\n}\n\n/// Позиция субтитра на экране\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitlePosition {\n  /// Позиция X в процентах (0-100)\n  pub x: f32,\n  /// Позиция Y в процентах (0-100)  \n  pub y: f32,\n  /// Выравнивание по горизонтали\n  pub align_x: SubtitleAlignX,\n  /// Выравнивание по вертикали\n  pub align_y: SubtitleAlignY,\n  /// Отступы в пикселях\n  pub margin: SubtitleMargin,\n}\n\nimpl Default for SubtitlePosition {\n  fn default() -\u003e Self {\n    Self {\n      x: 50.0, // По центру\n      y: 85.0, // Внизу экрана\n      align_x: SubtitleAlignX::Center,\n      align_y: SubtitleAlignY::Bottom,\n      margin: SubtitleMargin::default(),\n    }\n  }\n}\n\n/// Горизонтальное выравнивание субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleAlignX {\n  /// По левому краю\n  Left,\n  /// По центру\n  Center,\n  /// По правому краю\n  Right,\n}\n\n/// Вертикальное выравнивание субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleAlignY {\n  /// По верхнему краю\n  Top,\n  /// По центру\n  Center,\n  /// По нижнему краю\n  Bottom,\n}\n\n/// Отступы субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitleMargin {\n  /// Отступ сверху в пикселях\n  pub top: f32,\n  /// Отступ справа в пикселях\n  pub right: f32,\n  /// Отступ снизу в пикселях\n  pub bottom: f32,\n  /// Отступ слева в пикселях\n  pub left: f32,\n}\n\nimpl Default for SubtitleMargin {\n  fn default() -\u003e Self {\n    Self {\n      top: 20.0,\n      right: 20.0,\n      bottom: 20.0,\n      left: 20.0,\n    }\n  }\n}\n\n/// Стиль субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitleStyle {\n  /// Название шрифта\n  pub font_family: String,\n  /// Размер шрифта в пикселях\n  pub font_size: f32,\n  /// Толщина шрифта\n  pub font_weight: SubtitleFontWeight,\n  /// Цвет текста (в формате #RRGGBB или #RRGGBBAA)\n  pub color: String,\n  /// Цвет обводки (опционально)\n  pub stroke_color: Option\u003cString\u003e,\n  /// Толщина обводки в пикселях\n  pub stroke_width: f32,\n  /// Цвет тени (опционально)\n  pub shadow_color: Option\u003cString\u003e,\n  /// Смещение тени по X\n  pub shadow_x: f32,\n  /// Смещение тени по Y\n  pub shadow_y: f32,\n  /// Размытие тени\n  pub shadow_blur: f32,\n  /// Цвет фона (опционально)\n  pub background_color: Option\u003cString\u003e,\n  /// Прозрачность фона (0-1)\n  pub background_opacity: f32,\n  /// Отступы текста внутри фона\n  pub padding: SubtitlePadding,\n  /// Радиус скругления фона\n  pub border_radius: f32,\n  /// Межстрочный интервал\n  pub line_height: f32,\n  /// Межбуквенный интервал\n  pub letter_spacing: f32,\n  /// Максимальная ширина в процентах\n  pub max_width: f32,\n}\n\nimpl Default for SubtitleStyle {\n  fn default() -\u003e Self {\n    Self {\n      font_family: \"Arial\".to_string(),\n      font_size: 24.0,\n      font_weight: SubtitleFontWeight::Normal,\n      color: \"#FFFFFF\".to_string(),\n      stroke_color: Some(\"#000000\".to_string()),\n      stroke_width: 2.0,\n      shadow_color: Some(\"#000000\".to_string()),\n      shadow_x: 2.0,\n      shadow_y: 2.0,\n      shadow_blur: 4.0,\n      background_color: None,\n      background_opacity: 0.8,\n      padding: SubtitlePadding::default(),\n      border_radius: 4.0,\n      line_height: 1.2,\n      letter_spacing: 0.0,\n      max_width: 80.0,\n    }\n  }\n}\n\n/// Толщина шрифта субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleFontWeight {\n  /// Тонкий\n  Thin,\n  /// Светлый\n  Light,\n  /// Обычный\n  Normal,\n  /// Средний\n  Medium,\n  /// Жирный\n  Bold,\n  /// Очень жирный\n  Black,\n}\n\n/// Отступы текста внутри фона субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitlePadding {\n  /// Отступ сверху\n  pub top: f32,\n  /// Отступ справа\n  pub right: f32,\n  /// Отступ снизу\n  pub bottom: f32,\n  /// Отступ слева\n  pub left: f32,\n}\n\nimpl Default for SubtitlePadding {\n  fn default() -\u003e Self {\n    Self {\n      top: 8.0,\n      right: 12.0,\n      bottom: 8.0,\n      left: 12.0,\n    }\n  }\n}\n\n/// Анимация субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitleAnimation {\n  /// Уникальный идентификатор анимации\n  pub id: String,\n  /// Тип анимации\n  pub animation_type: SubtitleAnimationType,\n  /// Длительность анимации в секундах\n  pub duration: f64,\n  /// Задержка перед началом анимации\n  pub delay: f64,\n  /// Функция сглаживания\n  pub easing: SubtitleEasing,\n  /// Направление анимации (для движения)\n  pub direction: Option\u003cSubtitleDirection\u003e,\n  /// Дополнительные параметры\n  pub properties: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl SubtitleAnimation {\n  /// Создать новую анимацию субтитра\n  pub fn new(animation_type: SubtitleAnimationType, duration: f64) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      animation_type,\n      duration,\n      delay: 0.0,\n      easing: SubtitleEasing::EaseInOut,\n      direction: None,\n      properties: HashMap::new(),\n    }\n  }\n}\n\n/// Тип анимации субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleAnimationType {\n  /// Появление с изменением прозрачности\n  FadeIn,\n  /// Исчезновение с изменением прозрачности\n  FadeOut,\n  /// Въезд с указанного направления\n  SlideIn,\n  /// Выезд в указанном направлении\n  SlideOut,\n  /// Увеличение от 0 до полного размера\n  ScaleIn,\n  /// Уменьшение до 0\n  ScaleOut,\n  /// Печатающаяся машинка (по буквам)\n  Typewriter,\n  /// Волна (буквы появляются по очереди)\n  Wave,\n  /// Подпрыгивание\n  Bounce,\n  /// Покачивание\n  Shake,\n  /// Мигание\n  Blink,\n  /// Растворение (буквы исчезают случайно)\n  Dissolve,\n}\n\n/// Функция сглаживания анимации субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleEasing {\n  /// Линейная\n  Linear,\n  /// Плавная\n  Ease,\n  /// Плавный вход\n  EaseIn,\n  /// Плавный выход\n  EaseOut,\n  /// Плавный вход и выход\n  EaseInOut,\n  /// Эластичная\n  Elastic,\n  /// Прыжок\n  Bounce,\n}\n\n/// Направление анимации субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleDirection {\n  /// Сверху\n  Top,\n  /// Снизу\n  Bottom,\n  /// Слева\n  Left,\n  /// Справа\n  Right,\n  /// Из центра\n  Center,\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_project_schema_creation() {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    assert_eq!(project.metadata.name, \"Test Project\");\n    assert_eq!(project.version, \"1.0.0\");\n    assert_eq!(project.timeline.fps, 30);\n    assert_eq!(project.timeline.resolution, (1920, 1080));\n  }\n\n  #[test]\n  fn test_track_creation() {\n    let track = Track::new(TrackType::Video, \"Video Track 1\".to_string());\n    assert_eq!(track.track_type, TrackType::Video);\n    assert_eq!(track.name, \"Video Track 1\");\n    assert!(track.enabled);\n    assert_eq!(track.volume, 1.0);\n    assert!(!track.id.is_empty());\n  }\n\n  #[test]\n  fn test_clip_creation() {\n    let clip = Clip::new(PathBuf::from(\"/test/video.mp4\"), 10.0, 5.0);\n    assert_eq!(clip.start_time, 10.0);\n    assert_eq!(clip.end_time, 15.0);\n    assert_eq!(clip.get_timeline_duration(), 5.0);\n    assert_eq!(clip.speed, 1.0);\n    assert!(!clip.id.is_empty());\n  }\n\n  #[test]\n  fn test_effect_creation() {\n    let effect = Effect::new(EffectType::Blur, \"Blur\".to_string());\n    assert_eq!(effect.effect_type, EffectType::Blur);\n    assert_eq!(effect.name, \"Blur\");\n    assert!(effect.enabled);\n    assert!(!effect.id.is_empty());\n  }\n\n  #[test]\n  fn test_project_validation() {\n    let mut project = ProjectSchema::new(\"Test\".to_string());\n\n    // Пустой проект должен быть валидным\n    assert!(project.validate().is_ok());\n\n    // Невалидный FPS\n    project.timeline.fps = 0;\n    assert!(project.validate().is_err());\n\n    // Восстанавливаем валидный FPS\n    project.timeline.fps = 30;\n    assert!(project.validate().is_ok());\n\n    // Невалидное разрешение\n    project.timeline.resolution = (0, 1080);\n    assert!(project.validate().is_err());\n  }\n\n  #[test]\n  fn test_timeline_duration_calculation() {\n    let mut project = ProjectSchema::new(\"Test\".to_string());\n\n    // Добавляем трек с клипом\n    let mut track = Track::new(TrackType::Video, \"Test Track\".to_string());\n    let clip = Clip::new(PathBuf::from(\"/test.mp4\"), 5.0, 10.0);\n    track.clips.push(clip);\n    project.tracks.push(track);\n\n    // Длительность должна быть 15.0 (start_time 5.0 + duration 10.0)\n    assert_eq!(project.get_duration(), 15.0);\n  }\n\n  #[test]\n  fn test_effect_parameter_types() {\n    let mut params = HashMap::new();\n    params.insert(\"intensity\".to_string(), EffectParameter::Float(0.5));\n    params.insert(\"enabled\".to_string(), EffectParameter::Bool(true));\n    params.insert(\n      \"name\".to_string(),\n      EffectParameter::String(\"test\".to_string()),\n    );\n    params.insert(\"color\".to_string(), EffectParameter::Color(0xFF0000FF));\n\n    assert_eq!(params.len(), 4);\n  }\n\n  #[test]\n  fn test_serialization() {\n    let project = ProjectSchema::new(\"Serialization Test\".to_string());\n\n    // Сериализация в JSON\n    let json = serde_json::to_string(\u0026project).unwrap();\n    assert!(json.contains(\"Serialization Test\"));\n\n    // Десериализация из JSON\n    let deserialized: ProjectSchema = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.metadata.name, \"Serialization Test\");\n  }\n\n  #[test]\n  fn test_subtitle_creation() {\n    let subtitle = Subtitle::new(\"Привет мир!\".to_string(), 10.0, 15.0);\n    assert_eq!(subtitle.text, \"Привет мир!\");\n    assert_eq!(subtitle.start_time, 10.0);\n    assert_eq!(subtitle.end_time, 15.0);\n    assert_eq!(subtitle.get_duration(), 5.0);\n    assert!(subtitle.enabled);\n    assert!(!subtitle.id.is_empty());\n  }\n\n  #[test]\n  fn test_subtitle_validation() {\n    // Валидный субтитр\n    let subtitle = Subtitle::new(\"Текст\".to_string(), 0.0, 5.0);\n    assert!(subtitle.validate().is_ok());\n\n    // Пустой текст\n    let mut invalid_subtitle = subtitle.clone();\n    invalid_subtitle.text = \"\".to_string();\n    assert!(invalid_subtitle.validate().is_err());\n\n    // Отрицательное время начала\n    let mut invalid_subtitle = subtitle.clone();\n    invalid_subtitle.start_time = -1.0;\n    assert!(invalid_subtitle.validate().is_err());\n\n    // Время окончания меньше времени начала\n    let mut invalid_subtitle = subtitle.clone();\n    invalid_subtitle.end_time = invalid_subtitle.start_time - 1.0;\n    assert!(invalid_subtitle.validate().is_err());\n  }\n\n  #[test]\n  fn test_subtitle_style_default() {\n    let style = SubtitleStyle::default();\n    assert_eq!(style.font_family, \"Arial\");\n    assert_eq!(style.font_size, 24.0);\n    assert_eq!(style.color, \"#FFFFFF\");\n    assert_eq!(style.stroke_width, 2.0);\n    assert!(style.stroke_color.is_some());\n    assert!(style.shadow_color.is_some());\n  }\n\n  #[test]\n  fn test_subtitle_position_default() {\n    let position = SubtitlePosition::default();\n    assert_eq!(position.x, 50.0); // По центру\n    assert_eq!(position.y, 85.0); // Внизу экрана\n    assert_eq!(position.align_x, SubtitleAlignX::Center);\n    assert_eq!(position.align_y, SubtitleAlignY::Bottom);\n  }\n\n  #[test]\n  fn test_subtitle_animation_creation() {\n    let animation = SubtitleAnimation::new(SubtitleAnimationType::FadeIn, 1.0);\n    assert_eq!(animation.animation_type, SubtitleAnimationType::FadeIn);\n    assert_eq!(animation.duration, 1.0);\n    assert_eq!(animation.delay, 0.0);\n    assert_eq!(animation.easing, SubtitleEasing::EaseInOut);\n    assert!(!animation.id.is_empty());\n  }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":52}},{"line":42,"address":[],"length":0,"stats":{"Line":52}},{"line":43,"address":[],"length":0,"stats":{"Line":52}},{"line":50,"address":[],"length":0,"stats":{"Line":52}},{"line":51,"address":[],"length":0,"stats":{"Line":52}},{"line":52,"address":[],"length":0,"stats":{"Line":52}},{"line":53,"address":[],"length":0,"stats":{"Line":52}},{"line":54,"address":[],"length":0,"stats":{"Line":52}},{"line":55,"address":[],"length":0,"stats":{"Line":52}},{"line":56,"address":[],"length":0,"stats":{"Line":52}},{"line":57,"address":[],"length":0,"stats":{"Line":52}},{"line":58,"address":[],"length":0,"stats":{"Line":52}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":65,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":27}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":9}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":104,"address":[],"length":0,"stats":{"Line":7}},{"line":105,"address":[],"length":0,"stats":{"Line":7}},{"line":106,"address":[],"length":0,"stats":{"Line":7}},{"line":108,"address":[],"length":0,"stats":{"Line":15}},{"line":109,"address":[],"length":0,"stats":{"Line":15}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":52}},{"line":154,"address":[],"length":0,"stats":{"Line":52}},{"line":197,"address":[],"length":0,"stats":{"Line":28}},{"line":199,"address":[],"length":0,"stats":{"Line":28}},{"line":205,"address":[],"length":0,"stats":{"Line":28}},{"line":206,"address":[],"length":0,"stats":{"Line":28}},{"line":207,"address":[],"length":0,"stats":{"Line":28}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":27}},{"line":295,"address":[],"length":0,"stats":{"Line":27}},{"line":298,"address":[],"length":0,"stats":{"Line":27}},{"line":304,"address":[],"length":0,"stats":{"Line":27}},{"line":305,"address":[],"length":0,"stats":{"Line":27}},{"line":309,"address":[],"length":0,"stats":{"Line":27}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":4}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":13}},{"line":353,"address":[],"length":0,"stats":{"Line":13}},{"line":407,"address":[],"length":0,"stats":{"Line":18}},{"line":409,"address":[],"length":0,"stats":{"Line":18}},{"line":414,"address":[],"length":0,"stats":{"Line":18}},{"line":418,"address":[],"length":0,"stats":{"Line":18}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":52}},{"line":1416,"address":[],"length":0,"stats":{"Line":52}},{"line":1447,"address":[],"length":0,"stats":{"Line":52}},{"line":1449,"address":[],"length":0,"stats":{"Line":52}},{"line":1488,"address":[],"length":0,"stats":{"Line":2}},{"line":1490,"address":[],"length":0,"stats":{"Line":2}},{"line":1494,"address":[],"length":0,"stats":{"Line":2}},{"line":1495,"address":[],"length":0,"stats":{"Line":2}},{"line":1497,"address":[],"length":0,"stats":{"Line":2}},{"line":1502,"address":[],"length":0,"stats":{"Line":4}},{"line":1503,"address":[],"length":0,"stats":{"Line":4}},{"line":1504,"address":[],"length":0,"stats":{"Line":1}},{"line":1507,"address":[],"length":0,"stats":{"Line":3}},{"line":1508,"address":[],"length":0,"stats":{"Line":1}},{"line":1511,"address":[],"length":0,"stats":{"Line":2}},{"line":1512,"address":[],"length":0,"stats":{"Line":1}},{"line":1515,"address":[],"length":0,"stats":{"Line":1}},{"line":1519,"address":[],"length":0,"stats":{"Line":1}},{"line":1520,"address":[],"length":0,"stats":{"Line":1}},{"line":1540,"address":[],"length":0,"stats":{"Line":3}},{"line":1546,"address":[],"length":0,"stats":{"Line":3}},{"line":1587,"address":[],"length":0,"stats":{"Line":3}},{"line":1637,"address":[],"length":0,"stats":{"Line":3}},{"line":1639,"address":[],"length":0,"stats":{"Line":3}},{"line":1642,"address":[],"length":0,"stats":{"Line":3}},{"line":1643,"address":[],"length":0,"stats":{"Line":3}},{"line":1645,"address":[],"length":0,"stats":{"Line":3}},{"line":1651,"address":[],"length":0,"stats":{"Line":3}},{"line":1691,"address":[],"length":0,"stats":{"Line":3}},{"line":1722,"address":[],"length":0,"stats":{"Line":1}},{"line":1724,"address":[],"length":0,"stats":{"Line":1}},{"line":1730,"address":[],"length":0,"stats":{"Line":1}}],"covered":95,"coverable":133},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","test_integration.rs"],"content":"//! Интеграционные тесты для Video Compiler\n\n#[cfg(test)]\nmod tests {\n  use crate::video_compiler::{\n    cache::RenderCache,\n    initialize,\n    renderer::VideoRenderer,\n    schema::{Clip, ProjectSchema, Timeline, Track, TrackType},\n    CompilerSettings,\n  };\n  use std::path::PathBuf;\n  use std::sync::Arc;\n  use tokio::sync::{mpsc, RwLock};\n\n  /// Создать тестовый проект с видео клипами\n  fn create_test_project() -\u003e ProjectSchema {\n    let mut project = ProjectSchema::new(\"Test Video Project\".to_string());\n\n    // Настройки timeline\n    project.timeline = Timeline {\n      duration: 10.0,\n      fps: 30,\n      resolution: (1920, 1080),\n      sample_rate: 48000,\n      aspect_ratio: crate::video_compiler::schema::AspectRatio::Ratio16x9,\n    };\n\n    // Создаем видео трек\n    let mut video_track = Track::new(TrackType::Video, \"Main Video\".to_string());\n\n    // Добавляем тестовые клипы (используем существующие медиа файлы из public)\n    // Используем относительные пути от корня проекта\n    let project_root = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n\n    let clip1 = Clip::new(project_root.join(\"public\").join(\"t1.mp4\"), 0.0, 5.0);\n\n    let mut clip2 = Clip::new(project_root.join(\"public\").join(\"t2.mp4\"), 5.0, 5.0);\n    clip2.end_time = 10.0; // Устанавливаем правильное время окончания\n\n    video_track.clips.push(clip1);\n    video_track.clips.push(clip2);\n\n    project.tracks.push(video_track);\n\n    project\n  }\n\n  #[tokio::test]\n  async fn test_full_video_compilation() {\n    // Инициализируем Video Compiler\n    let state = match initialize().await {\n      Ok(state) =\u003e state,\n      Err(e) =\u003e {\n        eprintln!(\"Пропуск теста: Video Compiler не инициализирован: {}\", e);\n        return;\n      }\n    };\n\n    // Создаем тестовый проект\n    let project = create_test_project();\n\n    // Создаем канал для прогресса\n    let (progress_sender, mut progress_receiver) = mpsc::unbounded_channel();\n\n    // Создаем VideoRenderer\n    let mut renderer = match VideoRenderer::new(\n      project.clone(),\n      state.settings.clone(),\n      state.cache_manager.clone(),\n      progress_sender,\n    )\n    .await\n    {\n      Ok(renderer) =\u003e renderer,\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось создать VideoRenderer: {}\", e);\n        return;\n      }\n    };\n\n    // Определяем выходной путь\n    let output_path = std::env::temp_dir()\n      .join(\"timeline-studio-test\")\n      .join(\"test_output.mp4\");\n\n    // Создаем директорию если не существует\n    if let Some(parent) = output_path.parent() {\n      let _ = tokio::fs::create_dir_all(parent).await;\n    }\n\n    // Запускаем рендеринг\n    match renderer.render(\u0026output_path).await {\n      Ok(job_id) =\u003e {\n        println!(\"Рендеринг запущен с job_id: {}\", job_id);\n\n        // Отслеживаем прогресс\n        let mut last_progress = 0u64;\n        while let Some(update) = progress_receiver.recv().await {\n          use crate::video_compiler::progress::ProgressUpdate;\n\n          match update {\n            ProgressUpdate::ProgressChanged { progress, .. } =\u003e {\n              if progress.current_frame \u003e last_progress {\n                println!(\n                  \"Прогресс: {} кадров из {}, стадия: {}\",\n                  progress.current_frame, progress.total_frames, progress.stage\n                );\n                last_progress = progress.current_frame;\n              }\n            }\n            ProgressUpdate::JobCompleted { output_path, .. } =\u003e {\n              println!(\"Рендеринг завершен! Файл: {}\", output_path);\n\n              // Проверяем что файл создан\n              let path = PathBuf::from(\u0026output_path);\n              assert!(path.exists(), \"Выходной файл должен существовать\");\n\n              // Проверяем размер файла\n              let metadata = tokio::fs::metadata(\u0026path).await.unwrap();\n              assert!(metadata.len() \u003e 0, \"Файл не должен быть пустым\");\n\n              println!(\"Размер файла: {} байт\", metadata.len());\n\n              // Очищаем тестовый файл\n              let _ = tokio::fs::remove_file(\u0026path).await;\n              break;\n            }\n            ProgressUpdate::JobFailed { error, .. } =\u003e {\n              panic!(\"Рендеринг не удался: {}\", error);\n            }\n            _ =\u003e {}\n          }\n        }\n      }\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось запустить рендеринг: {}\", e);\n      }\n    }\n  }\n\n  #[tokio::test]\n  async fn test_invalid_project_validation() {\n    // Создаем проект с несуществующими файлами\n    let mut project = ProjectSchema::new(\"Invalid Project\".to_string());\n    let mut track = Track::new(TrackType::Video, \"Invalid Track\".to_string());\n\n    let invalid_clip = Clip::new(PathBuf::from(\"/non/existent/file.mp4\"), 0.0, 5.0);\n\n    track.clips.push(invalid_clip);\n    project.tracks.push(track);\n\n    // Сначала проверяем что проект не валиден\n    let validation_result = project.validate();\n    assert!(validation_result.is_err());\n    assert!(validation_result\n      .unwrap_err()\n      .contains(\"Исходный файл не найден\"));\n\n    // Создаем канал для прогресса\n    let (progress_sender, _) = mpsc::unbounded_channel();\n\n    // Пытаемся создать VideoRenderer\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n\n    let result = VideoRenderer::new(project, settings, cache, progress_sender).await;\n\n    // VideoRenderer должен провалиться на валидации\n    assert!(result.is_err());\n    if let Err(e) = result {\n      println!(\"Ожидаемая ошибка валидации: {}\", e);\n    }\n  }\n\n  #[tokio::test]\n  async fn test_render_cancellation() {\n    // Инициализируем Video Compiler\n    let state = match initialize().await {\n      Ok(state) =\u003e state,\n      Err(e) =\u003e {\n        eprintln!(\"Пропуск теста: Video Compiler не инициализирован: {}\", e);\n        return;\n      }\n    };\n\n    // Создаем простой проект\n    let mut project = ProjectSchema::new(\"Cancellation Test\".to_string());\n    project.timeline.duration = 5.0;\n\n    // Создаем канал для прогресса\n    let (progress_sender, _progress_receiver) = mpsc::unbounded_channel();\n\n    // Создаем VideoRenderer\n    let mut renderer = match VideoRenderer::new(\n      project,\n      state.settings.clone(),\n      state.cache_manager.clone(),\n      progress_sender,\n    )\n    .await\n    {\n      Ok(renderer) =\u003e renderer,\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось создать VideoRenderer: {}\", e);\n        return;\n      }\n    };\n\n    // Запускаем рендеринг\n    let output_path = std::env::temp_dir()\n      .join(\"timeline-studio-test\")\n      .join(\"test_cancel.mp4\");\n\n    let _job_id = match renderer.render(\u0026output_path).await {\n      Ok(id) =\u003e id,\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось запустить рендеринг: {}\", e);\n        return;\n      }\n    };\n\n    // Даем время на старт рендеринга\n    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n    // Отменяем рендеринг\n    assert!(renderer.cancel().await.is_ok());\n\n    // Проверяем, что задача отменена\n    let progress = renderer.get_progress().await;\n    assert!(\n      progress.is_none()\n        || matches!(\n          progress.unwrap().status,\n          crate::video_compiler::progress::RenderStatus::Cancelled\n        )\n    );\n  }\n\n  #[tokio::test]\n  async fn test_multiple_tracks_composition() {\n    // Создаем проект с несколькими треками\n    let mut project = ProjectSchema::new(\"Multi-track Project\".to_string());\n    project.timeline.duration = 10.0;\n\n    let project_root = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n\n    // Видео трек 1\n    let mut video_track1 = Track::new(TrackType::Video, \"Video Track 1\".to_string());\n    video_track1.clips.push(Clip::new(\n      project_root.join(\"public\").join(\"t1.mp4\"),\n      0.0,\n      5.0,\n    ));\n\n    // Видео трек 2 (наложение)\n    let mut video_track2 = Track::new(TrackType::Video, \"Video Track 2\".to_string());\n    let mut overlay_clip = Clip::new(project_root.join(\"public\").join(\"t2.mp4\"), 2.0, 3.0);\n    overlay_clip.end_time = 5.0;\n    video_track2.clips.push(overlay_clip);\n\n    project.tracks.push(video_track1);\n    project.tracks.push(video_track2);\n\n    // Валидация проекта\n    match project.validate() {\n      Ok(_) =\u003e println!(\"Проект с несколькими треками валиден\"),\n      Err(e) =\u003e {\n        eprintln!(\"Ошибка валидации: {}\", e);\n        return;\n      }\n    }\n  }\n\n  #[tokio::test]\n  async fn test_empty_project_handling() {\n    // Создаем пустой проект\n    let project = ProjectSchema::new(\"Empty Project\".to_string());\n\n    // Проверяем, что пустой проект проходит валидацию\n    assert!(project.validate().is_ok());\n\n    // Проверяем, что длительность = 0\n    assert_eq!(project.get_duration(), 0.0);\n  }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_server","mod.rs"],"content":"pub mod server;\npub mod tests;\n\npub use server::{VideoServerState, VideoRegistrationResponse, start_video_server};","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_server","server.rs"],"content":"use std::path::PathBuf;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse std::collections::HashMap;\nuse axum::{\n    Router,\n    routing::get,\n    extract::{Path, Query, State},\n    response::{IntoResponse, Response},\n    http::{StatusCode, header, HeaderMap},\n};\nuse tokio::fs::File;\nuse tokio::io::{AsyncSeekExt, AsyncReadExt};\nuse tokio_util::io::ReaderStream;\nuse serde::Serialize;\nuse tower_http::cors::{CorsLayer, Any};\n\n#[derive(Clone)]\npub struct VideoServerState {\n    // Map video ID to actual file path\n    pub(crate) video_registry: Arc\u003cMutex\u003cHashMap\u003cString, PathBuf\u003e\u003e\u003e,\n}\n\n#[derive(Serialize)]\npub struct VideoRegistrationResponse {\n    pub id: String,\n    pub url: String,\n}\n\nimpl VideoServerState {\n    pub fn new() -\u003e Self {\n        Self {\n            video_registry: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub async fn register_video(\u0026self, path: PathBuf) -\u003e String {\n        // Generate unique ID for video\n        let id = format!(\"{:x}\", md5::compute(path.to_string_lossy().as_bytes()));\n        \n        let mut registry = self.video_registry.lock().await;\n        registry.insert(id.clone(), path);\n        \n        id\n    }\n}\n\npub fn create_video_router(state: VideoServerState) -\u003e Router {\n    Router::new()\n        .route(\"/video/:id\", get(stream_video))\n        .route(\"/register\", get(register_video_endpoint))\n        .route(\"/health\", get(health_check))\n        .layer(\n            CorsLayer::new()\n                .allow_origin(Any)\n                .allow_methods(Any)\n                .allow_headers(Any)\n        )\n        .with_state(state)\n}\n\nasync fn health_check() -\u003e impl IntoResponse {\n    (StatusCode::OK, \"Video server is running\")\n}\n\nasync fn stream_video(\n    Path(id): Path\u003cString\u003e,\n    headers: HeaderMap,\n    State(state): State\u003cVideoServerState\u003e,\n) -\u003e Result\u003cResponse, StatusCode\u003e {\n    let registry = state.video_registry.lock().await;\n    let path = registry.get(\u0026id).ok_or(StatusCode::NOT_FOUND)?;\n    \n    let mut file = File::open(path).await.map_err(|_| StatusCode::NOT_FOUND)?;\n    let metadata = file.metadata().await.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n    let file_size = metadata.len();\n    \n    // Determine content type based on file extension\n    let content_type = match path.extension().and_then(|ext| ext.to_str()) {\n        Some(\"mp4\") =\u003e \"video/mp4\",\n        Some(\"webm\") =\u003e \"video/webm\",\n        Some(\"mov\") =\u003e \"video/quicktime\",\n        Some(\"avi\") =\u003e \"video/x-msvideo\",\n        Some(\"mkv\") =\u003e \"video/x-matroska\",\n        _ =\u003e \"video/mp4\", // default\n    };\n    \n    // Parse Range header\n    if let Some(range_header) = headers.get(header::RANGE) {\n        let range_str = range_header.to_str().map_err(|_| StatusCode::BAD_REQUEST)?;\n        if let Some(range) = parse_range_header(range_str, file_size) {\n            let (start, end) = range;\n            \n            // Seek to start position\n            file.seek(std::io::SeekFrom::Start(start)).await\n                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n            \n            // Create limited reader for the range\n            let limited = file.take(end - start + 1);\n            let stream = ReaderStream::new(limited);\n            \n            return Ok(Response::builder()\n                .status(StatusCode::PARTIAL_CONTENT)\n                .header(header::CONTENT_TYPE, content_type)\n                .header(header::ACCEPT_RANGES, \"bytes\")\n                .header(header::CONTENT_LENGTH, (end - start + 1).to_string())\n                .header(header::CONTENT_RANGE, format!(\"bytes {}-{}/{}\", start, end, file_size))\n                .body(axum::body::Body::from_stream(stream))\n                .unwrap());\n        }\n    }\n    \n    // No range header, return entire file\n    let stream = ReaderStream::new(file);\n    \n    Ok(Response::builder()\n        .status(StatusCode::OK)\n        .header(header::CONTENT_TYPE, content_type)\n        .header(header::ACCEPT_RANGES, \"bytes\")\n        .header(header::CONTENT_LENGTH, file_size.to_string())\n        .body(axum::body::Body::from_stream(stream))\n        .unwrap())\n}\n\npub(crate) fn parse_range_header(range: \u0026str, file_size: u64) -\u003e Option\u003c(u64, u64)\u003e {\n    if let Some(range) = range.strip_prefix(\"bytes=\") {\n        let parts: Vec\u003c\u0026str\u003e = range.split('-').collect();\n        if parts.len() == 2 {\n            let start = parts[0].parse::\u003cu64\u003e().ok()?;\n            let end = if parts[1].is_empty() {\n                file_size - 1\n            } else {\n                parts[1].parse::\u003cu64\u003e().ok()?.min(file_size - 1)\n            };\n            return Some((start, end));\n        }\n    }\n    None\n}\n\nasync fn register_video_endpoint(\n    Query(params): Query\u003cHashMap\u003cString, String\u003e\u003e,\n    State(state): State\u003cVideoServerState\u003e,\n) -\u003e Result\u003cimpl IntoResponse, StatusCode\u003e {\n    let path = params.get(\"path\").ok_or(StatusCode::BAD_REQUEST)?;\n    let path = PathBuf::from(path);\n    \n    if !path.exists() {\n        return Err(StatusCode::NOT_FOUND);\n    }\n    \n    let id = state.register_video(path).await;\n    \n    Ok(axum::Json(VideoRegistrationResponse {\n        id: id.clone(),\n        url: format!(\"http://localhost:4567/video/{}\", id),\n    }))\n}\n\n// Start server function to be called from main.rs\npub async fn start_video_server(state: VideoServerState) {\n    let app = create_video_router(state);\n    \n    match tokio::net::TcpListener::bind(\"127.0.0.1:4567\").await {\n        Ok(listener) =\u003e {\n            log::info!(\"Video server listening on http://localhost:4567\");\n            if let Err(e) = axum::serve(listener, app).await {\n                log::error!(\"Video server error: {}\", e);\n            }\n        }\n        Err(e) =\u003e {\n            log::error!(\"Failed to bind video server: {}\", e);\n        }\n    }\n}","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":8}},{"line":50,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":7}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}}],"covered":56,"coverable":74},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_server","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use super::super::*;\n    use axum::http::{Request, StatusCode};\n    use axum::body::Body;\n    use tower::ServiceExt;\n    use std::path::PathBuf;\n    use tempfile::NamedTempFile;\n    use std::io::Write;\n\n    #[tokio::test]\n    async fn test_video_server_state_new() {\n        let state = VideoServerState::new();\n        let registry = state.video_registry.lock().await;\n        assert!(registry.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_register_video() {\n        let state = VideoServerState::new();\n        let path = PathBuf::from(\"/test/video.mp4\");\n        \n        let id = state.register_video(path.clone()).await;\n        \n        assert!(!id.is_empty());\n        \n        let registry = state.video_registry.lock().await;\n        assert_eq!(registry.get(\u0026id), Some(\u0026path));\n    }\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/health\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[tokio::test]\n    async fn test_register_video_endpoint() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        // Create a temporary file\n        let temp_file = NamedTempFile::new().unwrap();\n        let path = temp_file.path().to_str().unwrap();\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\u0026format!(\"/register?path={}\", urlencoding::encode(path)))\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[tokio::test]\n    async fn test_register_video_endpoint_missing_path() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/register\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    }\n\n    #[tokio::test]\n    async fn test_register_video_endpoint_nonexistent_file() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/register?path=/nonexistent/file.mp4\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[tokio::test]\n    async fn test_stream_video_not_found() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/video/nonexistent\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[tokio::test]\n    async fn test_stream_video_with_range() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state.clone());\n        \n        // Create a temporary file with content\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(b\"test video content\").unwrap();\n        let path = temp_file.path().to_path_buf();\n        \n        // Register the video\n        let id = state.register_video(path).await;\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\u0026format!(\"/video/{}\", id))\n                    .header(\"Range\", \"bytes=0-9\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::PARTIAL_CONTENT);\n        assert_eq!(\n            response.headers().get(\"content-range\").unwrap(),\n            \"bytes 0-9/18\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_parse_range_header() {\n        assert_eq!(\n            server::parse_range_header(\"bytes=0-99\", 1000),\n            Some((0, 99))\n        );\n        \n        assert_eq!(\n            server::parse_range_header(\"bytes=50-\", 1000),\n            Some((50, 999))\n        );\n        \n        assert_eq!(\n            server::parse_range_header(\"invalid\", 1000),\n            None\n        );\n    }\n\n    #[tokio::test]\n    async fn test_video_registration_response_serialization() {\n        let response = VideoRegistrationResponse {\n            id: \"test123\".to_string(),\n            url: \"http://localhost:4567/video/test123\".to_string(),\n        };\n        \n        let json = serde_json::to_string(\u0026response).unwrap();\n        assert!(json.contains(\"test123\"));\n        assert!(json.contains(\"http://localhost:4567/video/test123\"));\n    }\n\n    #[tokio::test]\n    async fn test_cors_headers() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/health\")\n                    .header(\"Origin\", \"http://localhost:3000\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n        // CORS headers should be present due to CorsLayer::new().allow_origin(Any)\n        assert!(response.headers().contains_key(\"access-control-allow-origin\"));\n    }\n}","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","build.rs"],"content":"fn main() {\n  tauri_build::build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","filesystem.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::Path;\n\n/**\n * Структура для статистики файла\n */\n#[derive(Debug, Serialize, Deserialize)]\npub struct FileStats {\n  pub size: u64,\n  #[serde(rename = \"lastModified\")]\n  pub last_modified: u64,\n}\n\n/**\n * Проверяет существование файла\n */\n#[tauri::command]\npub fn file_exists(path: String) -\u003e Result\u003cbool, String\u003e {\n  let file_path = Path::new(\u0026path);\n  Ok(file_path.exists() \u0026\u0026 file_path.is_file())\n}\n\n/**\n * Получает статистику файла (размер и время модификации)\n */\n#[tauri::command]\npub fn get_file_stats(path: String) -\u003e Result\u003cFileStats, String\u003e {\n  let file_path = Path::new(\u0026path);\n\n  if !file_path.exists() {\n    return Err(format!(\"File does not exist: {}\", path));\n  }\n\n  match fs::metadata(file_path) {\n    Ok(metadata) =\u003e {\n      let size = metadata.len();\n\n      // Получаем время модификации в миллисекундах\n      let last_modified = metadata\n        .modified()\n        .map_err(|e| format!(\"Failed to get modification time: {}\", e))?\n        .duration_since(std::time::UNIX_EPOCH)\n        .map_err(|e| format!(\"Failed to convert time: {}\", e))?\n        .as_millis() as u64;\n\n      Ok(FileStats {\n        size,\n        last_modified,\n      })\n    }\n    Err(e) =\u003e Err(format!(\"Failed to get file metadata: {}\", e)),\n  }\n}\n\n/**\n * Получает платформу операционной системы\n */\n#[tauri::command]\npub fn get_platform() -\u003e Result\u003cString, String\u003e {\n  Ok(std::env::consts::OS.to_string())\n}\n\n/**\n * Рекурсивно ищет файлы в директории с заданным именем\n */\n#[tauri::command]\npub fn search_files_by_name(\n  directory: String,\n  filename: String,\n  max_depth: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n  let dir_path = Path::new(\u0026directory);\n\n  if !dir_path.exists() {\n    return Err(format!(\"Directory does not exist: {}\", directory));\n  }\n\n  let mut found_files = Vec::new();\n  let max_depth = max_depth.unwrap_or(5); // По умолчанию максимум 5 уровней\n\n  search_files_recursive(dir_path, \u0026filename, \u0026mut found_files, 0, max_depth)?;\n\n  Ok(found_files)\n}\n\n/**\n * Рекурсивная функция для поиска файлов\n */\nfn search_files_recursive(\n  dir: \u0026Path,\n  target_filename: \u0026str,\n  found_files: \u0026mut Vec\u003cString\u003e,\n  current_depth: u32,\n  max_depth: u32,\n) -\u003e Result\u003c(), String\u003e {\n  if current_depth \u003e= max_depth {\n    return Ok(());\n  }\n\n  match fs::read_dir(dir) {\n    Ok(entries) =\u003e {\n      for entry in entries {\n        match entry {\n          Ok(entry) =\u003e {\n            let entry_path = entry.path();\n\n            if entry_path.is_file() {\n              if let Some(filename) = entry_path.file_name() {\n                if filename == target_filename {\n                  if let Some(path_str) = entry_path.to_str() {\n                    found_files.push(path_str.to_string());\n                  }\n                }\n              }\n            } else if entry_path.is_dir() {\n              // Рекурсивно ищем в поддиректории\n              search_files_recursive(\n                \u0026entry_path,\n                target_filename,\n                found_files,\n                current_depth + 1,\n                max_depth,\n              )?;\n            }\n          }\n          Err(e) =\u003e {\n            eprintln!(\"Error reading directory entry: {}\", e);\n          }\n        }\n      }\n    }\n    Err(e) =\u003e return Err(format!(\"Failed to read directory: {}\", e)),\n  }\n\n  Ok(())\n}\n\n/**\n * Получает абсолютный путь к файлу\n */\n#[tauri::command]\npub fn get_absolute_path(path: String) -\u003e Result\u003cString, String\u003e {\n  let file_path = Path::new(\u0026path);\n\n  match file_path.canonicalize() {\n    Ok(absolute_path) =\u003e {\n      if let Some(path_str) = absolute_path.to_str() {\n        Ok(path_str.to_string())\n      } else {\n        Err(\"Failed to convert path to string\".to_string())\n      }\n    }\n    Err(e) =\u003e Err(format!(\"Failed to get absolute path: {}\", e)),\n  }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::{NamedTempFile, TempDir};\n    use std::fs;\n\n    #[test]\n    fn test_file_exists() {\n        let temp_file = NamedTempFile::new().unwrap();\n        let path = temp_file.path().to_str().unwrap().to_string();\n        \n        let result = file_exists(path.clone());\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n        \n        let result = file_exists(\"/nonexistent/file.txt\".to_string());\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n    }\n\n    #[test]\n    fn test_get_file_stats() {\n        let temp_file = NamedTempFile::new().unwrap();\n        fs::write(temp_file.path(), b\"test content\").unwrap();\n        let path = temp_file.path().to_str().unwrap().to_string();\n        \n        let result = get_file_stats(path);\n        assert!(result.is_ok());\n        \n        let stats = result.unwrap();\n        assert_eq!(stats.size, 12); // \"test content\" is 12 bytes\n        assert!(stats.last_modified \u003e 0);\n    }\n\n    #[test]\n    fn test_get_file_stats_nonexistent() {\n        let result = get_file_stats(\"/nonexistent/file.txt\".to_string());\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"File does not exist\"));\n    }\n\n    #[test]\n    fn test_get_file_stats_directory() {\n        let temp_dir = TempDir::new().unwrap();\n        let path = temp_dir.path().to_str().unwrap().to_string();\n        \n        // get_file_stats actually succeeds for directories since it only checks existence\n        let result = get_file_stats(path);\n        assert!(result.is_ok());\n        let stats = result.unwrap();\n        assert!(stats.last_modified \u003e 0);\n    }\n\n    #[test]\n    fn test_get_platform() {\n        let result = get_platform();\n        assert!(result.is_ok());\n        \n        let platform = result.unwrap();\n        assert!(!platform.is_empty());\n        \n        // Platform should be one of the known values\n        let valid_platforms = vec![\"windows\", \"macos\", \"linux\", \"ios\", \"android\"];\n        assert!(valid_platforms.contains(\u0026platform.as_str()));\n    }\n\n    #[test]\n    fn test_search_files_by_name() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create test files\n        fs::write(temp_dir.path().join(\"test1.txt\"), b\"content\").unwrap();\n        fs::write(temp_dir.path().join(\"test2.txt\"), b\"content\").unwrap();\n        fs::write(temp_dir.path().join(\"other.doc\"), b\"content\").unwrap();\n        \n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"test1.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 1);\n        assert!(files[0].contains(\"test1.txt\"));\n    }\n\n    #[test]\n    fn test_search_files_by_name_with_subdirectories() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create subdirectories\n        let sub_dir = temp_dir.path().join(\"subdir\");\n        fs::create_dir(\u0026sub_dir).unwrap();\n        \n        // Create files in different locations\n        fs::write(temp_dir.path().join(\"target.txt\"), b\"content\").unwrap();\n        fs::write(sub_dir.join(\"target.txt\"), b\"content\").unwrap();\n        \n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"target.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 2);\n    }\n\n    #[test]\n    fn test_search_files_by_name_max_depth() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create nested directories\n        let sub1 = temp_dir.path().join(\"level1\");\n        let sub2 = sub1.join(\"level2\");\n        let sub3 = sub2.join(\"level3\");\n        fs::create_dir_all(\u0026sub3).unwrap();\n        \n        // Create files at different depths\n        fs::write(temp_dir.path().join(\"file.txt\"), b\"content\").unwrap();\n        fs::write(sub1.join(\"file.txt\"), b\"content\").unwrap();\n        fs::write(sub2.join(\"file.txt\"), b\"content\").unwrap();\n        fs::write(sub3.join(\"file.txt\"), b\"content\").unwrap();\n        \n        // Search with max depth of 2\n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"file.txt\".to_string(),\n            Some(2)\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        // Should find files at depth 0 and 1, but not 2 or 3\n        assert_eq!(files.len(), 2);\n    }\n\n    #[test]\n    fn test_search_files_by_name_empty_result() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"nonexistent.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 0);\n    }\n\n    #[test]\n    fn test_search_files_by_name_nonexistent_directory() {\n        let result = search_files_by_name(\n            \"/nonexistent/directory\".to_string(),\n            \"file.txt\".to_string(),\n            None\n        );\n        \n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Directory does not exist\"));\n    }\n\n    #[test]\n    fn test_get_absolute_path() {\n        let temp_file = NamedTempFile::new().unwrap();\n        let path = temp_file.path().to_str().unwrap().to_string();\n        \n        let result = get_absolute_path(path.clone());\n        assert!(result.is_ok());\n        \n        let abs_path = result.unwrap();\n        assert!(abs_path.starts_with('/') || abs_path.contains(':'));\n    }\n\n    #[test]\n    fn test_get_absolute_path_nonexistent() {\n        // get_absolute_path can still work with non-existent files\n        // as long as the parent directory exists\n        let result = get_absolute_path(\"./nonexistent.txt\".to_string());\n        \n        // This might succeed or fail depending on the current directory\n        // If it succeeds, check that it's absolute\n        if let Ok(abs_path) = result {\n            assert!(abs_path.starts_with('/') || abs_path.contains(':'));\n        }\n    }\n\n    #[test]\n    #[cfg(unix)]\n    fn test_search_files_recursive_error_handling() {\n        // Test error handling in recursive search\n        let temp_dir = TempDir::new().unwrap();\n        \n        use std::os::unix::fs::PermissionsExt;\n        \n        // Create a readable file in root\n        fs::write(temp_dir.path().join(\"test.txt\"), b\"content\").unwrap();\n        \n        // Create a directory with restricted permissions\n        let restricted_dir = temp_dir.path().join(\"restricted\");\n        fs::create_dir(\u0026restricted_dir).unwrap();\n        \n        // Create a file inside before restricting\n        fs::write(restricted_dir.join(\"test.txt\"), b\"content\").unwrap();\n        \n        // Now restrict the directory\n        fs::set_permissions(\u0026restricted_dir, fs::Permissions::from_mode(0o000)).unwrap();\n        \n        // Search should find the file in root directory but fail on restricted directory\n        let result = search_files_by_name(\n            temp_dir.path().to_str().unwrap().to_string(),\n            \"test.txt\".to_string(),\n            None\n        );\n        \n        // Clean up permissions before assertions\n        fs::set_permissions(\u0026restricted_dir, fs::Permissions::from_mode(0o755)).unwrap();\n        \n        // The function returns error when it can't read a directory\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Failed to read directory\"));\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":9}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":28}},{"line":104,"address":[],"length":0,"stats":{"Line":11}},{"line":105,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":11}},{"line":108,"address":[],"length":0,"stats":{"Line":11}},{"line":109,"address":[],"length":0,"stats":{"Line":14}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":1}}],"covered":49,"coverable":54},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","language.rs"],"content":"use once_cell::sync::Lazy;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Mutex;\n\n// Поддерживаемые языки\nconst SUPPORTED_LANGUAGES: [\u0026str; 6] = [\"en\", \"ru\", \"es\", \"pt\", \"fr\", \"de\"];\nconst DEFAULT_LANGUAGE: \u0026str = \"en\";\n\n// Глобальное состояние для хранения текущего языка\nstatic APP_LANGUAGE: Lazy\u003cMutex\u003cString\u003e\u003e = Lazy::new(|| Mutex::new(DEFAULT_LANGUAGE.to_string()));\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LanguageResponse {\n  pub language: String,\n  pub system_language: String,\n}\n\n/// Получение системного языка\nfn get_system_language() -\u003e String {\n  // Получаем системную локаль\n  let locale = match sys_locale::get_locale() {\n    Some(loc) =\u003e loc,\n    None =\u003e DEFAULT_LANGUAGE.to_string(),\n  };\n\n  // Извлекаем код языка (первые 2 символа)\n  let lang_code = locale.chars().take(2).collect::\u003cString\u003e().to_lowercase();\n\n  // Проверяем, поддерживается ли язык, иначе возвращаем значение по умолчанию\n  if SUPPORTED_LANGUAGES.contains(\u0026lang_code.as_str()) {\n    lang_code\n  } else {\n    DEFAULT_LANGUAGE.to_string()\n  }\n}\n\n/// Проверка, поддерживается ли язык\nfn is_supported_language(lang: \u0026str) -\u003e bool {\n  SUPPORTED_LANGUAGES.contains(\u0026lang)\n}\n\n/// Получение текущего языка приложения\n#[tauri::command]\npub fn get_app_language() -\u003e LanguageResponse {\n  let system_language = get_system_language();\n  let app_language = APP_LANGUAGE.lock().unwrap().clone();\n\n  LanguageResponse {\n    language: app_language,\n    system_language,\n  }\n}\n\n/// Установка языка приложения\n#[tauri::command]\npub fn set_app_language(lang: String) -\u003e Result\u003cLanguageResponse, String\u003e {\n  // Проверяем, поддерживается ли язык\n  if !is_supported_language(\u0026lang) {\n    return Err(format!(\"Unsupported language: {}\", lang));\n  }\n\n  // Устанавливаем новый язык\n  let mut app_language = APP_LANGUAGE.lock().unwrap();\n  *app_language = lang;\n\n  Ok(LanguageResponse {\n    language: app_language.clone(),\n    system_language: get_system_language(),\n  })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_supported_language() {\n        // Test supported languages\n        assert!(is_supported_language(\"en\"));\n        assert!(is_supported_language(\"ru\"));\n        assert!(is_supported_language(\"es\"));\n        assert!(is_supported_language(\"pt\"));\n        assert!(is_supported_language(\"fr\"));\n        assert!(is_supported_language(\"de\"));\n        \n        // Test unsupported languages\n        assert!(!is_supported_language(\"ja\"));\n        assert!(!is_supported_language(\"ko\"));\n        assert!(!is_supported_language(\"zh\"));\n        assert!(!is_supported_language(\"\"));\n    }\n\n    #[test]\n    fn test_get_system_language() {\n        let lang = get_system_language();\n        // Should return a valid language code\n        assert!(!lang.is_empty());\n        assert!(SUPPORTED_LANGUAGES.contains(\u0026lang.as_str()));\n    }\n\n    #[test]\n    fn test_get_app_language() {\n        let response = get_app_language();\n        // Should return default language initially\n        assert!(!response.language.is_empty());\n        assert!(!response.system_language.is_empty());\n        assert!(is_supported_language(\u0026response.language));\n        assert!(is_supported_language(\u0026response.system_language));\n    }\n\n    #[test]\n    fn test_set_app_language_valid() {\n        // Test setting a valid language\n        let result = set_app_language(\"ru\".to_string());\n        assert!(result.is_ok());\n        \n        let response = result.unwrap();\n        assert_eq!(response.language, \"ru\");\n        assert!(!response.system_language.is_empty());\n        \n        // Verify the language was actually set\n        let current = get_app_language();\n        assert_eq!(current.language, \"ru\");\n        \n        // Reset to default\n        let _ = set_app_language(DEFAULT_LANGUAGE.to_string());\n    }\n\n    #[test]\n    fn test_set_app_language_invalid() {\n        // Test setting an invalid language\n        let result = set_app_language(\"xyz\".to_string());\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Unsupported language\"));\n    }\n\n    #[test]\n    fn test_supported_languages_constant() {\n        // Verify the constant is properly defined\n        assert_eq!(SUPPORTED_LANGUAGES.len(), 6);\n        assert_eq!(DEFAULT_LANGUAGE, \"en\");\n    }\n\n    #[test]\n    fn test_language_response_serialization() {\n        let response = LanguageResponse {\n            language: \"en\".to_string(),\n            system_language: \"en\".to_string(),\n        };\n        \n        let json = serde_json::to_string(\u0026response).unwrap();\n        assert!(json.contains(\"\\\"language\\\":\\\"en\\\"\"));\n        assert!(json.contains(\"\\\"system_language\\\":\\\"en\\\"\"));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":5}},{"line":21,"address":[],"length":0,"stats":{"Line":10}},{"line":22,"address":[],"length":0,"stats":{"Line":5}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":15}},{"line":39,"address":[],"length":0,"stats":{"Line":15}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}}],"covered":20,"coverable":22},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","lib.rs"],"content":"// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n// Модуль для работы с языком\nmod language;\nuse language::{get_app_language, set_app_language};\n\n// Модуль для работы с медиафайлами\nmod media;\nuse media::{get_media_files, get_media_metadata};\n\n// Модуль для работы с файловой системой\nmod filesystem;\n\n// Модуль Video Compiler\nmod video_compiler;\nuse video_compiler::{initialize, PreviewGenerator, VideoCompilerState};\n\n// Модуль Video Server\nmod video_server;\nuse video_server::{VideoServerState, VideoRegistrationResponse};\n\n// Импортируем GPU и Frame Extraction команды\nuse video_compiler::commands::{\n  cancel_render, check_ffmpeg_capabilities, check_hardware_acceleration, clear_frame_cache,\n  clear_prerender_cache, clear_preview_cache, compile_video, extract_recognition_frames,\n  extract_subtitle_frames, extract_timeline_frames, generate_preview, get_active_jobs,\n  get_cache_stats, get_compiler_settings, get_current_gpu_info, get_gpu_capabilities,\n  get_prerender_cache_info, get_render_progress, get_system_info, prerender_segment,\n  set_ffmpeg_path, update_compiler_settings,\n};\n\n#[tauri::command]\nfn greet() -\u003e String {\n  let now = SystemTime::now();\n  let epoch_ms = now.duration_since(UNIX_EPOCH).unwrap().as_millis();\n  format!(\"Hello world from Rust! Current epoch: {}\", epoch_ms)\n}\n\n// Video Compiler Commands (non-duplicate ones only)\n\n#[tauri::command]\nasync fn get_video_info(\n  file_path: String,\n  state: tauri::State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cvideo_compiler::preview::VideoInfo, String\u003e {\n  use std::path::Path;\n\n  let path = Path::new(\u0026file_path);\n  let preview_generator = PreviewGenerator::new(state.cache_manager.clone());\n\n  match preview_generator.get_video_info(path).await {\n    Ok(info) =\u003e Ok(info),\n    Err(e) =\u003e {\n      log::error!(\"Ошибка получения информации о видео: {}\", e);\n      Err(e.to_string())\n    }\n  }\n}\n\n#[tauri::command]\nasync fn clear_all_cache(state: tauri::State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c(), String\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_all().await;\n  log::info!(\"Весь кэш очищен\");\n  Ok(())\n}\n\n#[tauri::command]\nasync fn register_video(\n  path: String,\n  state: tauri::State\u003c'_, VideoServerState\u003e,\n) -\u003e Result\u003cVideoRegistrationResponse, String\u003e {\n  use std::path::PathBuf;\n  \n  let path_buf = PathBuf::from(\u0026path);\n  if !path_buf.exists() {\n    return Err(\"File does not exist\".to_string());\n  }\n  \n  let id = state.register_video(path_buf).await;\n  \n  Ok(VideoRegistrationResponse {\n    id: id.clone(),\n    url: format!(\"http://localhost:4567/video/{}\", id),\n  })\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n  // Инициализация runtime для async операций\n  let runtime = tokio::runtime::Runtime::new().unwrap();\n  \n  // Инициализация Video Compiler state\n  let video_compiler_state = runtime.block_on(async {\n    match initialize().await {\n      Ok(state) =\u003e {\n        log::info!(\"Video Compiler успешно инициализирован\");\n        state\n      }\n      Err(e) =\u003e {\n        log::error!(\"Ошибка инициализации Video Compiler: {}\", e);\n        // Возвращаем состояние по умолчанию, если FFmpeg недоступен\n        VideoCompilerState::default()\n      }\n    }\n  });\n  \n  // Инициализация Video Server\n  let video_server_state = VideoServerState::new();\n  let video_server_state_clone = video_server_state.clone();\n  \n  // Запускаем video server в отдельной задаче\n  runtime.spawn(async move {\n    video_server::start_video_server(video_server_state_clone).await;\n  });\n\n  tauri::Builder::default()\n    .plugin(tauri_plugin_log::Builder::new().build())\n    .plugin(tauri_plugin_notification::init())\n    .plugin(tauri_plugin_global_shortcut::Builder::new().build())\n    .plugin(tauri_plugin_fs::init())\n    .plugin(tauri_plugin_dialog::init())\n    .plugin(tauri_plugin_websocket::init())\n    .plugin(tauri_plugin_opener::init())\n    .plugin(tauri_plugin_store::Builder::default().build())\n    .manage(video_compiler_state)\n    .manage(video_server_state)\n    .invoke_handler(tauri::generate_handler![\n      greet,\n      get_app_language,\n      set_app_language,\n      get_media_metadata,\n      get_media_files,\n      filesystem::file_exists,\n      filesystem::get_file_stats,\n      filesystem::get_platform,\n      filesystem::search_files_by_name,\n      filesystem::get_absolute_path,\n      // Video Server command\n      register_video,\n      // Video Compiler commands\n      compile_video,\n      get_render_progress,\n      generate_preview,\n      prerender_segment,\n      get_prerender_cache_info,\n      clear_prerender_cache,\n      cancel_render,\n      get_active_jobs,\n      get_video_info,\n      clear_preview_cache,\n      get_cache_stats,\n      clear_all_cache,\n      // GPU команды\n      get_gpu_capabilities,\n      get_current_gpu_info,\n      check_hardware_acceleration,\n      get_compiler_settings,\n      update_compiler_settings,\n      set_ffmpeg_path,\n      get_system_info,\n      check_ffmpeg_capabilities,\n      // Frame extraction команды\n      extract_timeline_frames,\n      extract_recognition_frames,\n      extract_subtitle_frames,\n      clear_frame_cache\n    ])\n    .run(tauri::generate_context!())\n    .expect(\"error while running tauri application\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    use std::sync::Arc;\n\n    #[test]\n    fn test_greet() {\n        let result = greet();\n        assert!(result.contains(\"Hello world from Rust!\"));\n        assert!(result.contains(\"Current epoch:\"));\n        \n        // Проверяем, что epoch - это число\n        let parts: Vec\u003c\u0026str\u003e = result.split(\"Current epoch: \").collect();\n        assert_eq!(parts.len(), 2);\n        let epoch_str = parts[1];\n        assert!(epoch_str.parse::\u003cu128\u003e().is_ok());\n    }\n\n    #[test]\n    fn test_epoch_calculation() {\n        let now = SystemTime::now();\n        let epoch_ms = now.duration_since(UNIX_EPOCH).unwrap().as_millis();\n        \n        // Проверяем, что epoch в разумных пределах (после 2020 года)\n        assert!(epoch_ms \u003e 1577836800000); // 1 января 2020\n        assert!(epoch_ms \u003c 2000000000000); // где-то в 2033 году\n    }\n\n    #[test]\n    fn test_imports() {\n        // Проверяем, что все импорты работают\n        // Это в основном проверка компиляции\n        // Просто проверяем, что типы существуют\n        let _ = std::any::type_name::\u003cVideoCompilerState\u003e();\n        let _ = std::any::type_name::\u003cVideoServerState\u003e();\n    }\n\n    #[tokio::test]\n    async fn test_video_compiler_state_creation() {\n        // Тестируем создание VideoCompilerState через команды\n        use video_compiler::commands::VideoCompilerState;\n        \n        let state = VideoCompilerState::new();\n        \n        // Проверяем, что состояние создано корректно\n        assert!(Arc::strong_count(\u0026state.active_jobs) \u003e 0);\n        assert!(Arc::strong_count(\u0026state.cache_manager) \u003e 0);\n        assert!(!state.ffmpeg_path.is_empty());\n        assert!(Arc::strong_count(\u0026state.settings) \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_cache_functionality() {\n        use tokio::sync::RwLock;\n        \n        // Создаем RenderCache\n        let cache = Arc::new(RwLock::new(video_compiler::cache::RenderCache::new()));\n        \n        // Добавляем некоторые данные в кэш\n        {\n            let mut cache_guard = cache.write().await;\n            let _ = cache_guard.store_metadata(\n                \"test_path\".to_string(),\n                video_compiler::cache::MediaMetadata {\n                    file_path: \"test_path\".to_string(),\n                    file_size: 1000000,\n                    modified_time: std::time::SystemTime::now(),\n                    duration: 10.0,\n                    resolution: Some((1920, 1080)),\n                    fps: Some(30.0),\n                    bitrate: Some(5000),\n                    video_codec: Some(\"h264\".to_string()),\n                    audio_codec: Some(\"aac\".to_string()),\n                    cached_at: std::time::SystemTime::now(),\n                }\n            ).await;\n        }\n\n        // Очищаем кэш\n        {\n            let mut cache_guard = cache.write().await;\n            cache_guard.clear_all().await;\n        }\n\n        // Проверяем, что кэш пустой\n        let cache_guard = cache.read().await;\n        let memory_usage = cache_guard.get_memory_usage();\n        // После очистки кэша память должна быть почти полностью освобождена (небольшие структуры могут остаться)\n        assert!(memory_usage.total_mb() \u003c 0.01); // Меньше 10KB\n    }\n\n    #[tokio::test]\n    async fn test_register_video_functionality() {\n        \n        // Создаем временный видео файл\n        let temp_dir = TempDir::new().unwrap();\n        let video_path = temp_dir.path().join(\"test_video.mp4\");\n        std::fs::write(\u0026video_path, b\"fake video content\").unwrap();\n\n        // Создаем VideoServerState и регистрируем видео напрямую\n        let state = VideoServerState::new();\n        let id = state.register_video(video_path.clone()).await;\n        \n        assert!(!id.is_empty());\n        \n        // Проверяем, что файл действительно зарегистрирован\n        let videos = state.video_registry.lock().await;\n        assert!(videos.contains_key(\u0026id));\n        assert_eq!(videos.get(\u0026id).unwrap(), \u0026video_path);\n    }\n\n    #[test]\n    fn test_video_compiler_state_default() {\n        // Проверяем, что VideoCompilerState::default() создается корректно\n        let state = VideoCompilerState::default();\n        \n        // Проверяем, что все поля инициализированы\n        assert!(Arc::strong_count(\u0026state.active_jobs) \u003e 0);\n        assert!(Arc::strong_count(\u0026state.cache_manager) \u003e 0);\n        assert!(!state.ffmpeg_path.is_empty());\n        assert!(Arc::strong_count(\u0026state.settings) \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_initialize_success() {\n        // Тестируем инициализацию video compiler\n        let result = video_compiler::initialize().await;\n        \n        // Результат зависит от наличия FFmpeg в системе\n        // Но функция должна вернуть либо Ok, либо Err, но не паниковать\n        match result {\n            Ok(state) =\u003e {\n                // Проверяем, что состояние создано корректно\n                assert!(Arc::strong_count(\u0026state.cache_manager) \u003e 0);\n                assert!(Arc::strong_count(\u0026state.settings) \u003e 0);\n            }\n            Err(e) =\u003e {\n                // Ошибка ожидается, если FFmpeg не установлен\n                assert!(e.to_string().contains(\"FFmpeg\") || e.to_string().contains(\"ffmpeg\"));\n            }\n        }\n    }\n\n    #[test]\n    fn test_video_server_state_new() {\n        // Проверяем создание VideoServerState\n        let state = VideoServerState::new();\n        \n        // State должен быть создан успешно\n        // Проверяем, что он может быть клонирован\n        let _cloned = state.clone();\n    }\n\n    #[tokio::test]\n    async fn test_start_video_server() {\n        use std::time::Duration;\n        \n        // Создаем VideoServerState\n        let state = VideoServerState::new();\n        \n        // Запускаем сервер в отдельной задаче\n        let server_handle = tokio::spawn(async move {\n            video_server::start_video_server(state).await;\n        });\n        \n        // Даем серверу время запуститься\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        \n        // Проверяем, что сервер доступен\n        let client = reqwest::Client::new();\n        let response = client.get(\"http://localhost:4567/health\")\n            .timeout(Duration::from_secs(1))\n            .send()\n            .await;\n        \n        // Проверяем ответ или timeout (сервер может не запуститься в тестовом окружении)\n        match response {\n            Ok(resp) =\u003e {\n                assert_eq!(resp.status(), 200);\n            }\n            Err(_) =\u003e {\n                // Сервер может не запуститься в тестовом окружении, это нормально\n            }\n        }\n        \n        // Останавливаем сервер\n        server_handle.abort();\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":87},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","main.rs"],"content":"// Prevents additional console window on Windows in release, DO NOT REMOVE!!\r\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\r\n\r\nfn main() {\r\n  timeline_studio_lib::run()\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","ffmpeg.rs"],"content":"// Модуль для работы с FFmpeg\n\nuse std::process::Command;\n\n/// Проверка наличия FFmpeg в системе\npub fn check_ffmpeg() -\u003e Result\u003c(), String\u003e {\n  let output = Command::new(\"ffprobe\").arg(\"-version\").output();\n\n  match output {\n    Ok(_) =\u003e Ok(()),\n    Err(_) =\u003e Err(\"FFmpeg не установлен или не найден в системном пути\".to_string()),\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_check_ffmpeg() {\n    // Тест проверки наличия FFmpeg\n    // Примечание: этот тест может не пройти, если FFmpeg не установлен\n    match check_ffmpeg() {\n      Ok(_) =\u003e println!(\"FFmpeg найден\"),\n      Err(e) =\u003e println!(\"FFmpeg не найден: {}\", e),\n    }\n    // Не делаем assert, так как FFmpeg может быть не установлен в CI\n  }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":5},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","files.rs"],"content":"// Модуль для работы с файлами\n\nuse super::types::SUPPORTED_EXTENSIONS;\nuse std::path::Path;\nuse tauri::command;\n\n/// Получение списка медиафайлов в директории\n#[command]\npub fn get_media_files(directory: String) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n  let path = Path::new(\u0026directory);\n\n  if !path.exists() || !path.is_dir() {\n    return Err(format!(\"Директория не найдена: {}\", directory));\n  }\n\n  let entries = std::fs::read_dir(path).map_err(|e| format!(\"Ошибка чтения директории: {}\", e))?;\n\n  let mut media_files = Vec::new();\n\n  for entry in entries.flatten() {\n    let path = entry.path();\n\n    // Проверяем только файлы\n    if path.is_file() {\n      if let Some(extension) = path.extension().and_then(|e| e.to_str()) {\n        // Проверяем расширение файла\n        let ext = extension.to_lowercase();\n        if SUPPORTED_EXTENSIONS.contains(\u0026ext.as_str()) {\n          if let Some(path_str) = path.to_str() {\n            media_files.push(path_str.to_string());\n          }\n        }\n      }\n    }\n  }\n\n  Ok(media_files)\n}\n\n/// Проверяет, является ли файл медиафайлом по расширению\n#[allow(dead_code)]\npub fn is_media_file(file_path: \u0026str) -\u003e bool {\n  if let Some(extension) = Path::new(file_path).extension().and_then(|e| e.to_str()) {\n    let ext = extension.to_lowercase();\n    SUPPORTED_EXTENSIONS.contains(\u0026ext.as_str())\n  } else {\n    false\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use std::fs;\n  use tempfile::TempDir;\n\n  /// Создает временный тестовый файл\n  fn create_test_file(dir: \u0026TempDir, name: \u0026str, content: \u0026[u8]) -\u003e String {\n    let file_path = dir.path().join(name);\n    fs::write(\u0026file_path, content).expect(\"Failed to write test file\");\n    file_path.to_string_lossy().to_string()\n  }\n\n  /// Создает временную директорию с тестовыми файлами\n  fn create_test_directory() -\u003e TempDir {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp directory\");\n\n    // Создаем тестовые файлы разных типов\n    create_test_file(\u0026temp_dir, \"video.mp4\", b\"fake video content\");\n    create_test_file(\u0026temp_dir, \"audio.mp3\", b\"fake audio content\");\n    create_test_file(\u0026temp_dir, \"image.jpg\", b\"fake image content\");\n    create_test_file(\u0026temp_dir, \"document.txt\", b\"not a media file\");\n\n    temp_dir\n  }\n\n  #[test]\n  fn test_get_media_files_with_valid_directory() {\n    let temp_dir = create_test_directory();\n    let dir_path = temp_dir.path().to_string_lossy().to_string();\n\n    let result = get_media_files(dir_path);\n    assert!(result.is_ok());\n\n    let files = result.unwrap();\n    assert_eq!(files.len(), 3); // video.mp4, audio.mp3, image.jpg\n\n    // Проверяем, что все файлы имеют правильные расширения\n    let extensions: Vec\u003cString\u003e = files\n      .iter()\n      .filter_map(|f| {\n        std::path::Path::new(f)\n          .extension()\n          .and_then(|e| e.to_str())\n          .map(|s| s.to_lowercase())\n      })\n      .collect();\n\n    assert!(extensions.contains(\u0026\"mp4\".to_string()));\n    assert!(extensions.contains(\u0026\"mp3\".to_string()));\n    assert!(extensions.contains(\u0026\"jpg\".to_string()));\n    assert!(!extensions.contains(\u0026\"txt\".to_string()));\n  }\n\n  #[test]\n  fn test_get_media_files_with_invalid_directory() {\n    let result = get_media_files(\"/nonexistent/directory\".to_string());\n    assert!(result.is_err());\n    assert!(result.unwrap_err().contains(\"Директория не найдена\"));\n  }\n\n  #[test]\n  fn test_get_media_files_with_empty_directory() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp directory\");\n    let dir_path = temp_dir.path().to_string_lossy().to_string();\n\n    let result = get_media_files(dir_path);\n    assert!(result.is_ok());\n\n    let files = result.unwrap();\n    assert_eq!(files.len(), 0);\n  }\n\n  #[test]\n  fn test_supported_media_extensions() {\n    // Тестируем, что поддерживаются правильные расширения файлов\n    let temp_dir = TempDir::new().expect(\"Failed to create temp directory\");\n\n    // Создаем файлы с разными расширениями\n    let supported_extensions = [\n      \"mp4\", \"avi\", \"mkv\", \"mov\", \"webm\", // видео\n      \"mp3\", \"wav\", \"ogg\", \"flac\", // аудио\n      \"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", // изображения\n    ];\n\n    let unsupported_extensions = [\"txt\", \"doc\", \"pdf\", \"exe\"];\n\n    // Создаем поддерживаемые файлы\n    for ext in \u0026supported_extensions {\n      create_test_file(\u0026temp_dir, \u0026format!(\"test.{}\", ext), b\"test content\");\n    }\n\n    // Создаем неподдерживаемые файлы\n    for ext in \u0026unsupported_extensions {\n      create_test_file(\u0026temp_dir, \u0026format!(\"test.{}\", ext), b\"test content\");\n    }\n\n    let dir_path = temp_dir.path().to_string_lossy().to_string();\n    let result = get_media_files(dir_path);\n    assert!(result.is_ok());\n\n    let files = result.unwrap();\n    assert_eq!(files.len(), supported_extensions.len());\n\n    // Проверяем, что все найденные файлы имеют поддерживаемые расширения\n    for file in \u0026files {\n      let extension = std::path::Path::new(file)\n        .extension()\n        .and_then(|e| e.to_str())\n        .map(|s| s.to_lowercase())\n        .unwrap_or_default();\n\n      assert!(\n        supported_extensions.contains(\u0026extension.as_str()),\n        \"Неподдерживаемое расширение найдено: {}\",\n        extension\n      );\n    }\n  }\n\n  #[test]\n  fn test_is_media_file() {\n    // Тестируем функцию проверки медиафайлов\n    assert!(is_media_file(\"video.mp4\"));\n    assert!(is_media_file(\"audio.mp3\"));\n    assert!(is_media_file(\"image.jpg\"));\n    assert!(is_media_file(\"VIDEO.MP4\")); // Проверяем регистронезависимость\n\n    assert!(!is_media_file(\"document.txt\"));\n    assert!(!is_media_file(\"archive.zip\"));\n    assert!(!is_media_file(\"no_extension\"));\n  }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":7}},{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":12}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":15}},{"line":20,"address":[],"length":0,"stats":{"Line":27}},{"line":25,"address":[],"length":0,"stats":{"Line":108}},{"line":29,"address":[],"length":0,"stats":{"Line":42}},{"line":42,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":26}},{"line":47,"address":[],"length":0,"stats":{"Line":1}}],"covered":11,"coverable":11},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","metadata","tests.rs"],"content":"use super::*;\nuse tempfile::NamedTempFile;\nuse std::io::Write;\n\n#[test]\nfn test_parse_format_data() {\n    let mut format_data = serde_json::Map::new();\n    format_data.insert(\"duration\".to_string(), serde_json::json!(\"120.5\"));\n    format_data.insert(\"size\".to_string(), serde_json::json!(\"1048576\"));\n    format_data.insert(\"bit_rate\".to_string(), serde_json::json!(\"128000\"));\n    format_data.insert(\"format_name\".to_string(), serde_json::json!(\"mp4\"));\n    \n    let mut ffprobe_format = FfprobeFormat {\n        duration: None,\n        size: None,\n        bit_rate: None,\n        format_name: None,\n    };\n    \n    parse_format_data(\u0026format_data, \u0026mut ffprobe_format);\n    \n    assert_eq!(ffprobe_format.duration, Some(120.5));\n    assert_eq!(ffprobe_format.size, Some(1048576));\n    assert_eq!(ffprobe_format.bit_rate, Some(\"128000\".to_string()));\n    assert_eq!(ffprobe_format.format_name, Some(\"mp4\".to_string()));\n}\n\n#[test]\nfn test_parse_format_data_with_invalid_values() {\n    let mut format_data = serde_json::Map::new();\n    format_data.insert(\"duration\".to_string(), serde_json::json!(\"invalid\"));\n    format_data.insert(\"size\".to_string(), serde_json::json!(\"not a number\"));\n    \n    let mut ffprobe_format = FfprobeFormat {\n        duration: None,\n        size: None,\n        bit_rate: None,\n        format_name: None,\n    };\n    \n    parse_format_data(\u0026format_data, \u0026mut ffprobe_format);\n    \n    // Invalid values should result in None\n    assert_eq!(ffprobe_format.duration, None);\n    assert_eq!(ffprobe_format.size, None);\n}\n\n#[test]\nfn test_parse_stream_data_video() {\n    let stream_json = serde_json::json!({\n        \"index\": 0,\n        \"codec_type\": \"video\",\n        \"codec_name\": \"h264\",\n        \"width\": 1920,\n        \"height\": 1080,\n        \"bit_rate\": \"5000000\",\n        \"r_frame_rate\": \"30/1\",\n        \"display_aspect_ratio\": \"16:9\"\n    });\n\n    let parsed_stream = parse_stream_data(\u0026stream_json, 0);\n\n    assert_eq!(parsed_stream.index, 0);\n    assert_eq!(parsed_stream.codec_type, \"video\");\n    assert_eq!(parsed_stream.codec_name, Some(\"h264\".to_string()));\n    assert_eq!(parsed_stream.width, Some(1920));\n    assert_eq!(parsed_stream.height, Some(1080));\n    assert_eq!(parsed_stream.bit_rate, Some(\"5000000\".to_string()));\n    assert_eq!(parsed_stream.r_frame_rate, Some(\"30/1\".to_string()));\n    assert_eq!(parsed_stream.display_aspect_ratio, Some(\"16:9\".to_string()));\n}\n\n#[test]\nfn test_parse_stream_data_audio() {\n    let stream_json = serde_json::json!({\n        \"index\": 1,\n        \"codec_type\": \"audio\",\n        \"codec_name\": \"aac\",\n        \"sample_rate\": \"48000\",\n        \"channels\": 2,\n        \"bit_rate\": \"128000\"\n    });\n\n    let parsed_stream = parse_stream_data(\u0026stream_json, 1);\n\n    assert_eq!(parsed_stream.index, 1);\n    assert_eq!(parsed_stream.codec_type, \"audio\");\n    assert_eq!(parsed_stream.codec_name, Some(\"aac\".to_string()));\n    assert_eq!(parsed_stream.sample_rate, Some(\"48000\".to_string()));\n    assert_eq!(parsed_stream.channels, Some(2));\n    assert_eq!(parsed_stream.bit_rate, Some(\"128000\".to_string()));\n    assert_eq!(parsed_stream.width, None);\n    assert_eq!(parsed_stream.height, None);\n}\n\n#[test]\nfn test_parse_stream_data_missing_fields() {\n    let stream_json = serde_json::json!({});\n    let parsed_stream = parse_stream_data(\u0026stream_json, 5);\n\n    assert_eq!(parsed_stream.index, 5); // Should use the provided index\n    assert_eq!(parsed_stream.codec_type, \"unknown\");\n    assert_eq!(parsed_stream.codec_name, None);\n    assert_eq!(parsed_stream.width, None);\n    assert_eq!(parsed_stream.height, None);\n}\n\n#[test]\nfn test_extract_creation_time_with_tags() {\n    // Test with creation time\n    let format_with_time = serde_json::json!({\n        \"tags\": {\n            \"creation_time\": \"2023-01-01T00:00:00Z\"\n        }\n    });\n\n    let format_map = format_with_time.as_object();\n    let creation_time = extract_creation_time(format_map);\n    assert_eq!(creation_time, Some(\"2023-01-01T00:00:00Z\".to_string()));\n}\n\n#[test]\nfn test_extract_creation_time_without_tags() {\n    // Test without creation time\n    let format_without_time = serde_json::json!({\n        \"duration\": \"120.5\"\n    });\n\n    let format_map = format_without_time.as_object();\n    let creation_time = extract_creation_time(format_map);\n    assert_eq!(creation_time, None);\n}\n\n#[test]\nfn test_extract_creation_time_none() {\n    let creation_time = extract_creation_time(None);\n    assert_eq!(creation_time, None);\n}\n\n#[test]\nfn test_generate_iso8601_timestamp_format() {\n    let timestamp = generate_iso8601_timestamp();\n\n    // Check format: should be seconds.nanoseconds + Z\n    assert!(timestamp.ends_with('Z'));\n    assert!(timestamp.contains('.'));\n\n    let parts: Vec\u003c\u0026str\u003e = timestamp.split('.').collect();\n    assert_eq!(parts.len(), 2);\n\n    // Check seconds part is a valid number\n    assert!(parts[0].parse::\u003cu64\u003e().is_ok());\n    \n    // Check nanoseconds part (minus the Z) has 9 digits\n    let nanos_part = parts[1].trim_end_matches('Z');\n    assert_eq!(nanos_part.len(), 9);\n    assert!(nanos_part.parse::\u003cu32\u003e().is_ok());\n}\n\n#[test]\nfn test_get_media_metadata_nonexistent_file() {\n    let result = get_media_metadata(\"/nonexistent/file.mp4\".to_string());\n    assert!(result.is_err());\n    assert!(result.unwrap_err().contains(\"Файл не найден\"));\n}\n\n#[test]\nfn test_ffprobe_format_struct() {\n    let format = FfprobeFormat {\n        duration: Some(120.5),\n        size: Some(1024),\n        bit_rate: Some(\"128000\".to_string()),\n        format_name: Some(\"mp4\".to_string()),\n    };\n\n    // Test serialization\n    let json = serde_json::to_string(\u0026format).unwrap();\n    assert!(json.contains(\"120.5\"));\n    assert!(json.contains(\"1024\"));\n    assert!(json.contains(\"128000\"));\n    assert!(json.contains(\"mp4\"));\n\n    // Test deserialization\n    let deserialized: FfprobeFormat = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.duration, format.duration);\n    assert_eq!(deserialized.size, format.size);\n    assert_eq!(deserialized.bit_rate, format.bit_rate);\n    assert_eq!(deserialized.format_name, format.format_name);\n}\n\n#[test]\nfn test_ffprobe_stream_struct() {\n    let stream = FfprobeStream {\n        index: 0,\n        codec_type: \"video\".to_string(),\n        codec_name: Some(\"h264\".to_string()),\n        width: Some(1920),\n        height: Some(1080),\n        bit_rate: Some(\"5000000\".to_string()),\n        r_frame_rate: Some(\"30/1\".to_string()),\n        sample_rate: None,\n        channels: None,\n        display_aspect_ratio: Some(\"16:9\".to_string()),\n    };\n\n    // Test serialization\n    let json = serde_json::to_string(\u0026stream).unwrap();\n    assert!(json.contains(\"\\\"index\\\":0\"));\n    assert!(json.contains(\"\\\"codec_type\\\":\\\"video\\\"\"));\n    assert!(json.contains(\"\\\"width\\\":1920\"));\n\n    // Test deserialization\n    let deserialized: FfprobeStream = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.index, stream.index);\n    assert_eq!(deserialized.codec_type, stream.codec_type);\n    assert_eq!(deserialized.width, stream.width);\n}\n\n#[test]\nfn test_probe_data_struct() {\n    let probe_data = ProbeData {\n        streams: vec![\n            FfprobeStream {\n                index: 0,\n                codec_type: \"video\".to_string(),\n                codec_name: Some(\"h264\".to_string()),\n                width: Some(1920),\n                height: Some(1080),\n                bit_rate: None,\n                r_frame_rate: None,\n                sample_rate: None,\n                channels: None,\n                display_aspect_ratio: None,\n            },\n        ],\n        format: FfprobeFormat {\n            duration: Some(60.0),\n            size: Some(1048576),\n            bit_rate: None,\n            format_name: Some(\"mp4\".to_string()),\n        },\n    };\n\n    let json = serde_json::to_string(\u0026probe_data).unwrap();\n    assert!(json.contains(\"streams\"));\n    assert!(json.contains(\"format\"));\n\n    let deserialized: ProbeData = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.streams.len(), 1);\n    assert_eq!(deserialized.format.duration, Some(60.0));\n}\n\n#[test]\nfn test_media_file_struct() {\n    let media_file = MediaFile {\n        id: \"test-id\".to_string(),\n        name: \"test.mp4\".to_string(),\n        path: \"/path/to/test.mp4\".to_string(),\n        is_video: true,\n        is_audio: false,\n        is_image: false,\n        size: 1048576,\n        duration: Some(60.0),\n        start_time: 1234567890,\n        creation_time: \"2023-01-01T00:00:00Z\".to_string(),\n        probe_data: ProbeData {\n            streams: vec![],\n            format: FfprobeFormat {\n                duration: Some(60.0),\n                size: Some(1048576),\n                bit_rate: None,\n                format_name: None,\n            },\n        },\n    };\n\n    let json = serde_json::to_string(\u0026media_file).unwrap();\n    assert!(json.contains(\"test-id\"));\n    assert!(json.contains(\"test.mp4\"));\n    assert!(json.contains(\"is_video\"));\n\n    let deserialized: MediaFile = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.id, media_file.id);\n    assert_eq!(deserialized.is_video, true);\n    assert_eq!(deserialized.is_audio, false);\n}\n\n#[test]\nfn test_media_type_detection_video() {\n    // Test video file detection\n    let streams_array = vec![\n        serde_json::json!({\n            \"codec_type\": \"video\",\n            \"codec_name\": \"h264\"\n        })\n    ];\n    \n    let mut is_video = false;\n    let mut is_audio = false;\n    let mut is_image = false;\n\n    for stream in \u0026streams_array {\n        let codec_type = stream.get(\"codec_type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        \n        if codec_type == \"video\" \u0026\u0026 \n           stream.get(\"disposition\")\n                 .and_then(|d| d.get(\"attached_pic\"))\n                 .and_then(|v| v.as_i64()) != Some(1) {\n            is_video = true;\n        } else if codec_type == \"audio\" {\n            is_audio = true;\n        }\n    }\n\n    assert!(is_video);\n    assert!(!is_audio);\n    assert!(!is_image);\n}\n\n#[test]\nfn test_media_type_detection_audio() {\n    let streams_array = vec![\n        serde_json::json!({\n            \"codec_type\": \"audio\",\n            \"codec_name\": \"aac\"\n        })\n    ];\n    \n    let mut is_video = false;\n    let mut is_audio = false;\n\n    for stream in \u0026streams_array {\n        let codec_type = stream.get(\"codec_type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        \n        if codec_type == \"audio\" {\n            is_audio = true;\n        }\n    }\n\n    assert!(!is_video);\n    assert!(is_audio);\n}\n\n#[test]\nfn test_media_type_detection_image() {\n    // Image detection: no video/audio streams but has width/height\n    let streams_array = vec![\n        serde_json::json!({\n            \"codec_type\": \"video\",\n            \"codec_name\": \"mjpeg\",\n            \"width\": 1920,\n            \"height\": 1080,\n            \"disposition\": {\n                \"attached_pic\": 1\n            }\n        })\n    ];\n    \n    let mut is_video = false;\n    let mut is_audio = false;\n    let mut is_image = false;\n\n    for stream in \u0026streams_array {\n        let codec_type = stream.get(\"codec_type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        \n        if codec_type == \"video\" \u0026\u0026 \n           stream.get(\"disposition\")\n                 .and_then(|d| d.get(\"attached_pic\"))\n                 .and_then(|v| v.as_i64()) == Some(1) {\n            // This is an attached picture, not a video stream\n            is_image = true;\n        }\n    }\n\n    assert!(!is_video);\n    assert!(!is_audio);\n    assert!(is_image);\n}\n\n#[test]\nfn test_parse_format_data_empty() {\n    let format_data = serde_json::Map::new();\n    let mut ffprobe_format = FfprobeFormat {\n        duration: None,\n        size: None,\n        bit_rate: None,\n        format_name: None,\n    };\n    \n    parse_format_data(\u0026format_data, \u0026mut ffprobe_format);\n    \n    assert_eq!(ffprobe_format.duration, None);\n    assert_eq!(ffprobe_format.size, None);\n    assert_eq!(ffprobe_format.bit_rate, None);\n    assert_eq!(ffprobe_format.format_name, None);\n}\n\n#[test]\nfn test_parse_stream_data_with_index_override() {\n    let stream_json = serde_json::json!({\n        \"index\": 10,\n        \"codec_type\": \"video\"\n    });\n\n    let parsed_stream = parse_stream_data(\u0026stream_json, 99);\n\n    // Should use the index from JSON, not the parameter\n    assert_eq!(parsed_stream.index, 10);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","metadata.rs"],"content":"// Модуль для получения метаданных медиафайлов\n\nuse std::path::Path;\nuse std::process::Command;\nuse std::str;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse tauri::command;\n\nuse super::ffmpeg::check_ffmpeg;\nuse super::types::{FfprobeFormat, FfprobeStream, MediaFile, ProbeData};\n\n/// Получение метаданных медиафайла с помощью FFmpeg\n#[command]\npub fn get_media_metadata(file_path: String) -\u003e Result\u003cMediaFile, String\u003e {\n  // Проверяем наличие FFmpeg\n  check_ffmpeg()?;\n\n  // Проверяем существование файла\n  if !Path::new(\u0026file_path).exists() {\n    return Err(format!(\"Файл не найден: {}\", file_path));\n  }\n\n  // Получаем информацию о файле в формате JSON\n  let output = Command::new(\"ffprobe\")\n    .args([\n      \"-v\",\n      \"quiet\",\n      \"-print_format\",\n      \"json\",\n      \"-show_format\",\n      \"-show_streams\",\n      \u0026file_path,\n    ])\n    .output()\n    .map_err(|e| format!(\"Ошибка выполнения ffprobe: {}\", e))?;\n\n  let output_str =\n    str::from_utf8(\u0026output.stdout).map_err(|e| format!(\"Ошибка декодирования вывода: {}\", e))?;\n\n  // Парсим JSON\n  let probe_data: serde_json::Value =\n    serde_json::from_str(output_str).map_err(|e| format!(\"Ошибка парсинга JSON: {}\", e))?;\n\n  // Получаем имя файла из пути\n  let file_name = Path::new(\u0026file_path)\n    .file_name()\n    .and_then(|name| name.to_str())\n    .unwrap_or(\"unknown\")\n    .to_string();\n\n  // Определяем тип медиафайла\n  let streams = probe_data[\"streams\"].as_array();\n  let format = probe_data[\"format\"].as_object();\n\n  // Флаги для типа файла\n  let mut is_video = false;\n  let mut is_audio = false;\n  let mut is_image = false;\n\n  // Создаем структуры для потоков и формата\n  let mut ffprobe_streams: Vec\u003cFfprobeStream\u003e = Vec::new();\n  let mut ffprobe_format = FfprobeFormat {\n    duration: None,\n    size: None,\n    bit_rate: None,\n    format_name: None,\n  };\n\n  if let (Some(streams_array), Some(format_obj)) = (streams, format) {\n    // Заполняем информацию о формате\n    parse_format_data(format_obj, \u0026mut ffprobe_format);\n\n    // Обрабатываем потоки\n    for (i, stream) in streams_array.iter().enumerate() {\n      let parsed_stream = parse_stream_data(stream, i);\n\n      // Определяем тип файла\n      if parsed_stream.codec_type == \"video\"\n        \u0026\u0026 stream\n          .get(\"disposition\")\n          .and_then(|d| d.get(\"attached_pic\"))\n          .and_then(|v| v.as_i64())\n          != Some(1)\n      {\n        is_video = true;\n      } else if parsed_stream.codec_type == \"audio\" {\n        is_audio = true;\n      }\n\n      ffprobe_streams.push(parsed_stream);\n    }\n\n    // Если нет видео и аудио, но есть размеры, считаем изображением\n    if !is_video \u0026\u0026 !is_audio \u0026\u0026 !ffprobe_streams.is_empty() {\n      if let (Some(_width), Some(_height)) = (ffprobe_streams[0].width, ffprobe_streams[0].height) {\n        is_image = true;\n      }\n    }\n  }\n\n  // Определяем время создания\n  let creation_time = extract_creation_time(format);\n\n  // Получаем текущее время в формате ISO 8601\n  let now = SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap_or_default()\n    .as_secs();\n\n  // Создаем структуру MediaFile\n  let media_file = MediaFile {\n    id: file_path.clone(),\n    name: file_name,\n    path: file_path,\n    is_video,\n    is_audio,\n    is_image,\n    size: ffprobe_format.size.unwrap_or(0),\n    duration: ffprobe_format.duration,\n    start_time: now,\n    creation_time: creation_time.unwrap_or_else(generate_iso8601_timestamp),\n    probe_data: ProbeData {\n      streams: ffprobe_streams,\n      format: ffprobe_format,\n    },\n  };\n\n  Ok(media_file)\n}\n\n/// Парсит данные формата из JSON\nfn parse_format_data(\n  format_obj: \u0026serde_json::Map\u003cString, serde_json::Value\u003e,\n  ffprobe_format: \u0026mut FfprobeFormat,\n) {\n  ffprobe_format.duration = format_obj\n    .get(\"duration\")\n    .and_then(|v| v.as_str())\n    .and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n  ffprobe_format.size = format_obj\n    .get(\"size\")\n    .and_then(|v| v.as_str())\n    .and_then(|s| s.parse::\u003cu64\u003e().ok());\n\n  ffprobe_format.bit_rate = format_obj\n    .get(\"bit_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  ffprobe_format.format_name = format_obj\n    .get(\"format_name\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n}\n\n/// Парсит данные потока из JSON\nfn parse_stream_data(stream: \u0026serde_json::Value, index: usize) -\u003e FfprobeStream {\n  let stream_index = stream\n    .get(\"index\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u32)\n    .unwrap_or(index as u32);\n\n  let codec_type = stream\n    .get(\"codec_type\")\n    .and_then(|v| v.as_str())\n    .unwrap_or(\"unknown\")\n    .to_string();\n\n  let codec_name = stream\n    .get(\"codec_name\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let width = stream\n    .get(\"width\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u32);\n\n  let height = stream\n    .get(\"height\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u32);\n\n  let bit_rate = stream\n    .get(\"bit_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let r_frame_rate = stream\n    .get(\"r_frame_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let sample_rate = stream\n    .get(\"sample_rate\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  let channels = stream\n    .get(\"channels\")\n    .and_then(|v| v.as_u64())\n    .map(|v| v as u8);\n\n  let display_aspect_ratio = stream\n    .get(\"display_aspect_ratio\")\n    .and_then(|v| v.as_str())\n    .map(String::from);\n\n  FfprobeStream {\n    index: stream_index,\n    codec_type,\n    codec_name,\n    width,\n    height,\n    bit_rate,\n    r_frame_rate,\n    sample_rate,\n    channels,\n    display_aspect_ratio,\n  }\n}\n\n/// Извлекает время создания из метаданных формата\nfn extract_creation_time(\n  format: Option\u003c\u0026serde_json::Map\u003cString, serde_json::Value\u003e\u003e,\n) -\u003e Option\u003cString\u003e {\n  format?\n    .get(\"tags\")\n    .and_then(|tags| tags.get(\"creation_time\"))\n    .and_then(|v| v.as_str())\n    .map(String::from)\n}\n\n/// Генерирует текущее время в формате ISO 8601\nfn generate_iso8601_timestamp() -\u003e String {\n  let now = SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap_or_default();\n\n  let secs = now.as_secs();\n  let nanos = now.subsec_nanos();\n\n  format!(\"{}.{:09}Z\", secs, nanos)\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":8}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":7}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":11}},{"line":162,"address":[],"length":0,"stats":{"Line":11}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":9}},{"line":179,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":9}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":9}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":9}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":9}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":3}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}}],"covered":62,"coverable":89},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","mod.rs"],"content":"// Модуль для работы с медиафайлами\n// Экспортируем публичные типы и функции\n\npub mod ffmpeg;\npub mod files;\npub mod metadata;\npub mod types;\n\n// Реэкспортируем основные типы для удобства использования\npub use files::get_media_files;\npub use metadata::get_media_metadata;\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::{get_media_files, get_media_metadata};\n    use crate::media::types::{MediaFile, ProbeData};\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_get_media_metadata_mp4() {\n        // This test requires FFprobe to be installed\n        if std::process::Command::new(\"ffprobe\")\n            .arg(\"-version\")\n            .output()\n            .is_err()\n        {\n            eprintln!(\"Skipping test: ffprobe not found\");\n            return;\n        }\n\n        // Create a mock video file path\n        let result = get_media_metadata(\"/nonexistent/video.mp4\".to_string());\n        \n        // Should handle non-existent file gracefully\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Файл не найден\"));\n    }\n\n    #[test]\n    fn test_get_media_files_empty_directory() {\n        let temp_dir = TempDir::new().unwrap();\n        let result = get_media_files(temp_dir.path().to_str().unwrap().to_string());\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), 0);\n    }\n\n    #[test]\n    fn test_get_media_files_with_video_files() {\n        let temp_dir = TempDir::new().unwrap();\n        \n        // Create some test files\n        let video_extensions = vec![\"mp4\", \"avi\", \"mkv\", \"mov\"];\n        for ext in \u0026video_extensions {\n            let file_path = temp_dir.path().join(format!(\"test.{}\", ext));\n            std::fs::write(\u0026file_path, b\"dummy content\").unwrap();\n        }\n        \n        // Create a non-video file that should be ignored\n        let txt_file = temp_dir.path().join(\"readme.txt\");\n        std::fs::write(\u0026txt_file, b\"text content\").unwrap();\n        \n        let result = get_media_files(temp_dir.path().to_str().unwrap().to_string());\n        \n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(files.len(), video_extensions.len());\n        \n        // Check that all files have video extensions\n        for file in \u0026files {\n            let has_video_ext = video_extensions.iter().any(|ext| file.ends_with(ext));\n            assert!(has_video_ext);\n        }\n    }\n\n    #[test]\n    fn test_get_media_files_nonexistent_directory() {\n        let result = get_media_files(\"/nonexistent/directory\".to_string());\n        \n        // Should return error\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Директория не найдена\"));\n    }\n\n    #[test]\n    fn test_media_file_structure() {\n        use crate::media::types::{FfprobeFormat, FfprobeStream};\n        \n        // Test the MediaFile structure serialization  \n        let media_file = MediaFile {\n            id: \"test-id\".to_string(),\n            path: \"/test/video.mp4\".to_string(),\n            name: \"video.mp4\".to_string(),\n            size: 1024,\n            duration: Some(60.0),\n            is_video: true,\n            is_audio: false,\n            is_image: false,\n            start_time: 0,\n            creation_time: \"2023-01-01T00:00:00Z\".to_string(),\n            probe_data: ProbeData {\n                streams: vec![\n                    FfprobeStream {\n                        index: 0,\n                        codec_type: \"video\".to_string(),\n                        codec_name: Some(\"h264\".to_string()),\n                        width: Some(1920),\n                        height: Some(1080),\n                        bit_rate: Some(\"5000000\".to_string()),\n                        r_frame_rate: Some(\"30/1\".to_string()),\n                        sample_rate: None,\n                        channels: None,\n                        display_aspect_ratio: Some(\"16:9\".to_string()),\n                    }\n                ],\n                format: FfprobeFormat {\n                    duration: Some(60.0),\n                    size: Some(1024),\n                    bit_rate: Some(\"5000000\".to_string()),\n                    format_name: Some(\"mov,mp4,m4a,3gp,3g2,mj2\".to_string()),\n                },\n            },\n        };\n        \n        let json = serde_json::to_string(\u0026media_file).unwrap();\n        assert!(json.contains(\"\\\"path\\\"\"));\n        assert!(json.contains(\"\\\"probe_data\\\"\"));\n        assert!(json.contains(\"\\\"is_video\\\":true\"));\n    }\n\n    #[test]\n    fn test_supported_extensions() {\n        use crate::media::types::SUPPORTED_EXTENSIONS;\n        \n        // Test that common video extensions are supported\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mp4\"));\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"avi\"));\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mkv\"));\n        assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mov\"));\n        \n        // Test that non-video extensions are not supported\n        assert!(!SUPPORTED_EXTENSIONS.contains(\u0026\"txt\"));\n        assert!(!SUPPORTED_EXTENSIONS.contains(\u0026\"doc\"));\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","media","types.rs"],"content":"// Типы данных для работы с медиафайлами\n\nuse serde::{Deserialize, Serialize};\n\n/// Структура для хранения метаданных видео\n#[derive(Debug, Serialize, Deserialize)]\npub struct VideoMetadata {\n  pub duration: Option\u003cf64\u003e,\n  pub width: Option\u003cu32\u003e,\n  pub height: Option\u003cu32\u003e,\n  pub fps: Option\u003cf64\u003e,\n  pub codec: Option\u003cString\u003e,\n  pub bitrate: Option\u003cu64\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub creation_time: Option\u003cString\u003e,\n}\n\n/// Структура для хранения метаданных аудио\n#[derive(Debug, Serialize, Deserialize)]\npub struct AudioMetadata {\n  pub duration: Option\u003cf64\u003e,\n  pub codec: Option\u003cString\u003e,\n  pub bitrate: Option\u003cu64\u003e,\n  pub sample_rate: Option\u003cu32\u003e,\n  pub channels: Option\u003cu8\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub creation_time: Option\u003cString\u003e,\n}\n\n/// Структура для хранения метаданных изображения\n#[derive(Debug, Serialize, Deserialize)]\npub struct ImageMetadata {\n  pub width: Option\u003cu32\u003e,\n  pub height: Option\u003cu32\u003e,\n  pub format: Option\u003cString\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub creation_time: Option\u003cString\u003e,\n}\n\n/// Перечисление для типов медиафайлов\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum MediaMetadata {\n  Video(VideoMetadata),\n  Audio(AudioMetadata),\n  Image(ImageMetadata),\n  Unknown,\n}\n\n/// Структура для потока в формате FFprobe\n#[derive(Debug, Serialize, Deserialize)]\npub struct FfprobeStream {\n  pub index: u32,\n  pub codec_type: String,\n  pub codec_name: Option\u003cString\u003e,\n  pub width: Option\u003cu32\u003e,\n  pub height: Option\u003cu32\u003e,\n  pub bit_rate: Option\u003cString\u003e,\n  pub r_frame_rate: Option\u003cString\u003e,\n  pub sample_rate: Option\u003cString\u003e,\n  pub channels: Option\u003cu8\u003e,\n  pub display_aspect_ratio: Option\u003cString\u003e,\n}\n\n/// Структура для формата в формате FFprobe\n#[derive(Debug, Serialize, Deserialize)]\npub struct FfprobeFormat {\n  pub duration: Option\u003cf64\u003e,\n  pub size: Option\u003cu64\u003e,\n  pub bit_rate: Option\u003cString\u003e,\n  pub format_name: Option\u003cString\u003e,\n}\n\n/// Структура для хранения данных FFprobe\n#[derive(Debug, Serialize, Deserialize)]\npub struct ProbeData {\n  pub streams: Vec\u003cFfprobeStream\u003e,\n  pub format: FfprobeFormat,\n}\n\n/// Структура для медиафайла\n#[derive(Debug, Serialize, Deserialize)]\npub struct MediaFile {\n  pub id: String,\n  pub name: String,\n  pub path: String,\n  pub is_video: bool,\n  pub is_audio: bool,\n  pub is_image: bool,\n  pub size: u64,\n  pub duration: Option\u003cf64\u003e,\n  pub start_time: u64,\n  pub creation_time: String,\n  pub probe_data: ProbeData,\n}\n\n/// Поддерживаемые расширения медиафайлов\npub const SUPPORTED_EXTENSIONS: \u0026[\u0026str] = \u0026[\n  // Видео\n  \"mp4\", \"avi\", \"mkv\", \"mov\", \"webm\", // Аудио\n  \"mp3\", \"wav\", \"ogg\", \"flac\", // Изображения\n  \"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\",\n];\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_media_file_structure_serialization() {\n    // Тестируем сериализацию/десериализацию структур\n    let stream = FfprobeStream {\n      index: 0,\n      codec_type: \"video\".to_string(),\n      codec_name: Some(\"h264\".to_string()),\n      width: Some(1920),\n      height: Some(1080),\n      bit_rate: Some(\"5000000\".to_string()),\n      r_frame_rate: Some(\"30/1\".to_string()),\n      sample_rate: None,\n      channels: None,\n      display_aspect_ratio: Some(\"16:9\".to_string()),\n    };\n\n    let format = FfprobeFormat {\n      duration: Some(120.5),\n      size: Some(1024000),\n      bit_rate: Some(\"5000000\".to_string()),\n      format_name: Some(\"mov,mp4,m4a,3gp,3g2,mj2\".to_string()),\n    };\n\n    let probe_data = ProbeData {\n      streams: vec![stream],\n      format,\n    };\n\n    let media_file = MediaFile {\n      id: \"test_id\".to_string(),\n      name: \"test.mp4\".to_string(),\n      path: \"/path/to/test.mp4\".to_string(),\n      is_video: true,\n      is_audio: false,\n      is_image: false,\n      size: 1024000,\n      duration: Some(120.5),\n      start_time: 1234567890,\n      creation_time: \"2023-01-01T00:00:00Z\".to_string(),\n      probe_data,\n    };\n\n    // Тестируем сериализацию в JSON\n    let json = serde_json::to_string(\u0026media_file);\n    assert!(json.is_ok());\n\n    // Тестируем десериализацию из JSON\n    let json_str = json.unwrap();\n    let deserialized: Result\u003cMediaFile, _\u003e = serde_json::from_str(\u0026json_str);\n    assert!(deserialized.is_ok());\n\n    let deserialized_file = deserialized.unwrap();\n    assert_eq!(deserialized_file.name, \"test.mp4\");\n    assert!(deserialized_file.is_video);\n    assert_eq!(deserialized_file.probe_data.streams.len(), 1);\n    assert_eq!(deserialized_file.probe_data.streams[0].codec_type, \"video\");\n  }\n\n  #[test]\n  fn test_media_metadata_enum() {\n    // Тестируем перечисление MediaMetadata\n    let video_metadata = VideoMetadata {\n      duration: Some(120.0),\n      width: Some(1920),\n      height: Some(1080),\n      fps: Some(30.0),\n      codec: Some(\"h264\".to_string()),\n      bitrate: Some(5000000),\n      size: Some(1024000),\n      creation_time: Some(\"2023-01-01T00:00:00Z\".to_string()),\n    };\n\n    let media_metadata = MediaMetadata::Video(video_metadata);\n\n    // Тестируем сериализацию\n    let json = serde_json::to_string(\u0026media_metadata);\n    assert!(json.is_ok());\n\n    // Проверяем, что JSON содержит тег типа\n    let json_str = json.unwrap();\n    assert!(json_str.contains(\"\\\"type\\\":\\\"Video\\\"\"));\n  }\n\n  #[test]\n  fn test_supported_extensions() {\n    // Проверяем, что константа содержит ожидаемые расширения\n    assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mp4\"));\n    assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"mp3\"));\n    assert!(SUPPORTED_EXTENSIONS.contains(\u0026\"jpg\"));\n    assert!(!SUPPORTED_EXTENSIONS.contains(\u0026\"txt\"));\n  }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","cache","tests.rs"],"content":"//! Тесты для модуля кэширования Video Compiler\n\nuse super::*;\nuse std::time::Duration;\n\n#[tokio::test]\nasync fn test_cache_creation() {\n  let cache = RenderCache::new();\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 0);\n  assert_eq!(stats.metadata_requests, 0);\n  assert_eq!(stats.render_requests, 0);\n}\n\n#[tokio::test]\nasync fn test_cache_with_custom_settings() {\n  let settings = CacheSettings {\n    max_preview_entries: 50,\n    max_metadata_entries: 25,\n    max_render_entries: 10,\n    max_memory_mb: 256,\n    preview_ttl: Duration::from_secs(1800),\n    metadata_ttl: Duration::from_secs(900),\n    render_ttl: Duration::from_secs(3600),\n  };\n  let cache = RenderCache::with_settings(settings.clone());\n  assert_eq!(cache.settings.max_preview_entries, 50);\n  assert_eq!(cache.settings.max_memory_mb, 256);\n}\n\n#[tokio::test]\nasync fn test_preview_cache() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n  let image_data = vec![1, 2, 3, 4, 5];\n\n  // Сохраняем превью\n  cache\n    .store_preview(key.clone(), image_data.clone())\n    .await\n    .unwrap();\n\n  // Получаем превью\n  let cached_data = cache.get_preview(\u0026key).await;\n  assert!(cached_data.is_some());\n  assert_eq!(cached_data.unwrap().image_data, image_data);\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 1);\n  assert_eq!(stats.preview_hits, 1);\n  assert_eq!(stats.preview_misses, 0);\n}\n\n#[tokio::test]\nasync fn test_preview_cache_miss() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n\n  // Пытаемся получить несуществующее превью\n  let cached_data = cache.get_preview(\u0026key).await;\n  assert!(cached_data.is_none());\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 1);\n  assert_eq!(stats.preview_hits, 0);\n  assert_eq!(stats.preview_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_metadata_cache() {\n  let mut cache = RenderCache::new();\n  let file_path = \"/test/video.mp4\".to_string();\n  let metadata = MediaMetadata {\n    file_path: file_path.clone(),\n    file_size: 1024000,\n    modified_time: SystemTime::now(),\n    duration: 120.0,\n    resolution: Some((1920, 1080)),\n    fps: Some(30.0),\n    bitrate: Some(8000000),\n    video_codec: Some(\"h264\".to_string()),\n    audio_codec: Some(\"aac\".to_string()),\n    cached_at: SystemTime::now(),\n  };\n\n  // Сохраняем метаданные\n  cache\n    .store_metadata(file_path.clone(), metadata.clone())\n    .await\n    .unwrap();\n\n  // Получаем метаданные\n  let cached_metadata = cache.get_metadata(\u0026file_path).await;\n  assert!(cached_metadata.is_some());\n  assert_eq!(cached_metadata.unwrap().duration, 120.0);\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.metadata_requests, 1);\n  assert_eq!(stats.metadata_hits, 1);\n}\n\n#[tokio::test]\nasync fn test_metadata_cache_miss() {\n  let mut cache = RenderCache::new();\n  \n  // Пытаемся получить несуществующие метаданные\n  let cached_metadata = cache.get_metadata(\"/nonexistent.mp4\").await;\n  assert!(cached_metadata.is_none());\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.metadata_requests, 1);\n  assert_eq!(stats.metadata_hits, 0);\n  assert_eq!(stats.metadata_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_render_cache() {\n  let mut cache = RenderCache::new();\n  let cache_key = \"render_job_123\".to_string();\n  let render_data = RenderCacheData {\n    cache_key: cache_key.clone(),\n    output_path: PathBuf::from(\"/output/render.mp4\"),\n    render_hash: \"abc123def456\".to_string(),\n    created_at: SystemTime::now(),\n    file_size: 5000000,\n  };\n\n  // Сохраняем данные рендеринга\n  cache\n    .store_render_data(cache_key.clone(), render_data.clone())\n    .await\n    .unwrap();\n\n  // Получаем данные рендеринга\n  let cached_render = cache.get_render_data(\u0026cache_key).await;\n  assert!(cached_render.is_some());\n  assert_eq!(cached_render.unwrap().render_hash, \"abc123def456\");\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.render_requests, 1);\n  assert_eq!(stats.render_hits, 1);\n}\n\n#[tokio::test]\nasync fn test_render_cache_miss() {\n  let mut cache = RenderCache::new();\n  \n  // Пытаемся получить несуществующие данные рендеринга\n  let cached_render = cache.get_render_data(\"nonexistent_job\").await;\n  assert!(cached_render.is_none());\n\n  // Проверяем статистику\n  let stats = cache.get_stats();\n  assert_eq!(stats.render_requests, 1);\n  assert_eq!(stats.render_hits, 0);\n  assert_eq!(stats.render_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_cache_expiration() {\n  let settings = CacheSettings {\n    preview_ttl: Duration::from_millis(10), // Очень короткий TTL для теста\n    metadata_ttl: Duration::from_millis(10),\n    render_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 5.0, (320, 180), 50);\n  let image_data = vec![10, 20, 30];\n\n  // Сохраняем превью\n  cache.store_preview(key.clone(), image_data).await.unwrap();\n\n  // Сразу должно быть доступно\n  assert!(cache.get_preview(\u0026key).await.is_some());\n\n  // Ждем истечения TTL\n  tokio::time::sleep(Duration::from_millis(20)).await;\n\n  // Теперь должно быть недоступно\n  assert!(cache.get_preview(\u0026key).await.is_none());\n}\n\n#[tokio::test]\nasync fn test_metadata_expiration() {\n  let settings = CacheSettings {\n    metadata_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  let metadata = MediaMetadata {\n    file_path: \"/test/video.mp4\".to_string(),\n    file_size: 1024,\n    modified_time: SystemTime::now(),\n    duration: 60.0,\n    resolution: None,\n    fps: None,\n    bitrate: None,\n    video_codec: None,\n    audio_codec: None,\n    cached_at: SystemTime::now(),\n  };\n\n  cache.store_metadata(\"/test/video.mp4\".to_string(), metadata).await.unwrap();\n  assert!(cache.get_metadata(\"/test/video.mp4\").await.is_some());\n\n  tokio::time::sleep(Duration::from_millis(20)).await;\n  assert!(cache.get_metadata(\"/test/video.mp4\").await.is_none());\n}\n\n#[tokio::test]\nasync fn test_render_data_expiration() {\n  let settings = CacheSettings {\n    render_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  let render_data = RenderCacheData {\n    cache_key: \"job_123\".to_string(),\n    output_path: PathBuf::from(\"/output.mp4\"),\n    render_hash: \"hash123\".to_string(),\n    created_at: SystemTime::now(),\n    file_size: 1000,\n  };\n\n  cache.store_render_data(\"job_123\".to_string(), render_data).await.unwrap();\n  assert!(cache.get_render_data(\"job_123\").await.is_some());\n\n  tokio::time::sleep(Duration::from_millis(20)).await;\n  assert!(cache.get_render_data(\"job_123\").await.is_none());\n}\n\n#[tokio::test]\nasync fn test_cache_stats() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 1.0, (640, 360), 75);\n\n  // Промах\n  cache.get_preview(\u0026key).await;\n\n  // Сохраняем и попадание\n  cache\n    .store_preview(key.clone(), vec![1, 2, 3])\n    .await\n    .unwrap();\n  cache.get_preview(\u0026key).await;\n\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 2);\n  assert_eq!(stats.preview_hits, 1);\n  assert_eq!(stats.preview_misses, 1);\n  assert_eq!(stats.preview_hit_ratio(), 0.5);\n}\n\n#[tokio::test]\nasync fn test_cache_stats_hit_ratios() {\n  let cache = RenderCache::new();\n  let stats = cache.get_stats();\n\n  // При нулевых запросах hit ratio должен быть 0\n  assert_eq!(stats.hit_ratio(), 0.0);\n  assert_eq!(stats.preview_hit_ratio(), 0.0);\n}\n\n#[tokio::test]\nasync fn test_memory_usage() {\n  let cache = RenderCache::new();\n  let usage = cache.get_memory_usage();\n\n  assert_eq!(\n    usage.total_bytes,\n    usage.preview_bytes + usage.metadata_bytes + usage.render_bytes\n  );\n  assert!(usage.total_mb() \u003e= 0.0);\n}\n\n#[tokio::test]\nasync fn test_cache_clear() {\n  let mut cache = RenderCache::new();\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 2.0, (640, 360), 75);\n\n  // Добавляем данные\n  cache\n    .store_preview(key.clone(), vec![1, 2, 3])\n    .await\n    .unwrap();\n  assert!(cache.get_preview(\u0026key).await.is_some());\n\n  // Очищаем превью\n  cache.clear_previews().await;\n  assert!(cache.get_preview(\u0026key).await.is_none());\n}\n\n#[tokio::test]\nasync fn test_cache_clear_all() {\n  let mut cache = RenderCache::new();\n  \n  // Добавляем различные данные\n  let preview_key = PreviewKey::new(\"/test1.mp4\".to_string(), 1.0, (640, 360), 75);\n  cache.store_preview(preview_key.clone(), vec![1, 2, 3]).await.unwrap();\n  \n  let metadata = MediaMetadata {\n    file_path: \"/test2.mp4\".to_string(),\n    file_size: 1024,\n    modified_time: SystemTime::now(),\n    duration: 60.0,\n    resolution: None,\n    fps: None,\n    bitrate: None,\n    video_codec: None,\n    audio_codec: None,\n    cached_at: SystemTime::now(),\n  };\n  cache.store_metadata(\"/test2.mp4\".to_string(), metadata).await.unwrap();\n  \n  let render_data = RenderCacheData {\n    cache_key: \"job_456\".to_string(),\n    output_path: PathBuf::from(\"/output.mp4\"),\n    render_hash: \"hash456\".to_string(),\n    created_at: SystemTime::now(),\n    file_size: 2000,\n  };\n  cache.store_render_data(\"job_456\".to_string(), render_data).await.unwrap();\n  \n  // Проверяем что все данные есть\n  assert!(cache.get_preview(\u0026preview_key).await.is_some());\n  assert!(cache.get_metadata(\"/test2.mp4\").await.is_some());\n  assert!(cache.get_render_data(\"job_456\").await.is_some());\n  \n  // Очищаем весь кэш\n  cache.clear_all().await;\n  \n  // Проверяем что все данные удалены\n  assert!(cache.get_preview(\u0026preview_key).await.is_none());\n  assert!(cache.get_metadata(\"/test2.mp4\").await.is_none());\n  assert!(cache.get_render_data(\"job_456\").await.is_none());\n  \n  // Статистика должна быть сброшена\n  let stats = cache.get_stats();\n  assert_eq!(stats.preview_requests, 1); // один после clear_all\n  assert_eq!(stats.preview_hits, 0);\n  assert_eq!(stats.preview_misses, 1);\n}\n\n#[tokio::test]\nasync fn test_cleanup_old_entries() {\n  let settings = CacheSettings {\n    preview_ttl: Duration::from_millis(10),\n    metadata_ttl: Duration::from_millis(10),\n    render_ttl: Duration::from_millis(10),\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  // Добавляем данные\n  let key1 = PreviewKey::new(\"/test1.mp4\".to_string(), 1.0, (640, 360), 75);\n  let key2 = PreviewKey::new(\"/test2.mp4\".to_string(), 2.0, (640, 360), 75);\n  cache.store_preview(key1.clone(), vec![1, 2, 3]).await.unwrap();\n  \n  // Ждем истечения TTL для первого элемента\n  tokio::time::sleep(Duration::from_millis(15)).await;\n  \n  // Добавляем второй элемент\n  cache.store_preview(key2.clone(), vec![4, 5, 6]).await.unwrap();\n  \n  // Вызываем очистку\n  cache.cleanup_old_entries().await.unwrap();\n  \n  // Первый должен быть удален, второй остаться\n  assert!(cache.get_preview(\u0026key1).await.is_none());\n  assert!(cache.get_preview(\u0026key2).await.is_some());\n}\n\n#[tokio::test]\nasync fn test_cleanup_if_needed_with_memory_limit() {\n  let settings = CacheSettings {\n    max_memory_mb: 1, // Очень маленький лимит памяти для теста\n    max_preview_entries: 10000,\n    ..Default::default()\n  };\n  let mut cache = RenderCache::with_settings(settings);\n\n  // Добавляем много больших превью чтобы превысить лимит памяти\n  for i in 0..100 {\n    let key = PreviewKey::new(format!(\"/test{}.mp4\", i), i as f64, (1920, 1080), 90);\n    let large_data = vec![0u8; 100000]; // 100KB на превью\n    cache.store_preview(key, large_data).await.unwrap();\n  }\n\n  // cleanup_if_needed должен был быть вызван автоматически\n  let usage = cache.get_memory_usage();\n  // Проверяем что память не превышает сильно установленный лимит\n  assert!(usage.total_mb() \u003c 10.0); // Даем запас на накладные расходы\n}\n\n#[test]\nfn test_preview_key_creation() {\n  let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (1920, 1080), 90);\n  assert_eq!(key.file_path, \"/test/video.mp4\");\n  assert_eq!(key.timestamp, 10500); // 10.5 * 1000\n  assert_eq!(key.resolution, (1920, 1080));\n  assert_eq!(key.quality, 90);\n}\n\n#[test]\nfn test_preview_key_equality_and_hash() {\n  let key1 = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (1920, 1080), 90);\n  let key2 = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (1920, 1080), 90);\n  let key3 = PreviewKey::new(\"/test/video.mp4\".to_string(), 11.0, (1920, 1080), 90);\n  \n  assert_eq!(key1, key2);\n  assert_ne!(key1, key3);\n  \n  // Проверяем что ключи можно использовать в HashMap\n  let mut map = std::collections::HashMap::new();\n  map.insert(key1.clone(), \"value1\");\n  assert_eq!(map.get(\u0026key2), Some(\u0026\"value1\"));\n}\n\n#[test]\nfn test_preview_data_is_expired() {\n  let data = PreviewData {\n    image_data: vec![1, 2, 3],\n    timestamp: SystemTime::now() - Duration::from_secs(3600),\n    access_count: 5,\n  };\n\n  assert!(data.is_expired(Duration::from_secs(1800))); // 30 минут - истек\n  assert!(!data.is_expired(Duration::from_secs(7200))); // 2 часа - не истек\n}\n\n#[test]\nfn test_media_metadata_is_expired() {\n  let metadata = MediaMetadata {\n    file_path: \"/test.mp4\".to_string(),\n    file_size: 1024,\n    modified_time: SystemTime::now(),\n    duration: 60.0,\n    resolution: None,\n    fps: None,\n    bitrate: None,\n    video_codec: None,\n    audio_codec: None,\n    cached_at: SystemTime::now() - Duration::from_secs(1800),\n  };\n\n  assert!(metadata.is_expired(Duration::from_secs(900))); // 15 минут - истек\n  assert!(!metadata.is_expired(Duration::from_secs(3600))); // 1 час - не истек\n}\n\n#[test]\nfn test_render_cache_data_is_expired() {\n  let data = RenderCacheData {\n    cache_key: \"job_123\".to_string(),\n    output_path: PathBuf::from(\"/output.mp4\"),\n    render_hash: \"hash123\".to_string(),\n    created_at: SystemTime::now() - Duration::from_secs(7200),\n    file_size: 1000,\n  };\n\n  assert!(data.is_expired(Duration::from_secs(3600))); // 1 час - истек\n  assert!(!data.is_expired(Duration::from_secs(14400))); // 4 часа - не истек\n}\n\n#[test]\nfn test_cache_settings_default() {\n  let settings = CacheSettings::default();\n  assert_eq!(settings.max_preview_entries, 1000);\n  assert_eq!(settings.max_metadata_entries, 500);\n  assert_eq!(settings.max_render_entries, 100);\n  assert_eq!(settings.max_memory_mb, 512);\n  assert_eq!(settings.preview_ttl, Duration::from_secs(3600));\n  assert_eq!(settings.metadata_ttl, Duration::from_secs(1800));\n  assert_eq!(settings.render_ttl, Duration::from_secs(7200));\n}\n\n#[test]\nfn test_render_cache_default() {\n  let cache = RenderCache::default();\n  assert_eq!(cache.settings.max_preview_entries, 1000);\n}\n\n#[test]\nfn test_cache_memory_usage_total_mb() {\n  let usage = CacheMemoryUsage {\n    preview_bytes: 1024 * 1024 * 10, // 10 MB\n    metadata_bytes: 1024 * 1024 * 5, // 5 MB\n    render_bytes: 1024 * 1024 * 15,  // 15 MB\n    total_bytes: 1024 * 1024 * 30,   // 30 MB\n  };\n  \n  assert_eq!(usage.total_mb(), 30.0);\n}\n\n#[test]\nfn test_lru_cache() {\n  let mut lru = LruCache::new(2);\n\n  lru.insert(\"key1\".to_string(), \"value1\".to_string());\n  lru.insert(\"key2\".to_string(), \"value2\".to_string());\n\n  assert_eq!(lru.get(\u0026\"key1\".to_string()), Some(\"value1\".to_string()));\n\n  // Добавляем третий элемент, должен вытеснить самый старый\n  lru.insert(\"key3\".to_string(), \"value3\".to_string());\n\n  // key3 должен быть доступен\n  assert!(lru.get(\u0026\"key3\".to_string()).is_some());\n}\n\n#[test]\nfn test_lru_cache_remove() {\n  let mut lru = LruCache::new(5);\n  \n  lru.insert(\"key1\".to_string(), \"value1\".to_string());\n  lru.insert(\"key2\".to_string(), \"value2\".to_string());\n  \n  // Удаляем элемент\n  let removed = lru.remove(\u0026\"key1\".to_string());\n  assert_eq!(removed, Some(\"value1\".to_string()));\n  \n  // Проверяем что элемент удален\n  assert_eq!(lru.get(\u0026\"key1\".to_string()), None);\n  assert_eq!(lru.get(\u0026\"key2\".to_string()), Some(\"value2\".to_string()));\n}\n\n#[test]\nfn test_lru_cache_clear() {\n  let mut lru = LruCache::new(5);\n  \n  lru.insert(\"key1\".to_string(), \"value1\".to_string());\n  lru.insert(\"key2\".to_string(), \"value2\".to_string());\n  lru.insert(\"key3\".to_string(), \"value3\".to_string());\n  \n  lru.clear();\n  \n  assert_eq!(lru.get(\u0026\"key1\".to_string()), None);\n  assert_eq!(lru.get(\u0026\"key2\".to_string()), None);\n  assert_eq!(lru.get(\u0026\"key3\".to_string()), None);\n}\n\n#[test]\nfn test_lru_cache_retain() {\n  let mut lru = LruCache::new(5);\n  \n  lru.insert(1, 10);\n  lru.insert(2, 20);\n  lru.insert(3, 30);\n  lru.insert(4, 40);\n  \n  // Оставляем только четные значения\n  lru.retain(|_k, v| v % 20 == 0);\n  \n  assert_eq!(lru.get(\u00261), None);\n  assert_eq!(lru.get(\u00262), Some(20));\n  assert_eq!(lru.get(\u00263), None);\n  assert_eq!(lru.get(\u00264), Some(40));\n}\n\n#[test]\nfn test_lru_cache_memory_estimate() {\n  let lru: LruCache\u003cString, String\u003e = LruCache::new(100);\n  let memory = lru.estimate_memory_usage();\n  assert!(memory \u003e 0);\n}\n\n#[test]\nfn test_lru_cache_capacity_enforcement() {\n  let mut lru = LruCache::new(3);\n  \n  lru.insert(1, \"one\");\n  lru.insert(2, \"two\");\n  lru.insert(3, \"three\");\n  \n  // Все три должны быть доступны\n  assert_eq!(lru.get(\u00261), Some(\"one\"));\n  assert_eq!(lru.get(\u00262), Some(\"two\"));\n  assert_eq!(lru.get(\u00263), Some(\"three\"));\n  \n  // Добавляем четвертый элемент\n  lru.insert(4, \"four\");\n  \n  // Один из старых должен быть удален\n  assert_eq!(lru.get(\u00264), Some(\"four\"));\n  \n  // Проверяем что осталось только 3 элемента\n  let mut count = 0;\n  for i in 1..=4 {\n    if lru.get(\u0026i).is_some() {\n      count += 1;\n    }\n  }\n  assert_eq!(count, 3);\n}\n\n#[test] \nfn test_cache_stats_serialization() {\n  let stats = CacheStats {\n    preview_requests: 100,\n    preview_hits: 80,\n    preview_misses: 20,\n    metadata_requests: 50,\n    metadata_hits: 45,\n    metadata_misses: 5,\n    render_requests: 10,\n    render_hits: 8,\n    render_misses: 2,\n  };\n  \n  let json = serde_json::to_string(\u0026stats).unwrap();\n  assert!(json.contains(\"\\\"preview_requests\\\":100\"));\n  \n  let deserialized: CacheStats = serde_json::from_str(\u0026json).unwrap();\n  assert_eq!(deserialized.preview_hits, 80);\n  assert_eq!(deserialized.metadata_hits, 45);\n}\n\n#[test]\nfn test_media_metadata_serialization() {\n  let metadata = MediaMetadata {\n    file_path: \"/test/video.mp4\".to_string(),\n    file_size: 1024000,\n    modified_time: SystemTime::now(),\n    duration: 120.5,\n    resolution: Some((1920, 1080)),\n    fps: Some(30.0),\n    bitrate: Some(8000000),\n    video_codec: Some(\"h264\".to_string()),\n    audio_codec: Some(\"aac\".to_string()),\n    cached_at: SystemTime::now(),\n  };\n  \n  let json = serde_json::to_string(\u0026metadata).unwrap();\n  assert!(json.contains(\"1024000\"));\n  assert!(json.contains(\"120.5\"));\n  assert!(json.contains(\"1920\"));\n  assert!(json.contains(\"h264\"));\n  \n  let deserialized: MediaMetadata = serde_json::from_str(\u0026json).unwrap();\n  assert_eq!(deserialized.file_path, metadata.file_path);\n  assert_eq!(deserialized.duration, metadata.duration);\n  assert_eq!(deserialized.resolution, metadata.resolution);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","cache.rs"],"content":"//! Cache - Модуль кэширования для Video Compiler\n//!\n//! Этот модуль реализует LRU кэш для превью кадров, промежуточных результатов\n//! рендеринга и метаданных медиа файлов для улучшения производительности.\n\nuse crate::video_compiler::error::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::time::{Duration, SystemTime};\n\n/// Основной кэш Video Compiler\n#[derive(Debug)]\npub struct RenderCache {\n  /// Кэш превью кадров\n  preview_cache: LruCache\u003cPreviewKey, PreviewData\u003e,\n  /// Кэш метаданных файлов\n  metadata_cache: LruCache\u003cString, MediaMetadata\u003e,\n  /// Кэш промежуточных результатов рендеринга\n  render_cache: LruCache\u003cString, RenderCacheData\u003e,\n  /// Настройки кэша\n  settings: CacheSettings,\n  /// Статистика использования\n  stats: CacheStats,\n}\n\nimpl RenderCache {\n  /// Создать новый кэш с настройками по умолчанию\n  pub fn new() -\u003e Self {\n    Self::with_settings(CacheSettings::default())\n  }\n\n  /// Создать новый кэш с указанными настройками\n  pub fn with_settings(settings: CacheSettings) -\u003e Self {\n    Self {\n      preview_cache: LruCache::new(settings.max_preview_entries),\n      metadata_cache: LruCache::new(settings.max_metadata_entries),\n      render_cache: LruCache::new(settings.max_render_entries),\n      settings,\n      stats: CacheStats::default(),\n    }\n  }\n\n  /// Получить превью кадр из кэша\n  pub async fn get_preview(\u0026mut self, key: \u0026PreviewKey) -\u003e Option\u003cPreviewData\u003e {\n    self.stats.preview_requests += 1;\n\n    if let Some(data) = self.preview_cache.get(key) {\n      // Проверяем, не истек ли кэш\n      if !data.is_expired(self.settings.preview_ttl) {\n        self.stats.preview_hits += 1;\n        return Some(data.clone());\n      } else {\n        // Удаляем истекший элемент\n        self.preview_cache.remove(key);\n      }\n    }\n\n    self.stats.preview_misses += 1;\n    None\n  }\n\n  /// Сохранить превью кадр в кэш\n  pub async fn store_preview(\u0026mut self, key: PreviewKey, data: Vec\u003cu8\u003e) -\u003e Result\u003c()\u003e {\n    let preview_data = PreviewData {\n      image_data: data,\n      timestamp: SystemTime::now(),\n      access_count: 0,\n    };\n\n    self.preview_cache.insert(key, preview_data);\n    self.cleanup_if_needed().await?;\n    Ok(())\n  }\n\n  /// Получить метаданные файла из кэша\n  pub async fn get_metadata(\u0026mut self, file_path: \u0026str) -\u003e Option\u003cMediaMetadata\u003e {\n    self.stats.metadata_requests += 1;\n\n    if let Some(metadata) = self.metadata_cache.get(\u0026file_path.to_string()) {\n      if !metadata.is_expired(self.settings.metadata_ttl) {\n        self.stats.metadata_hits += 1;\n        return Some(metadata.clone());\n      } else {\n        self.metadata_cache.remove(\u0026file_path.to_string());\n      }\n    }\n\n    self.stats.metadata_misses += 1;\n    None\n  }\n\n  /// Сохранить метаданные файла в кэш\n  pub async fn store_metadata(\u0026mut self, file_path: String, metadata: MediaMetadata) -\u003e Result\u003c()\u003e {\n    self.metadata_cache.insert(file_path, metadata);\n    self.cleanup_if_needed().await?;\n    Ok(())\n  }\n\n  /// Получить данные рендеринга из кэша\n  pub async fn get_render_data(\u0026mut self, cache_key: \u0026str) -\u003e Option\u003cRenderCacheData\u003e {\n    self.stats.render_requests += 1;\n\n    if let Some(data) = self.render_cache.get(\u0026cache_key.to_string()) {\n      if !data.is_expired(self.settings.render_ttl) {\n        self.stats.render_hits += 1;\n        return Some(data.clone());\n      } else {\n        self.render_cache.remove(\u0026cache_key.to_string());\n      }\n    }\n\n    self.stats.render_misses += 1;\n    None\n  }\n\n  /// Сохранить данные рендеринга в кэш\n  pub async fn store_render_data(\n    \u0026mut self,\n    cache_key: String,\n    data: RenderCacheData,\n  ) -\u003e Result\u003c()\u003e {\n    self.render_cache.insert(cache_key, data);\n    self.cleanup_if_needed().await?;\n    Ok(())\n  }\n\n  /// Очистить весь кэш\n  pub async fn clear_all(\u0026mut self) {\n    self.preview_cache.clear();\n    self.metadata_cache.clear();\n    self.render_cache.clear();\n    self.stats = CacheStats::default();\n  }\n\n  /// Очистить только превью кэш\n  pub async fn clear_previews(\u0026mut self) {\n    self.preview_cache.clear();\n  }\n\n  /// Получить статистику кэша\n  pub fn get_stats(\u0026self) -\u003e \u0026CacheStats {\n    \u0026self.stats\n  }\n\n  /// Получить использование памяти кэшем (приблизительно)\n  pub fn get_memory_usage(\u0026self) -\u003e CacheMemoryUsage {\n    let preview_memory = self.preview_cache.estimate_memory_usage();\n    let metadata_memory = self.metadata_cache.estimate_memory_usage();\n    let render_memory = self.render_cache.estimate_memory_usage();\n\n    CacheMemoryUsage {\n      preview_bytes: preview_memory,\n      metadata_bytes: metadata_memory,\n      render_bytes: render_memory,\n      total_bytes: preview_memory + metadata_memory + render_memory,\n    }\n  }\n\n  /// Очистка кэша при необходимости\n  async fn cleanup_if_needed(\u0026mut self) -\u003e Result\u003c()\u003e {\n    let memory_usage = self.get_memory_usage();\n    let max_memory = self.settings.max_memory_mb * 1024 * 1024;\n\n    if memory_usage.total_bytes \u003e max_memory {\n      log::info!(\"Превышен лимит памяти кэша, выполняется очистка\");\n      self.cleanup_old_entries().await?;\n    }\n\n    Ok(())\n  }\n\n  /// Очистка старых записей\n  async fn cleanup_old_entries(\u0026mut self) -\u003e Result\u003c()\u003e {\n    let _now = SystemTime::now();\n\n    // Очищаем истекшие превью\n    self\n      .preview_cache\n      .retain(|_, data| !data.is_expired(self.settings.preview_ttl));\n\n    // Очищаем истекшие метаданные\n    self\n      .metadata_cache\n      .retain(|_, metadata| !metadata.is_expired(self.settings.metadata_ttl));\n\n    // Очищаем истекшие данные рендеринга\n    self\n      .render_cache\n      .retain(|_, data| !data.is_expired(self.settings.render_ttl));\n\n    Ok(())\n  }\n}\n\nimpl Default for RenderCache {\n  fn default() -\u003e Self {\n    Self::new()\n  }\n}\n\n/// Ключ для кэша превью\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\npub struct PreviewKey {\n  /// Путь к файлу\n  pub file_path: String,\n  /// Временная метка (секунды)\n  pub timestamp: u64,\n  /// Разрешение превью\n  pub resolution: (u32, u32),\n  /// Качество превью\n  pub quality: u8,\n}\n\nimpl PreviewKey {\n  pub fn new(file_path: String, timestamp: f64, resolution: (u32, u32), quality: u8) -\u003e Self {\n    Self {\n      file_path,\n      timestamp: (timestamp * 1000.0) as u64, // Конвертируем в миллисекунды\n      resolution,\n      quality,\n    }\n  }\n}\n\n/// Данные превью кадра\n#[derive(Debug, Clone)]\npub struct PreviewData {\n  /// Данные изображения (JPEG/PNG)\n  pub image_data: Vec\u003cu8\u003e,\n  /// Время создания\n  pub timestamp: SystemTime,\n  /// Количество обращений\n  pub access_count: u64,\n}\n\nimpl PreviewData {\n  /// Проверить, истек ли кэш\n  pub fn is_expired(\u0026self, ttl: Duration) -\u003e bool {\n    self.timestamp.elapsed().unwrap_or(Duration::ZERO) \u003e ttl\n  }\n}\n\n/// Метаданные медиа файла\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MediaMetadata {\n  /// Путь к файлу\n  pub file_path: String,\n  /// Размер файла в байтах\n  pub file_size: u64,\n  /// Время модификации файла\n  pub modified_time: SystemTime,\n  /// Длительность в секундах\n  pub duration: f64,\n  /// Разрешение видео (если есть)\n  pub resolution: Option\u003c(u32, u32)\u003e,\n  /// FPS (если есть)\n  pub fps: Option\u003cf32\u003e,\n  /// Битрейт (bps)\n  pub bitrate: Option\u003cu32\u003e,\n  /// Кодек видео\n  pub video_codec: Option\u003cString\u003e,\n  /// Кодек аудио\n  pub audio_codec: Option\u003cString\u003e,\n  /// Время кэширования\n  pub cached_at: SystemTime,\n}\n\nimpl MediaMetadata {\n  /// Проверить, истек ли кэш\n  pub fn is_expired(\u0026self, ttl: Duration) -\u003e bool {\n    self.cached_at.elapsed().unwrap_or(Duration::ZERO) \u003e ttl\n  }\n}\n\n/// Данные кэша рендеринга\n#[derive(Debug, Clone)]\npub struct RenderCacheData {\n  /// Ключ кэша\n  pub cache_key: String,\n  /// Путь к результирующему файлу\n  pub output_path: PathBuf,\n  /// Параметры рендеринга (хеш)\n  pub render_hash: String,\n  /// Время создания\n  pub created_at: SystemTime,\n  /// Размер результирующего файла\n  pub file_size: u64,\n}\n\nimpl RenderCacheData {\n  /// Проверить, истек ли кэш\n  pub fn is_expired(\u0026self, ttl: Duration) -\u003e bool {\n    self.created_at.elapsed().unwrap_or(Duration::ZERO) \u003e ttl\n  }\n}\n\n/// Настройки кэша\n#[derive(Debug, Clone)]\npub struct CacheSettings {\n  /// Максимальное количество превью в кэше\n  pub max_preview_entries: usize,\n  /// Максимальное количество метаданных в кэше\n  pub max_metadata_entries: usize,\n  /// Максимальное количество данных рендеринга в кэше\n  pub max_render_entries: usize,\n  /// Максимальное использование памяти в MB\n  pub max_memory_mb: usize,\n  /// TTL для превью\n  pub preview_ttl: Duration,\n  /// TTL для метаданных\n  pub metadata_ttl: Duration,\n  /// TTL для данных рендеринга\n  pub render_ttl: Duration,\n}\n\nimpl Default for CacheSettings {\n  fn default() -\u003e Self {\n    Self {\n      max_preview_entries: 1000,\n      max_metadata_entries: 500,\n      max_render_entries: 100,\n      max_memory_mb: 512,\n      preview_ttl: Duration::from_secs(3600),  // 1 час\n      metadata_ttl: Duration::from_secs(1800), // 30 минут\n      render_ttl: Duration::from_secs(7200),   // 2 часа\n    }\n  }\n}\n\n/// Статистика использования кэша\n#[derive(Debug, Default, Clone, serde::Serialize, serde::Deserialize)]\npub struct CacheStats {\n  /// Запросы превью\n  pub preview_requests: u64,\n  /// Попадания превью\n  pub preview_hits: u64,\n  /// Промахи превью\n  pub preview_misses: u64,\n  /// Запросы метаданных\n  pub metadata_requests: u64,\n  /// Попадания метаданных\n  pub metadata_hits: u64,\n  /// Промахи метаданных\n  pub metadata_misses: u64,\n  /// Запросы рендеринга\n  pub render_requests: u64,\n  /// Попадания рендеринга\n  pub render_hits: u64,\n  /// Промахи рендеринга\n  pub render_misses: u64,\n}\n\nimpl CacheStats {\n  /// Получить общий процент попаданий\n  pub fn hit_ratio(\u0026self) -\u003e f32 {\n    let total_requests = self.preview_requests + self.metadata_requests + self.render_requests;\n    let total_hits = self.preview_hits + self.metadata_hits + self.render_hits;\n\n    if total_requests == 0 {\n      0.0\n    } else {\n      total_hits as f32 / total_requests as f32\n    }\n  }\n\n  /// Получить процент попаданий превью\n  pub fn preview_hit_ratio(\u0026self) -\u003e f32 {\n    if self.preview_requests == 0 {\n      0.0\n    } else {\n      self.preview_hits as f32 / self.preview_requests as f32\n    }\n  }\n}\n\n/// Использование памяти кэшем\n#[derive(Debug, Clone)]\npub struct CacheMemoryUsage {\n  /// Память, используемая превью (байты)\n  pub preview_bytes: usize,\n  /// Память, используемая метаданными (байты)\n  pub metadata_bytes: usize,\n  /// Память, используемая данными рендеринга (байты)\n  pub render_bytes: usize,\n  /// Общее использование памяти (байты)\n  pub total_bytes: usize,\n}\n\nimpl CacheMemoryUsage {\n  /// Получить использование в мегабайтах\n  pub fn total_mb(\u0026self) -\u003e f32 {\n    self.total_bytes as f32 / (1024.0 * 1024.0)\n  }\n}\n\n/// Простая реализация LRU кэша\n#[derive(Debug)]\nstruct LruCache\u003cK, V\u003e {\n  map: HashMap\u003cK, LruNode\u003cV\u003e\u003e,\n  capacity: usize,\n  head: Option\u003cK\u003e,\n  tail: Option\u003cK\u003e,\n}\n\n#[derive(Debug, Clone)]\nstruct LruNode\u003cV\u003e {\n  value: V,\n  prev: Option\u003cString\u003e,\n  next: Option\u003cString\u003e,\n}\n\nimpl\u003cK, V\u003e LruCache\u003cK, V\u003e\nwhere\n  K: Clone + std::hash::Hash + Eq + std::fmt::Debug,\n  V: Clone,\n{\n  fn new(capacity: usize) -\u003e Self {\n    Self {\n      map: HashMap::new(),\n      capacity,\n      head: None,\n      tail: None,\n    }\n  }\n\n  fn get(\u0026mut self, key: \u0026K) -\u003e Option\u003cV\u003e {\n    if let Some(node) = self.map.get(key) {\n      let value = node.value.clone();\n      // В реальной реализации здесь бы мы перемещали элемент в начало\n      Some(value)\n    } else {\n      None\n    }\n  }\n\n  fn insert(\u0026mut self, key: K, value: V) {\n    if self.map.len() \u003e= self.capacity {\n      // Удаляем самый старый элемент\n      if let Some(oldest_key) = self.get_oldest_key() {\n        self.map.remove(\u0026oldest_key);\n      }\n    }\n\n    let node = LruNode {\n      value,\n      prev: None,\n      next: None,\n    };\n\n    self.map.insert(key, node);\n  }\n\n  fn remove(\u0026mut self, key: \u0026K) -\u003e Option\u003cV\u003e {\n    self.map.remove(key).map(|node| node.value)\n  }\n\n  fn clear(\u0026mut self) {\n    self.map.clear();\n    self.head = None;\n    self.tail = None;\n  }\n\n  fn retain\u003cF\u003e(\u0026mut self, mut f: F)\n  where\n    F: FnMut(\u0026K, \u0026V) -\u003e bool,\n  {\n    self.map.retain(|k, v| f(k, \u0026v.value));\n  }\n\n  fn estimate_memory_usage(\u0026self) -\u003e usize {\n    // Простая оценка использования памяти\n    std::mem::size_of::\u003cSelf\u003e()\n      + self.map.capacity() * (std::mem::size_of::\u003cK\u003e() + std::mem::size_of::\u003cV\u003e())\n  }\n\n  fn get_oldest_key(\u0026self) -\u003e Option\u003cK\u003e {\n    // Упрощенная реализация - возвращаем первый ключ\n    self.map.keys().next().cloned()\n  }\n}\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(test)]\nmod inline_tests {\n  use super::*;\n  use std::time::Duration;\n\n  #[tokio::test]\n  async fn test_cache_creation() {\n    let cache = RenderCache::new();\n    let stats = cache.get_stats();\n    assert_eq!(stats.preview_requests, 0);\n    assert_eq!(stats.metadata_requests, 0);\n  }\n\n  #[tokio::test]\n  async fn test_preview_cache() {\n    let mut cache = RenderCache::new();\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n    let image_data = vec![1, 2, 3, 4, 5];\n\n    // Сохраняем превью\n    cache\n      .store_preview(key.clone(), image_data.clone())\n      .await\n      .unwrap();\n\n    // Получаем превью\n    let cached_data = cache.get_preview(\u0026key).await;\n    assert!(cached_data.is_some());\n    assert_eq!(cached_data.unwrap().image_data, image_data);\n\n    // Проверяем статистику\n    let stats = cache.get_stats();\n    assert_eq!(stats.preview_requests, 1);\n    assert_eq!(stats.preview_hits, 1);\n    assert_eq!(stats.preview_misses, 0);\n  }\n\n  #[tokio::test]\n  async fn test_metadata_cache() {\n    let mut cache = RenderCache::new();\n    let file_path = \"/test/video.mp4\".to_string();\n    let metadata = MediaMetadata {\n      file_path: file_path.clone(),\n      file_size: 1024000,\n      modified_time: SystemTime::now(),\n      duration: 120.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n      cached_at: SystemTime::now(),\n    };\n\n    // Сохраняем метаданные\n    cache\n      .store_metadata(file_path.clone(), metadata.clone())\n      .await\n      .unwrap();\n\n    // Получаем метаданные\n    let cached_metadata = cache.get_metadata(\u0026file_path).await;\n    assert!(cached_metadata.is_some());\n    assert_eq!(cached_metadata.unwrap().duration, 120.0);\n  }\n\n  #[tokio::test]\n  async fn test_cache_expiration() {\n    let settings = CacheSettings {\n      preview_ttl: Duration::from_millis(10), // Очень короткий TTL для теста\n      ..Default::default()\n    };\n    let mut cache = RenderCache::with_settings(settings);\n\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 5.0, (320, 180), 50);\n    let image_data = vec![10, 20, 30];\n\n    // Сохраняем превью\n    cache.store_preview(key.clone(), image_data).await.unwrap();\n\n    // Сразу должно быть доступно\n    assert!(cache.get_preview(\u0026key).await.is_some());\n\n    // Ждем истечения TTL\n    tokio::time::sleep(Duration::from_millis(20)).await;\n\n    // Теперь должно быть недоступно\n    assert!(cache.get_preview(\u0026key).await.is_none());\n  }\n\n  #[tokio::test]\n  async fn test_cache_stats() {\n    let mut cache = RenderCache::new();\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 1.0, (640, 360), 75);\n\n    // Промах\n    cache.get_preview(\u0026key).await;\n\n    // Сохраняем и попадание\n    cache\n      .store_preview(key.clone(), vec![1, 2, 3])\n      .await\n      .unwrap();\n    cache.get_preview(\u0026key).await;\n\n    let stats = cache.get_stats();\n    assert_eq!(stats.preview_requests, 2);\n    assert_eq!(stats.preview_hits, 1);\n    assert_eq!(stats.preview_misses, 1);\n    assert_eq!(stats.preview_hit_ratio(), 0.5);\n  }\n\n  #[tokio::test]\n  async fn test_memory_usage() {\n    let cache = RenderCache::new();\n    let usage = cache.get_memory_usage();\n\n    assert_eq!(\n      usage.total_bytes,\n      usage.preview_bytes + usage.metadata_bytes + usage.render_bytes\n    );\n    assert!(usage.total_mb() \u003e= 0.0);\n  }\n\n  #[tokio::test]\n  async fn test_cache_clear() {\n    let mut cache = RenderCache::new();\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 2.0, (640, 360), 75);\n\n    // Добавляем данные\n    cache\n      .store_preview(key.clone(), vec![1, 2, 3])\n      .await\n      .unwrap();\n    assert!(cache.get_preview(\u0026key).await.is_some());\n\n    // Очищаем превью\n    cache.clear_previews().await;\n    assert!(cache.get_preview(\u0026key).await.is_none());\n  }\n\n  #[test]\n  fn test_lru_cache() {\n    let mut lru = LruCache::new(2);\n\n    lru.insert(\"key1\".to_string(), \"value1\".to_string());\n    lru.insert(\"key2\".to_string(), \"value2\".to_string());\n\n    assert_eq!(lru.get(\u0026\"key1\".to_string()), Some(\"value1\".to_string()));\n\n    // Добавляем третий элемент, должен вытеснить самый старый\n    lru.insert(\"key3\".to_string(), \"value3\".to_string());\n\n    // key1 или key2 должен быть удален (в зависимости от реализации)\n    assert!(lru.get(\u0026\"key3\".to_string()).is_some());\n  }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":61}},{"line":30,"address":[],"length":0,"stats":{"Line":61}},{"line":34,"address":[],"length":0,"stats":{"Line":68}},{"line":36,"address":[],"length":0,"stats":{"Line":68}},{"line":37,"address":[],"length":0,"stats":{"Line":68}},{"line":38,"address":[],"length":0,"stats":{"Line":68}},{"line":40,"address":[],"length":0,"stats":{"Line":68}},{"line":45,"address":[],"length":0,"stats":{"Line":50}},{"line":46,"address":[],"length":0,"stats":{"Line":25}},{"line":48,"address":[],"length":0,"stats":{"Line":37}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":15}},{"line":60,"address":[],"length":0,"stats":{"Line":15}},{"line":64,"address":[],"length":0,"stats":{"Line":222}},{"line":67,"address":[],"length":0,"stats":{"Line":111}},{"line":71,"address":[],"length":0,"stats":{"Line":111}},{"line":72,"address":[],"length":0,"stats":{"Line":111}},{"line":73,"address":[],"length":0,"stats":{"Line":111}},{"line":77,"address":[],"length":0,"stats":{"Line":14}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":80,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":10}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":147,"address":[],"length":0,"stats":{"Line":124}},{"line":148,"address":[],"length":0,"stats":{"Line":124}},{"line":149,"address":[],"length":0,"stats":{"Line":124}},{"line":150,"address":[],"length":0,"stats":{"Line":124}},{"line":156,"address":[],"length":0,"stats":{"Line":124}},{"line":161,"address":[],"length":0,"stats":{"Line":238}},{"line":162,"address":[],"length":0,"stats":{"Line":119}},{"line":163,"address":[],"length":0,"stats":{"Line":119}},{"line":165,"address":[],"length":0,"stats":{"Line":119}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":119}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":124}},{"line":219,"address":[],"length":0,"stats":{"Line":124}},{"line":239,"address":[],"length":0,"stats":{"Line":18}},{"line":240,"address":[],"length":0,"stats":{"Line":18}},{"line":271,"address":[],"length":0,"stats":{"Line":7}},{"line":272,"address":[],"length":0,"stats":{"Line":7}},{"line":293,"address":[],"length":0,"stats":{"Line":6}},{"line":294,"address":[],"length":0,"stats":{"Line":6}},{"line":318,"address":[],"length":0,"stats":{"Line":68}},{"line":324,"address":[],"length":0,"stats":{"Line":68}},{"line":325,"address":[],"length":0,"stats":{"Line":68}},{"line":326,"address":[],"length":0,"stats":{"Line":68}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":3}},{"line":370,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":2}},{"line":392,"address":[],"length":0,"stats":{"Line":6}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":418,"address":[],"length":0,"stats":{"Line":211}},{"line":420,"address":[],"length":0,"stats":{"Line":211}},{"line":427,"address":[],"length":0,"stats":{"Line":59}},{"line":428,"address":[],"length":0,"stats":{"Line":94}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":24}},{"line":437,"address":[],"length":0,"stats":{"Line":138}},{"line":438,"address":[],"length":0,"stats":{"Line":138}},{"line":440,"address":[],"length":0,"stats":{"Line":6}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":138}},{"line":454,"address":[],"length":0,"stats":{"Line":5}},{"line":455,"address":[],"length":0,"stats":{"Line":15}},{"line":458,"address":[],"length":0,"stats":{"Line":13}},{"line":459,"address":[],"length":0,"stats":{"Line":13}},{"line":460,"address":[],"length":0,"stats":{"Line":13}},{"line":461,"address":[],"length":0,"stats":{"Line":13}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":468,"address":[],"length":0,"stats":{"Line":14}},{"line":471,"address":[],"length":0,"stats":{"Line":373}},{"line":473,"address":[],"length":0,"stats":{"Line":373}},{"line":474,"address":[],"length":0,"stats":{"Line":373}},{"line":477,"address":[],"length":0,"stats":{"Line":3}},{"line":479,"address":[],"length":0,"stats":{"Line":3}}],"covered":122,"coverable":128},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","commands","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::video_compiler::{\n        commands::*,\n        progress::{RenderStatus, RenderProgress},\n        schema::{AspectRatio, ProjectSchema, Timeline, Track, TrackType},\n        CompilerSettings,\n    };\n    use tempfile::TempDir;\n\n    fn create_test_state() -\u003e VideoCompilerState {\n        VideoCompilerState::new()\n    }\n\n    fn create_test_project() -\u003e ProjectSchema {\n        let mut project = ProjectSchema::new(\"Test Project\".to_string());\n        \n        // Set up timeline\n        project.timeline = Timeline {\n            duration: 60.0,\n            fps: 30,\n            resolution: (1920, 1080),\n            sample_rate: 48000,\n            aspect_ratio: AspectRatio::Ratio16x9,\n        };\n        \n        // Add a video track\n        let track = Track::new(TrackType::Video, \"Video Track\".to_string());\n        project.tracks.push(track);\n        \n        project\n    }\n\n    #[test]\n    fn test_video_compiler_state_new() {\n        let state = VideoCompilerState::new();\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n    }\n\n    #[test]\n    fn test_video_compiler_state_default() {\n        let state = VideoCompilerState::default();\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n    }\n\n    #[test]\n    fn test_render_job_serialization() {\n        let job = RenderJob {\n            id: \"test-id\".to_string(),\n            project_name: \"Test Project\".to_string(),\n            output_path: \"/tmp/output.mp4\".to_string(),\n            status: RenderStatus::Processing,\n            created_at: chrono::Utc::now().to_rfc3339(),\n            progress: None,\n            error_message: None,\n        };\n\n        let json = serde_json::to_string(\u0026job).unwrap();\n        assert!(json.contains(\"test-id\"));\n        assert!(json.contains(\"Test Project\"));\n        \n        let deserialized: RenderJob = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.id, job.id);\n        assert_eq!(deserialized.project_name, job.project_name);\n    }\n\n    #[tokio::test]\n    async fn test_compiler_settings_serialization() {\n        let settings = CompilerSettings::default();\n        let json = serde_json::to_string(\u0026settings).unwrap();\n        assert!(json.contains(\"max_concurrent_jobs\"));\n        assert!(json.contains(\"cache_size_mb\"));\n        \n        let deserialized: CompilerSettings = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.max_concurrent_jobs, settings.max_concurrent_jobs);\n    }\n\n    #[test]\n    fn test_ffmpeg_capabilities_serialization() {\n        let capabilities = FfmpegCapabilities {\n            version: \"5.0.0\".to_string(),\n            available_codecs: vec![\"h264\".to_string(), \"aac\".to_string()],\n            hardware_encoders: vec![\"h264_nvenc\".to_string()],\n            path: \"/usr/bin/ffmpeg\".to_string(),\n        };\n\n        let json = serde_json::to_string(\u0026capabilities).unwrap();\n        assert!(json.contains(\"5.0.0\"));\n        assert!(json.contains(\"h264\"));\n        \n        // FfmpegCapabilities doesn't have Deserialize, so skip deserialization test\n    }\n\n    #[test]\n    fn test_system_info_serialization() {\n        let system_info = SystemInfo {\n            os: \"linux\".to_string(),\n            arch: \"x86_64\".to_string(),\n            ffmpeg_path: \"ffmpeg\".to_string(),\n            temp_directory: \"/tmp\".to_string(),\n            gpu_capabilities: None,\n            available_memory: Some(8_000_000_000),\n            cpu_cores: 8,\n        };\n\n        let json = serde_json::to_string(\u0026system_info).unwrap();\n        assert!(json.contains(\"linux\"));\n        assert!(json.contains(\"x86_64\"));\n        \n        // SystemInfo doesn't have Deserialize, so skip deserialization test\n    }\n\n    #[test]\n    fn test_prerender_request_serialization() {\n        let request = PrerenderRequest {\n            project_schema: create_test_project(),\n            start_time: 0.0,\n            end_time: 10.0,\n            apply_effects: true,\n            quality: Some(80),\n        };\n\n        let json = serde_json::to_string(\u0026request).unwrap();\n        assert!(json.contains(\"project_schema\"));\n        assert!(json.contains(\"start_time\"));\n        \n        let deserialized: PrerenderRequest = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.start_time, request.start_time);\n    }\n\n    #[tokio::test]\n    async fn test_get_prerender_cache_info() {\n        let result = get_prerender_cache_info().await;\n        assert!(result.is_ok());\n        \n        let info = result.unwrap();\n        assert_eq!(info.file_count, info.files.len());\n        assert!(info.total_size \u003e= 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_prerender_cache() {\n        let result = clear_prerender_cache().await;\n        assert!(result.is_ok());\n        \n        let deleted_size = result.unwrap();\n        assert!(deleted_size \u003e= 0);\n    }\n\n    #[test]\n    fn test_extract_ffmpeg_version() {\n        let output = \"ffmpeg version 5.1.2 Copyright (c) 2000-2022 the FFmpeg developers\";\n        let version = extract_ffmpeg_version(output);\n        assert_eq!(version, \"ffmpeg version 5.1.2 Copyright (c) 2000-2022 the FFmpeg developers\");\n\n        let output_no_version = \"Some other output\";\n        let version = extract_ffmpeg_version(output_no_version);\n        assert_eq!(version, \"Unknown\");\n    }\n\n    #[test]\n    fn test_extract_available_codecs() {\n        let output = \"Codecs:\\nD..... = Decoding supported\\n.E.... = Encoding supported\\n..V... = Video codec\\n..A... = Audio codec\\n D.V... h264         H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\\n DEA... aac          AAC (Advanced Audio Coding)\";\n        let codecs = extract_available_codecs(output);\n        assert!(codecs.contains(\u0026\"h264\".to_string()));\n        assert!(codecs.contains(\u0026\"aac\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_hardware_encoders() {\n        let output = \"Encoders:\\n V..... h264_nvenc   NVIDIA NVENC H.264 encoder\\n V..... h264_qsv     Intel Quick Sync Video H.264 encoder\";\n        let encoders = extract_hardware_encoders(output);\n        assert!(encoders.contains(\u0026\"h264_nvenc\".to_string()));\n        assert!(encoders.contains(\u0026\"h264_qsv\".to_string()));\n    }\n\n    #[test]\n    fn test_timeline_frame_extraction_request_serialization() {\n        let request = TimelineFrameExtractionRequest {\n            video_path: \"/path/to/video.mp4\".to_string(),\n            duration: 120.0,\n            interval: 5.0,\n            max_frames: Some(20),\n        };\n\n        let json = serde_json::to_string(\u0026request).unwrap();\n        assert!(json.contains(\"video_path\"));\n        assert!(json.contains(\"120.0\"));\n        \n        let deserialized: TimelineFrameExtractionRequest = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.video_path, request.video_path);\n    }\n\n    #[test] \n    fn test_prerender_result_serialization() {\n        let result = PrerenderResult {\n            file_path: \"/tmp/prerender.mp4\".to_string(),\n            duration: 10.0,\n            file_size: 1024 * 1024,\n            render_time_ms: 5000,\n        };\n\n        let json = serde_json::to_string(\u0026result).unwrap();\n        assert!(json.contains(\"/tmp/prerender.mp4\"));\n        assert!(json.contains(\"10.0\"));\n        \n        let deserialized: PrerenderResult = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.file_path, result.file_path);\n    }\n\n    #[test]\n    fn test_prerender_cache_file_serialization() {\n        let file = PrerenderCacheFile {\n            path: \"/tmp/prerender_0_10_abc.mp4\".to_string(),\n            size: 2048,\n            created: 1234567890,\n            start_time: 0.0,\n            end_time: 10.0,\n        };\n\n        let json = serde_json::to_string(\u0026file).unwrap();\n        assert!(json.contains(\"prerender_0_10\"));\n        \n        let deserialized: PrerenderCacheFile = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.path, file.path);\n    }\n\n    #[test]\n    fn test_prerender_cache_info_serialization() {\n        let info = PrerenderCacheInfo {\n            file_count: 2,\n            total_size: 4096,\n            files: vec![\n                PrerenderCacheFile {\n                    path: \"/tmp/prerender_0_10_abc.mp4\".to_string(),\n                    size: 2048,\n                    created: 1234567890,\n                    start_time: 0.0,\n                    end_time: 10.0,\n                },\n                PrerenderCacheFile {\n                    path: \"/tmp/prerender_10_20_def.mp4\".to_string(),\n                    size: 2048,\n                    created: 1234567891,\n                    start_time: 10.0,\n                    end_time: 20.0,\n                },\n            ],\n        };\n\n        let json = serde_json::to_string(\u0026info).unwrap();\n        assert!(json.contains(\"file_count\"));\n        assert!(json.contains(\"total_size\"));\n        \n        let deserialized: PrerenderCacheInfo = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.file_count, info.file_count);\n        assert_eq!(deserialized.total_size, info.total_size);\n    }\n\n    #[test]\n    fn test_timeline_frame_serialization() {\n        let frame = TimelineFrame {\n            timestamp: 5.0,\n            frame_data: \"base64encodeddata\".to_string(),\n            is_keyframe: true,\n        };\n\n        let json = serde_json::to_string(\u0026frame).unwrap();\n        assert!(json.contains(\"timestamp\"));\n        assert!(json.contains(\"frame_data\"));\n        assert!(json.contains(\"is_keyframe\"));\n        \n        let deserialized: TimelineFrame = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.timestamp, frame.timestamp);\n        assert_eq!(deserialized.is_keyframe, frame.is_keyframe);\n    }\n\n    #[test]\n    fn test_recognition_frame_result_serialization() {\n        let result = RecognitionFrameResult {\n            timestamp: 10.0,\n            frame_data: vec![1, 2, 3, 4],\n            resolution: [1920, 1080],\n            scene_change_score: Some(0.85),\n            is_keyframe: false,\n        };\n\n        let json = serde_json::to_string(\u0026result).unwrap();\n        assert!(json.contains(\"timestamp\"));\n        assert!(json.contains(\"resolution\"));\n        assert!(json.contains(\"scene_change_score\"));\n        \n        let deserialized: RecognitionFrameResult = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.timestamp, result.timestamp);\n        assert_eq!(deserialized.resolution, result.resolution);\n    }\n\n    #[test]\n    fn test_subtitle_frame_result_serialization() {\n        let result = SubtitleFrameResult {\n            subtitle_id: \"subtitle-1\".to_string(),\n            subtitle_text: \"Hello World\".to_string(),\n            timestamp: 15.0,\n            frame_data: vec![5, 6, 7, 8],\n            start_time: 14.5,\n            end_time: 16.5,\n        };\n\n        let json = serde_json::to_string(\u0026result).unwrap();\n        assert!(json.contains(\"subtitle_id\"));\n        assert!(json.contains(\"subtitle_text\"));\n        \n        let deserialized: SubtitleFrameResult = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.subtitle_id, result.subtitle_id);\n        assert_eq!(deserialized.subtitle_text, result.subtitle_text);\n    }\n\n    #[test]\n    fn test_get_available_memory() {\n        // Test the function directly\n        let memory = get_available_memory();\n        // Just check it doesn't panic\n        assert!(memory.is_some() || memory.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_cache_stats_structure() {\n        let state = create_test_state();\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        \n        // Check all required fields exist\n        assert_eq!(stats.preview_requests, 0);\n        assert_eq!(stats.preview_hits, 0);\n        assert_eq!(stats.preview_misses, 0);\n        assert_eq!(stats.metadata_requests, 0);\n        assert_eq!(stats.metadata_hits, 0);\n        assert_eq!(stats.metadata_misses, 0);\n        assert_eq!(stats.render_requests, 0);\n        assert_eq!(stats.render_hits, 0);\n        assert_eq!(stats.render_misses, 0);\n    }\n\n    #[tokio::test]\n    async fn test_video_compiler_state_structure() {\n        let state = create_test_state();\n        \n        // Check active_jobs\n        {\n            let jobs = state.active_jobs.read().await;\n            assert!(jobs.is_empty());\n        }\n        \n        // Check cache_manager\n        {\n            let _cache = state.cache_manager.read().await;\n            // Cache exists\n        }\n        \n        // Check settings\n        {\n            let settings = state.settings.read().await;\n            assert!(settings.max_concurrent_jobs \u003e 0);\n        }\n        \n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n    }\n\n    #[tokio::test]\n    async fn test_compile_video_state() {\n        let state = create_test_state();\n        let project = create_test_project();\n        \n        // Test that we can create the state and access its components\n        assert!(state.active_jobs.read().await.is_empty());\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n        \n        // Validate project schema\n        assert_eq!(project.metadata.name, \"Test Project\");\n        assert_eq!(project.timeline.fps, 30);\n        assert_eq!(project.timeline.resolution, (1920, 1080));\n    }\n\n    #[tokio::test] \n    async fn test_render_job_management() {\n        let state = create_test_state();\n        \n        // Test that active jobs starts empty\n        {\n            let jobs = state.active_jobs.read().await;\n            assert!(jobs.is_empty());\n        }\n        \n        // Test RenderJob structure (command version)\n        let job = RenderJob {\n            id: \"test-123\".to_string(),\n            project_name: \"Test Project\".to_string(),\n            output_path: \"/tmp/output.mp4\".to_string(),\n            status: RenderStatus::Processing,\n            created_at: chrono::Utc::now().to_rfc3339(),\n            progress: Some(RenderProgress {\n                job_id: \"test-123\".to_string(),\n                stage: \"Encoding\".to_string(),\n                percentage: 50.0,\n                current_frame: 1500,\n                total_frames: 3000,\n                elapsed_time: std::time::Duration::from_secs(60),\n                estimated_remaining: Some(std::time::Duration::from_secs(60)),\n                status: RenderStatus::Processing,\n                message: Some(\"Processing video\".to_string()),\n            }),\n            error_message: None,\n        };\n        \n        assert_eq!(job.id, \"test-123\");\n        assert_eq!(job.status, RenderStatus::Processing);\n    }\n\n    #[tokio::test]\n    async fn test_get_active_jobs() {\n        let state = create_test_state();\n        \n        // Test that active jobs starts empty\n        let jobs = state.active_jobs.read().await;\n        assert!(jobs.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_cancel_render() {\n        let state = create_test_state();\n        let job_id = \"test-job-123\".to_string();\n        \n        // Verify no jobs exist\n        {\n            let jobs = state.active_jobs.read().await;\n            assert!(!jobs.contains_key(\u0026job_id));\n        }\n    }\n\n    #[tokio::test]\n    async fn test_generate_preview() {\n        let state = create_test_state();\n        let temp_dir = TempDir::new().unwrap();\n        let video_path = temp_dir.path().join(\"test.mp4\").to_str().unwrap().to_string();\n        \n        // Create a fake video file\n        std::fs::write(\u0026video_path, b\"fake video content\").unwrap();\n        \n        // Test cache manager exists\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        assert_eq!(stats.preview_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_gpu_capabilities() {\n        // Test GPU capabilities structure\n        use crate::video_compiler::gpu::GpuCapabilities;\n        \n        let capabilities = GpuCapabilities {\n            available_encoders: vec![crate::video_compiler::gpu::GpuEncoder::Nvenc],\n            recommended_encoder: Some(crate::video_compiler::gpu::GpuEncoder::Nvenc),\n            current_gpu: None,\n            hardware_acceleration_supported: true,\n        };\n        \n        assert!(capabilities.hardware_acceleration_supported);\n    }\n\n    #[tokio::test]\n    async fn test_get_current_gpu_info() {\n        // Test GPU info structure\n        use crate::video_compiler::gpu::GpuInfo;\n        \n        let info = GpuInfo {\n            name: \"Test GPU\".to_string(),\n            driver_version: Some(\"1.0.0\".to_string()),\n            memory_total: Some(8192 * 1024 * 1024),\n            memory_used: Some(1024 * 1024 * 1024),\n            utilization: Some(50.0),\n            encoder_type: crate::video_compiler::gpu::GpuEncoder::Nvenc,\n            supported_codecs: vec![\"h264\".to_string(), \"hevc\".to_string()],\n        };\n        \n        assert_eq!(info.name, \"Test GPU\");\n        assert!(info.memory_total.unwrap() \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_check_hardware_acceleration() {\n        let state = create_test_state();\n        \n        // Test settings have hardware acceleration flag\n        let settings = state.settings.read().await;\n        let hw_enabled = settings.hardware_acceleration;\n        assert!(hw_enabled == true || hw_enabled == false); // Either value is valid\n    }\n\n    #[tokio::test]\n    async fn test_get_cache_stats() {\n        let state = create_test_state();\n        \n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        \n        // New cache should have zero requests\n        assert_eq!(stats.preview_requests, 0);\n        assert_eq!(stats.metadata_requests, 0);\n        assert_eq!(stats.render_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_cache() {\n        let state = create_test_state();\n        \n        // Clear cache\n        {\n            let mut cache = state.cache_manager.write().await;\n            cache.clear_all().await;\n        }\n        \n        // Verify cache is empty\n        let cache = state.cache_manager.read().await;\n        let usage = cache.get_memory_usage();\n        assert!(usage.total_mb() \u003c 0.01);\n    }\n\n    #[tokio::test]\n    async fn test_clear_preview_cache() {\n        let state = create_test_state();\n        \n        // Clear preview cache\n        {\n            let mut cache = state.cache_manager.write().await;\n            cache.clear_previews().await;\n        }\n        \n        // Verify preview cache is empty\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        // Stats should be zero after clearing\n    }\n\n    #[tokio::test]\n    async fn test_get_compiler_settings() {\n        let state = create_test_state();\n        \n        let settings = state.settings.read().await;\n        assert!(settings.max_concurrent_jobs \u003e 0);\n        assert!(settings.cache_size_mb \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_update_compiler_settings() {\n        let state = create_test_state();\n        \n        // Update settings\n        {\n            let mut settings = state.settings.write().await;\n            settings.max_concurrent_jobs = 8;\n            settings.hardware_acceleration = false;\n        }\n        \n        // Verify settings were updated\n        let settings = state.settings.read().await;\n        assert_eq!(settings.max_concurrent_jobs, 8);\n        assert_eq!(settings.hardware_acceleration, false);\n    }\n\n    #[tokio::test]\n    async fn test_set_ffmpeg_path() {\n        let state = create_test_state();\n        let new_path = \"/usr/local/bin/ffmpeg\".to_string();\n        \n        // Verify original path\n        assert_eq!(state.ffmpeg_path, \"ffmpeg\");\n        \n        // Would update via state in real command\n        // For test, just verify structure\n        assert!(!new_path.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_get_system_info() {\n        // Test system info structure\n        let info = SystemInfo {\n            os: \"linux\".to_string(),\n            arch: \"x86_64\".to_string(),\n            ffmpeg_path: \"ffmpeg\".to_string(),\n            temp_directory: \"/tmp\".to_string(),\n            gpu_capabilities: None,\n            available_memory: Some(8_000_000_000),\n            cpu_cores: 8,\n        };\n        \n        assert_eq!(info.cpu_cores, 8);\n        assert!(info.available_memory.unwrap() \u003e 0);\n    }\n\n    #[tokio::test]\n    async fn test_check_ffmpeg_capabilities() {\n        // Test FFmpeg capabilities structure\n        let capabilities = FfmpegCapabilities {\n            version: \"5.0.0\".to_string(),\n            available_codecs: vec![\"h264\".to_string(), \"aac\".to_string()],\n            hardware_encoders: vec![\"h264_nvenc\".to_string()],\n            path: \"/usr/bin/ffmpeg\".to_string(),\n        };\n        \n        assert!(!capabilities.version.is_empty());\n        assert!(!capabilities.available_codecs.is_empty());\n        assert!(capabilities.available_codecs.contains(\u0026\"h264\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_extract_timeline_frames() {\n        let temp_dir = TempDir::new().unwrap();\n        let video_path = temp_dir.path().join(\"test.mp4\").to_str().unwrap().to_string();\n        std::fs::write(\u0026video_path, b\"fake video\").unwrap();\n        \n        // Test request structure with correct fields\n        let request = TimelineFrameExtractionRequest {\n            video_path: video_path.clone(),\n            duration: 30.0,\n            interval: 5.0,\n            max_frames: Some(6),\n        };\n        \n        assert_eq!(request.duration, 30.0);\n        assert_eq!(request.interval, 5.0);\n        assert_eq!(request.max_frames, Some(6));\n    }\n\n    #[tokio::test]\n    async fn test_clear_frame_cache() {\n        let state = create_test_state();\n        \n        // Test that cache manager exists and can be accessed\n        let cache = state.cache_manager.read().await;\n        let stats = cache.get_stats();\n        \n        // Frame cache should be part of overall cache\n        assert_eq!(stats.preview_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_prerender_segment() {\n        let project = create_test_project();\n        \n        // Test request structure with correct fields\n        let request = PrerenderRequest {\n            project_schema: project,\n            start_time: 0.0,\n            end_time: 10.0,\n            apply_effects: true,\n            quality: Some(80),\n        };\n        \n        assert_eq!(request.start_time, 0.0);\n        assert_eq!(request.end_time, 10.0);\n        assert_eq!(request.apply_effects, true);\n        assert_eq!(request.quality, Some(80));\n    }\n\n    #[tokio::test]\n    async fn test_get_prerender_cache_info_standalone() {\n        // Test the standalone function\n        let result = get_prerender_cache_info().await;\n        assert!(result.is_ok());\n        \n        let info = result.unwrap();\n        assert_eq!(info.file_count, info.files.len());\n        assert!(info.total_size \u003e= 0);\n    }\n\n    #[tokio::test]\n    async fn test_clear_prerender_cache_standalone() {\n        // Test the standalone function\n        let result = clear_prerender_cache().await;\n        assert!(result.is_ok());\n        \n        let deleted_size = result.unwrap();\n        assert!(deleted_size \u003e= 0);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","commands.rs"],"content":"/*!\n * Tauri команды для Video Compiler\n *\n * Этот модуль определяет все Tauri команды для работы с video compiler\n * из фронтенда, включая компиляцию видео, управление GPU и мониторинг.\n */\n\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tauri::State;\nuse tokio::sync::{mpsc, RwLock};\nuse uuid::Uuid;\n\nuse crate::video_compiler::cache::{CacheStats, RenderCache};\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::frame_extraction::{\n  ExtractionPurpose, ExtractionSettings, ExtractionStrategy, FrameExtractionManager,\n};\nuse crate::video_compiler::gpu::{GpuCapabilities, GpuDetector, GpuInfo};\nuse crate::video_compiler::progress::{RenderProgress, RenderStatus};\nuse crate::video_compiler::renderer::VideoRenderer;\nuse crate::video_compiler::schema::{Clip, ProjectSchema, Subtitle};\nuse crate::video_compiler::CompilerSettings;\n\n/// Состояние Video Compiler для Tauri\n#[derive(Debug)]\npub struct VideoCompilerState {\n  /// Активные задачи рендеринга\n  pub active_jobs: Arc\u003cRwLock\u003cHashMap\u003cString, VideoRenderer\u003e\u003e\u003e,\n\n  /// Менеджер кэша\n  pub cache_manager: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n\n  /// Путь к FFmpeg\n  pub ffmpeg_path: String,\n\n  /// Настройки компилятора\n  pub settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n}\n\nimpl VideoCompilerState {\n  pub fn new() -\u003e Self {\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let cache_manager = Arc::new(RwLock::new(RenderCache::new()));\n\n    Self {\n      active_jobs: Arc::new(RwLock::new(HashMap::new())),\n      cache_manager,\n      ffmpeg_path: \"ffmpeg\".to_string(), // Предполагаем, что ffmpeg в PATH\n      settings,\n    }\n  }\n}\n\nimpl Default for VideoCompilerState {\n  fn default() -\u003e Self {\n    Self::new()\n  }\n}\n\n/// Информация о задаче рендеринга для фронтенда\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct RenderJob {\n  pub id: String,\n  pub project_name: String,\n  pub output_path: String,\n  pub status: RenderStatus,\n  pub created_at: String,\n  pub progress: Option\u003cRenderProgress\u003e,\n  pub error_message: Option\u003cString\u003e,\n}\n\n// ==================== ОСНОВНЫЕ КОМАНДЫ ====================\n\n/// Запуск компиляции видео\n#[tauri::command]\npub async fn compile_video(\n  project_schema: ProjectSchema,\n  output_path: String,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cString\u003e {\n  let job_id = uuid::Uuid::new_v4().to_string();\n\n  // Создаем канал для прогресса\n  let (progress_sender, _progress_receiver) = mpsc::unbounded_channel();\n\n  // Создаем рендерер\n  let renderer = VideoRenderer::new(\n    project_schema,\n    state.settings.clone(),\n    state.cache_manager.clone(),\n    progress_sender,\n  )\n  .await\n  .map_err(|e| VideoCompilerError::InternalError(format!(\"Failed to create renderer: {}\", e)))?;\n\n  // Сохраняем в активных задачах\n  {\n    let mut jobs = state.active_jobs.write().await;\n    jobs.insert(job_id.clone(), renderer);\n  }\n\n  // Запускаем рендеринг в фоне\n  let active_jobs = state.active_jobs.clone();\n  let job_id_clone = job_id.clone();\n  let output_path_clone = output_path.clone();\n\n  tokio::spawn(async move {\n    let result = {\n      let mut jobs = active_jobs.write().await;\n      if let Some(renderer) = jobs.get_mut(\u0026job_id_clone) {\n        renderer.render(Path::new(\u0026output_path_clone)).await\n      } else {\n        Err(VideoCompilerError::InternalError(\n          \"Job not found\".to_string(),\n        ))\n      }\n    };\n\n    // Логируем результат\n    match result {\n      Ok(_) =\u003e log::info!(\"Рендеринг завершен успешно: {}\", job_id_clone),\n      Err(e) =\u003e log::error!(\"Ошибка рендеринга {}: {}\", job_id_clone, e),\n    }\n\n    // Удаляем из активных задач\n    {\n      let mut jobs = active_jobs.write().await;\n      jobs.remove(\u0026job_id_clone);\n    }\n  });\n\n  Ok(job_id)\n}\n\n/// Получить прогресс рендеринга\n#[tauri::command]\npub async fn get_render_progress(\n  job_id: String,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cOption\u003cRenderProgress\u003e\u003e {\n  let jobs = state.active_jobs.read().await;\n\n  if let Some(renderer) = jobs.get(\u0026job_id) {\n    Ok(renderer.get_progress().await)\n  } else {\n    Ok(None)\n  }\n}\n\n/// Отменить рендеринг\n#[tauri::command]\npub async fn cancel_render(job_id: String, state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cbool\u003e {\n  let mut jobs = state.active_jobs.write().await;\n\n  if let Some(renderer) = jobs.get_mut(\u0026job_id) {\n    renderer.cancel().await?;\n    jobs.remove(\u0026job_id);\n    Ok(true)\n  } else {\n    Ok(false)\n  }\n}\n\n/// Получить список активных задач\n#[tauri::command]\npub async fn get_active_jobs(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cVec\u003cRenderJob\u003e\u003e {\n  let jobs = state.active_jobs.read().await;\n  let mut result = Vec::new();\n\n  for (job_id, renderer) in jobs.iter() {\n    let progress = renderer.get_progress().await;\n    let status = match \u0026progress {\n      Some(p) =\u003e p.status.clone(),\n      None =\u003e RenderStatus::Processing,\n    };\n\n    result.push(RenderJob {\n      id: job_id.clone(),\n      project_name: \"Unknown Project\".to_string(), // TODO: получать из ProjectSchema\n      output_path: \"Unknown Path\".to_string(),     // TODO: сохранять путь\n      status,\n      created_at: chrono::Utc::now().to_rfc3339(),\n      progress,\n      error_message: None,\n    });\n  }\n\n  Ok(result)\n}\n\n/// Генерация превью кадра\n#[tauri::command]\npub async fn generate_preview(\n  video_path: String,\n  timestamp: f64,\n  resolution: Option\u003c(u32, u32)\u003e,\n  quality: Option\u003cu8\u003e,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n  use crate::video_compiler::preview::PreviewGenerator;\n\n  let preview_gen = PreviewGenerator::new(state.cache_manager.clone());\n\n  // Генерируем превью\n  preview_gen\n    .generate_preview(Path::new(\u0026video_path), timestamp, resolution, quality)\n    .await\n    .map_err(|e| VideoCompilerError::PreviewError {\n      timestamp,\n      reason: e.to_string(),\n    })\n}\n\n/// Параметры для пререндера сегмента\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderRequest {\n  /// Схема проекта\n  pub project_schema: ProjectSchema,\n  /// Время начала сегмента в секундах\n  pub start_time: f64,\n  /// Время окончания сегмента в секундах\n  pub end_time: f64,\n  /// Применять ли эффекты и фильтры\n  pub apply_effects: bool,\n  /// Качество пререндера (1-100)\n  pub quality: Option\u003cu8\u003e,\n}\n\n/// Результат пререндера\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderResult {\n  /// Путь к файлу пререндера\n  pub file_path: String,\n  /// Длительность сегмента\n  pub duration: f64,\n  /// Размер файла в байтах\n  pub file_size: u64,\n  /// Время рендеринга в миллисекундах\n  pub render_time_ms: u64,\n}\n\n/// Пререндер сегмента видео для быстрого предпросмотра\n#[tauri::command]\npub async fn prerender_segment(\n  request: PrerenderRequest,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cPrerenderResult\u003e {\n  use crate::video_compiler::ffmpeg_builder::{FFmpegBuilder, FFmpegBuilderSettings};\n  use std::time::Instant;\n  use tokio::fs;\n\n  let start_instant = Instant::now();\n\n  // Валидация параметров\n  if request.start_time \u003e= request.end_time {\n    return Err(VideoCompilerError::validation(\n      \"Start time must be before end time\",\n    ));\n  }\n\n  let duration = request.end_time - request.start_time;\n  if duration \u003e 60.0 {\n    return Err(VideoCompilerError::validation(\n      \"Prerender segment cannot be longer than 60 seconds\",\n    ));\n  }\n\n  // Создаем временный файл для пререндера с уникальным именем\n  let temp_dir = std::env::temp_dir();\n\n  // Создаем хеш из параметров проекта для уникальности\n  use std::collections::hash_map::DefaultHasher;\n  use std::hash::{Hash, Hasher};\n\n  let mut hasher = DefaultHasher::new();\n  request.project_schema.tracks.len().hash(\u0026mut hasher);\n  request.project_schema.effects.len().hash(\u0026mut hasher);\n  request.apply_effects.hash(\u0026mut hasher);\n  request.quality.hash(\u0026mut hasher);\n  let hash = hasher.finish();\n\n  let file_name = format!(\n    \"prerender_{}_{}_{:x}.mp4\",\n    request.start_time.round() as i64,\n    request.end_time.round() as i64,\n    hash \u0026 0xFFFFFF // Используем только последние 6 цифр хеша\n  );\n  let output_path = temp_dir.join(file_name);\n\n  // Настройки FFmpeg\n  let ffmpeg_settings = FFmpegBuilderSettings {\n    ffmpeg_path: state.ffmpeg_path.clone(),\n    ..Default::default()\n  };\n\n  // Создаем билдер\n  let builder = FFmpegBuilder::with_settings(request.project_schema, ffmpeg_settings);\n\n  // Строим команду пререндера\n  let mut cmd = builder\n    .build_prerender_segment_command(\n      request.start_time,\n      request.end_time,\n      \u0026output_path,\n      request.apply_effects,\n    )\n    .await?;\n\n  // Запускаем FFmpeg\n  let output = cmd\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  if !output.status.success() {\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n    let exit_code = output.status.code();\n    return Err(VideoCompilerError::ffmpeg(\n      exit_code,\n      stderr.to_string(),\n      \"prerender_segment\",\n    ));\n  }\n\n  // Получаем размер файла\n  let metadata = fs::metadata(\u0026output_path)\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  let render_time_ms = start_instant.elapsed().as_millis() as u64;\n\n  Ok(PrerenderResult {\n    file_path: output_path.to_string_lossy().to_string(),\n    duration,\n    file_size: metadata.len(),\n    render_time_ms,\n  })\n}\n\n/// Информация о кеше пререндеров\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderCacheInfo {\n  /// Количество файлов в кеше\n  pub file_count: usize,\n  /// Общий размер кеша в байтах\n  pub total_size: u64,\n  /// Список файлов в кеше\n  pub files: Vec\u003cPrerenderCacheFile\u003e,\n}\n\n/// Информация о файле в кеше\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct PrerenderCacheFile {\n  /// Путь к файлу\n  pub path: String,\n  /// Размер файла в байтах\n  pub size: u64,\n  /// Время создания\n  pub created: u64,\n  /// Параметры сегмента\n  pub start_time: f64,\n  pub end_time: f64,\n}\n\n/// Получить информацию о кеше пререндеров\n#[tauri::command]\npub async fn get_prerender_cache_info() -\u003e Result\u003cPrerenderCacheInfo\u003e {\n  use std::time::SystemTime;\n  use tokio::fs;\n\n  let temp_dir = std::env::temp_dir();\n  let mut files = Vec::new();\n  let mut total_size = 0u64;\n\n  // Читаем содержимое временной директории\n  let mut entries = fs::read_dir(\u0026temp_dir)\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  while let Some(entry) = entries\n    .next_entry()\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?\n  {\n    let path = entry.path();\n    let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n    // Проверяем, является ли это файлом пререндера\n    if file_name.starts_with(\"prerender_\") \u0026\u0026 file_name.ends_with(\".mp4\") {\n      let metadata = entry\n        .metadata()\n        .await\n        .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n      if metadata.is_file() {\n        let size = metadata.len();\n        total_size += size;\n\n        // Парсим время из имени файла\n        let parts: Vec\u003c\u0026str\u003e = file_name\n          .trim_start_matches(\"prerender_\")\n          .trim_end_matches(\".mp4\")\n          .split('_')\n          .collect();\n\n        let (start_time, end_time) = if parts.len() \u003e= 2 {\n          (\n            parts[0].parse::\u003cf64\u003e().unwrap_or(0.0),\n            parts[1].parse::\u003cf64\u003e().unwrap_or(0.0),\n          )\n        } else {\n          (0.0, 0.0)\n        };\n\n        let created = metadata\n          .created()\n          .ok()\n          .and_then(|t| t.duration_since(SystemTime::UNIX_EPOCH).ok())\n          .map(|d| d.as_secs())\n          .unwrap_or(0);\n\n        files.push(PrerenderCacheFile {\n          path: path.to_string_lossy().to_string(),\n          size,\n          created,\n          start_time,\n          end_time,\n        });\n      }\n    }\n  }\n\n  // Сортируем файлы по времени создания (новые первыми)\n  files.sort_by(|a, b| b.created.cmp(\u0026a.created));\n\n  Ok(PrerenderCacheInfo {\n    file_count: files.len(),\n    total_size,\n    files,\n  })\n}\n\n/// Очистить кеш пререндеров\n#[tauri::command]\npub async fn clear_prerender_cache() -\u003e Result\u003cu64\u003e {\n  use tokio::fs;\n\n  let temp_dir = std::env::temp_dir();\n  let mut _deleted_count = 0u64;\n  let mut deleted_size = 0u64;\n\n  // Читаем содержимое временной директории\n  let mut entries = fs::read_dir(\u0026temp_dir)\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n  while let Some(entry) = entries\n    .next_entry()\n    .await\n    .map_err(|e| VideoCompilerError::io(e.to_string()))?\n  {\n    let path = entry.path();\n    let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n    // Проверяем, является ли это файлом пререндера\n    if file_name.starts_with(\"prerender_\") \u0026\u0026 file_name.ends_with(\".mp4\") {\n      let metadata = entry\n        .metadata()\n        .await\n        .map_err(|e| VideoCompilerError::io(e.to_string()))?;\n\n      if metadata.is_file() {\n        deleted_size += metadata.len();\n\n        // Удаляем файл\n        if let Ok(_) = fs::remove_file(\u0026path).await {\n          _deleted_count += 1;\n        }\n      }\n    }\n  }\n\n  Ok(deleted_size)\n}\n\n// ==================== GPU КОМАНДЫ ====================\n\n/// Получить возможности GPU\n#[tauri::command]\npub async fn get_gpu_capabilities(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cGpuCapabilities\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n\n  detector\n    .get_gpu_capabilities()\n    .await\n    .map_err(|e| VideoCompilerError::gpu(format!(\"Failed to get GPU capabilities: {}\", e)))\n}\n\n/// Получить информацию о текущем GPU\n#[tauri::command]\npub async fn get_current_gpu_info(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cOption\u003cGpuInfo\u003e\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n\n  match detector.get_gpu_capabilities().await {\n    Ok(capabilities) =\u003e Ok(capabilities.current_gpu),\n    Err(_) =\u003e Ok(None),\n  }\n}\n\n/// Проверить доступность аппаратного ускорения\n#[tauri::command]\npub async fn check_hardware_acceleration(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cbool\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n\n  match detector.detect_available_encoders().await {\n    Ok(encoders) =\u003e Ok(!encoders.is_empty()),\n    Err(_) =\u003e Ok(false),\n  }\n}\n\n// ==================== КЭШИРОВАНИЕ ====================\n\n/// Получить статистику кэша\n#[tauri::command]\npub async fn get_cache_stats(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cCacheStats\u003e {\n  let cache = state.cache_manager.read().await;\n  Ok(cache.get_stats().clone())\n}\n\n/// Очистить кэш\n#[tauri::command]\npub async fn clear_cache(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c()\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_all().await;\n  Ok(())\n}\n\n/// Очистить кэш превью\n#[tauri::command]\npub async fn clear_preview_cache(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c()\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_previews().await;\n  Ok(())\n}\n\n// ==================== НАСТРОЙКИ ====================\n\n/// Получить настройки компилятора\n#[tauri::command]\npub async fn get_compiler_settings(\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cCompilerSettings\u003e {\n  let settings = state.settings.read().await;\n  Ok(settings.clone())\n}\n\n/// Обновить настройки компилятора\n#[tauri::command]\npub async fn update_compiler_settings(\n  new_settings: CompilerSettings,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003c()\u003e {\n  let mut settings = state.settings.write().await;\n  *settings = new_settings;\n  Ok(())\n}\n\n/// Установить путь к FFmpeg\n#[tauri::command]\npub async fn set_ffmpeg_path(path: String, _state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cbool\u003e {\n  // Проверяем, что FFmpeg доступен по указанному пути\n  let output = tokio::process::Command::new(\u0026path)\n    .arg(\"-version\")\n    .output()\n    .await;\n\n  match output {\n    Ok(output) if output.status.success() =\u003e {\n      // TODO: Обновить путь в состоянии\n      Ok(true)\n    }\n    _ =\u003e Err(VideoCompilerError::DependencyMissing(format!(\n      \"FFmpeg not found at path: {}\",\n      path\n    ))),\n  }\n}\n\n// ==================== ДИАГНОСТИКА ====================\n\n/// Получить информацию о системе для диагностики\n#[tauri::command]\npub async fn get_system_info(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003cSystemInfo\u003e {\n  let detector = GpuDetector::new(state.ffmpeg_path.clone());\n  let gpu_capabilities = detector.get_gpu_capabilities().await.ok();\n\n  Ok(SystemInfo {\n    os: std::env::consts::OS.to_string(),\n    arch: std::env::consts::ARCH.to_string(),\n    ffmpeg_path: state.ffmpeg_path.clone(),\n    temp_directory: std::env::temp_dir().to_string_lossy().to_string(),\n    gpu_capabilities,\n    available_memory: get_available_memory(),\n    cpu_cores: std::thread::available_parallelism()\n      .map(|n| n.get())\n      .unwrap_or(1),\n  })\n}\n\n/// Информация о системе\n#[derive(Debug, serde::Serialize)]\npub struct SystemInfo {\n  pub os: String,\n  pub arch: String,\n  pub ffmpeg_path: String,\n  pub temp_directory: String,\n  pub gpu_capabilities: Option\u003cGpuCapabilities\u003e,\n  pub available_memory: Option\u003cu64\u003e,\n  pub cpu_cores: usize,\n}\n\n/// Получить доступную память системы\nfn get_available_memory() -\u003e Option\u003cu64\u003e {\n  #[cfg(target_os = \"linux\")]\n  {\n    // Читаем /proc/meminfo\n    use std::fs;\n    if let Ok(content) = fs::read_to_string(\"/proc/meminfo\") {\n      for line in content.lines() {\n        if line.starts_with(\"MemAvailable:\") {\n          if let Some(kb) = line.split_whitespace().nth(1) {\n            if let Ok(kb_val) = kb.parse::\u003cu64\u003e() {\n              return Some(kb_val * 1024); // Конвертируем в байты\n            }\n          }\n        }\n      }\n    }\n  }\n\n  #[cfg(target_os = \"macos\")]\n  {\n    // Используем sysctl\n    use std::process::Command;\n    if let Ok(output) = Command::new(\"sysctl\").args([\"-n\", \"hw.memsize\"]).output() {\n      if let Ok(mem_str) = String::from_utf8(output.stdout) {\n        if let Ok(mem_bytes) = mem_str.trim().parse::\u003cu64\u003e() {\n          return Some(mem_bytes);\n        }\n      }\n    }\n  }\n\n  #[cfg(target_os = \"windows\")]\n  {\n    // Для Windows можно использовать WMI или другие системные API\n    // Пока возвращаем None\n  }\n\n  None\n}\n\n// ==================== ИЗВЛЕЧЕНИЕ КАДРОВ ====================\n\n/// Параметры для извлечения кадров для timeline\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct TimelineFrameExtractionRequest {\n  /// Путь к видео файлу\n  pub video_path: String,\n  /// Длительность видео\n  pub duration: f64,\n  /// Интервал между кадрами (секунды)\n  pub interval: f64,\n  /// Максимальное количество кадров\n  pub max_frames: Option\u003cusize\u003e,\n}\n\n/// Результат извлечения кадра для timeline\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct TimelineFrame {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные кадра (base64)\n  pub frame_data: String,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Извлечь кадры для timeline\n#[tauri::command]\npub async fn extract_timeline_frames(\n  request: TimelineFrameExtractionRequest,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cTimelineFrame\u003e\u003e {\n  use base64::engine::general_purpose::STANDARD as BASE64;\n  use base64::Engine as _;\n  use std::path::Path;\n\n  let manager = FrameExtractionManager::new(state.cache_manager.clone());\n\n  // Настройки для timeline превью\n  let settings = ExtractionSettings {\n    strategy: ExtractionStrategy::Combined {\n      min_interval: request.interval,\n      include_scene_changes: true,\n      include_keyframes: true,\n    },\n    purpose: ExtractionPurpose::TimelinePreview,\n    resolution: (160, 90), // Маленькое разрешение для timeline\n    quality: 60,\n    format: crate::video_compiler::schema::PreviewFormat::Jpeg,\n    max_frames: request.max_frames,\n    gpu_decode: true,\n    parallel_extraction: true,\n    thread_count: None,\n  };\n\n  let path = Path::new(\u0026request.video_path);\n  let _video_info = manager.preview_generator.get_video_info(path).await?;\n\n  // Создаем фейковый клип для использования существующей функции\n  let clip = Clip {\n    id: Uuid::new_v4().to_string(),\n    source_path: path.to_path_buf(),\n    start_time: 0.0,\n    end_time: request.duration,\n    source_start: 0.0,\n    source_end: request.duration,\n    speed: 1.0,\n    volume: 1.0,\n    locked: false,\n    effects: Vec::new(),\n    filters: Vec::new(),\n    template_id: None,\n    template_cell: None,\n    style_template_id: None,\n    properties: HashMap::new(),\n  };\n\n  let frames = manager\n    .extract_frames_for_clip(\u0026clip, Some(settings))\n    .await?;\n\n  // Преобразуем в формат для фронтенда\n  Ok(\n    frames\n      .into_iter()\n      .map(|frame| TimelineFrame {\n        timestamp: frame.timestamp,\n        frame_data: BASE64.encode(\u0026frame.data),\n        is_keyframe: frame.is_keyframe,\n      })\n      .collect(),\n  )\n}\n\n/// Результат распознавания кадра\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct RecognitionFrameResult {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные кадра\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Разрешение\n  pub resolution: [u32; 2],\n  /// Оценка изменения сцены\n  pub scene_change_score: Option\u003cf32\u003e,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Извлечь кадры для распознавания\n#[tauri::command]\npub async fn extract_recognition_frames(\n  video_path: String,\n  purpose: String,\n  _interval: f64,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cRecognitionFrameResult\u003e\u003e {\n  use std::path::Path;\n\n  let manager = FrameExtractionManager::new(state.cache_manager.clone());\n\n  // Парсим цель извлечения\n  let extraction_purpose = match purpose.as_str() {\n    \"object_detection\" =\u003e ExtractionPurpose::ObjectDetection,\n    \"scene_recognition\" =\u003e ExtractionPurpose::SceneRecognition,\n    \"text_recognition\" =\u003e ExtractionPurpose::TextRecognition,\n    _ =\u003e ExtractionPurpose::ObjectDetection,\n  };\n\n  let path = Path::new(\u0026video_path);\n  let video_info = manager.preview_generator.get_video_info(path).await?;\n\n  let frames = manager\n    .extract_frames_for_recognition(path, video_info.duration, extraction_purpose)\n    .await?;\n\n  // Преобразуем в формат для фронтенда\n  Ok(\n    frames\n      .into_iter()\n      .map(|frame| RecognitionFrameResult {\n        timestamp: frame.timestamp,\n        frame_data: frame.frame_data,\n        resolution: [frame.resolution.0, frame.resolution.1],\n        scene_change_score: frame.scene_change_score,\n        is_keyframe: frame.is_keyframe,\n      })\n      .collect(),\n  )\n}\n\n/// Параметры для извлечения кадров субтитров\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct SubtitleFrameResult {\n  /// ID субтитра\n  pub subtitle_id: String,\n  /// Текст субтитра\n  pub subtitle_text: String,\n  /// Временная метка кадра\n  pub timestamp: f64,\n  /// Данные кадра (base64)\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Время начала субтитра\n  pub start_time: f64,\n  /// Время окончания субтитра\n  pub end_time: f64,\n}\n\n/// Извлечь кадры для субтитров\n#[tauri::command]\npub async fn extract_subtitle_frames(\n  video_path: String,\n  subtitles: Vec\u003cSubtitle\u003e,\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cVec\u003cSubtitleFrameResult\u003e\u003e {\n  use std::path::Path;\n\n  let manager = FrameExtractionManager::new(state.cache_manager.clone());\n  let path = Path::new(\u0026video_path);\n\n  let frames = manager\n    .extract_frames_for_subtitles(path, \u0026subtitles, None)\n    .await?;\n\n  // Преобразуем в формат для фронтенда\n  Ok(\n    frames\n      .into_iter()\n      .map(|frame| SubtitleFrameResult {\n        subtitle_id: frame.subtitle_id,\n        subtitle_text: frame.subtitle_text,\n        timestamp: frame.timestamp,\n        frame_data: frame.frame_data,\n        start_time: frame.start_time,\n        end_time: frame.end_time,\n      })\n      .collect(),\n  )\n}\n\n/// Очистить кэш кадров\n#[tauri::command]\npub async fn clear_frame_cache(state: State\u003c'_, VideoCompilerState\u003e) -\u003e Result\u003c()\u003e {\n  let mut cache = state.cache_manager.write().await;\n  cache.clear_previews().await;\n  Ok(())\n}\n\n/// Проверить доступность FFmpeg и его возможности\n#[tauri::command]\npub async fn check_ffmpeg_capabilities(\n  state: State\u003c'_, VideoCompilerState\u003e,\n) -\u003e Result\u003cFfmpegCapabilities\u003e {\n  let ffmpeg_path = \u0026state.ffmpeg_path;\n\n  // Проверяем версию FFmpeg\n  let version_output = tokio::process::Command::new(ffmpeg_path)\n    .arg(\"-version\")\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::DependencyMissing(format!(\"FFmpeg not found: {}\", e)))?;\n\n  let version_str = String::from_utf8_lossy(\u0026version_output.stdout);\n  let version = extract_ffmpeg_version(\u0026version_str);\n\n  // Проверяем доступные кодеки\n  let codecs_output = tokio::process::Command::new(ffmpeg_path)\n    .arg(\"-codecs\")\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::io(format!(\"Failed to get codecs: {}\", e)))?;\n\n  let codecs_str = String::from_utf8_lossy(\u0026codecs_output.stdout);\n  let available_codecs = extract_available_codecs(\u0026codecs_str);\n\n  // Проверяем доступные энкодеры\n  let encoders_output = tokio::process::Command::new(ffmpeg_path)\n    .arg(\"-encoders\")\n    .output()\n    .await\n    .map_err(|e| VideoCompilerError::io(format!(\"Failed to get encoders: {}\", e)))?;\n\n  let encoders_str = String::from_utf8_lossy(\u0026encoders_output.stdout);\n  let hardware_encoders = extract_hardware_encoders(\u0026encoders_str);\n\n  Ok(FfmpegCapabilities {\n    version,\n    available_codecs,\n    hardware_encoders,\n    path: ffmpeg_path.clone(),\n  })\n}\n\n/// Возможности FFmpeg\n#[derive(Debug, serde::Serialize)]\npub struct FfmpegCapabilities {\n  pub version: String,\n  pub available_codecs: Vec\u003cString\u003e,\n  pub hardware_encoders: Vec\u003cString\u003e,\n  pub path: String,\n}\n\n/// Извлечь версию FFmpeg из вывода\nfn extract_ffmpeg_version(output: \u0026str) -\u003e String {\n  for line in output.lines() {\n    if line.starts_with(\"ffmpeg version\") {\n      return line.to_string();\n    }\n  }\n  \"Unknown\".to_string()\n}\n\n/// Извлечь доступные кодеки\nfn extract_available_codecs(output: \u0026str) -\u003e Vec\u003cString\u003e {\n  let mut codecs = Vec::new();\n  let important_codecs = [\"h264\", \"h265\", \"vp8\", \"vp9\", \"av1\", \"aac\", \"mp3\", \"opus\"];\n\n  for line in output.lines() {\n    for codec in \u0026important_codecs {\n      if line.contains(codec) \u0026\u0026 !codecs.contains(\u0026codec.to_string()) {\n        codecs.push(codec.to_string());\n      }\n    }\n  }\n\n  codecs\n}\n\n/// Извлечь аппаратные энкодеры\nfn extract_hardware_encoders(output: \u0026str) -\u003e Vec\u003cString\u003e {\n  let mut encoders = Vec::new();\n  let hw_encoders = [\n    \"h264_nvenc\",\n    \"hevc_nvenc\",\n    \"h264_qsv\",\n    \"hevc_qsv\",\n    \"h264_vaapi\",\n    \"hevc_vaapi\",\n    \"h264_videotoolbox\",\n    \"hevc_videotoolbox\",\n    \"h264_amf\",\n    \"hevc_amf\",\n  ];\n\n  for line in output.lines() {\n    for encoder in \u0026hw_encoders {\n      if line.contains(encoder) \u0026\u0026 !encoders.contains(\u0026encoder.to_string()) {\n        encoders.push(encoder.to_string());\n      }\n    }\n  }\n\n  encoders\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":23}},{"line":44,"address":[],"length":0,"stats":{"Line":23}},{"line":45,"address":[],"length":0,"stats":{"Line":23}},{"line":48,"address":[],"length":0,"stats":{"Line":23}},{"line":50,"address":[],"length":0,"stats":{"Line":23}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":4}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":4}},{"line":379,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":382,"address":[],"length":0,"stats":{"Line":4794}},{"line":383,"address":[],"length":0,"stats":{"Line":2398}},{"line":384,"address":[],"length":0,"stats":{"Line":2398}},{"line":385,"address":[],"length":0,"stats":{"Line":4796}},{"line":388,"address":[],"length":0,"stats":{"Line":2396}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":440,"address":[],"length":0,"stats":{"Line":2}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":4}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":451,"address":[],"length":0,"stats":{"Line":2}},{"line":452,"address":[],"length":0,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":4}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":4794}},{"line":460,"address":[],"length":0,"stats":{"Line":2398}},{"line":461,"address":[],"length":0,"stats":{"Line":2398}},{"line":462,"address":[],"length":0,"stats":{"Line":4796}},{"line":465,"address":[],"length":0,"stats":{"Line":2396}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":1}},{"line":647,"address":[],"length":0,"stats":{"Line":2}},{"line":648,"address":[],"length":0,"stats":{"Line":1}},{"line":649,"address":[],"length":0,"stats":{"Line":1}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":2}},{"line":929,"address":[],"length":0,"stats":{"Line":4}},{"line":930,"address":[],"length":0,"stats":{"Line":2}},{"line":931,"address":[],"length":0,"stats":{"Line":1}},{"line":934,"address":[],"length":0,"stats":{"Line":1}},{"line":938,"address":[],"length":0,"stats":{"Line":1}},{"line":939,"address":[],"length":0,"stats":{"Line":1}},{"line":940,"address":[],"length":0,"stats":{"Line":1}},{"line":942,"address":[],"length":0,"stats":{"Line":8}},{"line":943,"address":[],"length":0,"stats":{"Line":119}},{"line":944,"address":[],"length":0,"stats":{"Line":4}},{"line":945,"address":[],"length":0,"stats":{"Line":2}},{"line":950,"address":[],"length":0,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":1}},{"line":955,"address":[],"length":0,"stats":{"Line":1}},{"line":956,"address":[],"length":0,"stats":{"Line":1}},{"line":957,"address":[],"length":0,"stats":{"Line":1}},{"line":958,"address":[],"length":0,"stats":{"Line":1}},{"line":959,"address":[],"length":0,"stats":{"Line":1}},{"line":960,"address":[],"length":0,"stats":{"Line":1}},{"line":961,"address":[],"length":0,"stats":{"Line":1}},{"line":962,"address":[],"length":0,"stats":{"Line":1}},{"line":963,"address":[],"length":0,"stats":{"Line":1}},{"line":964,"address":[],"length":0,"stats":{"Line":1}},{"line":965,"address":[],"length":0,"stats":{"Line":1}},{"line":966,"address":[],"length":0,"stats":{"Line":1}},{"line":969,"address":[],"length":0,"stats":{"Line":4}},{"line":970,"address":[],"length":0,"stats":{"Line":63}},{"line":971,"address":[],"length":0,"stats":{"Line":4}},{"line":972,"address":[],"length":0,"stats":{"Line":2}},{"line":977,"address":[],"length":0,"stats":{"Line":1}}],"covered":72,"coverable":354},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","error.rs"],"content":"//! Error - Модуль обработки ошибок Video Compiler\n//!\n//! Этот модуль определяет типы ошибок, которые могут возникнуть при работе\n//! с Video Compiler модулем, включая ошибки FFmpeg, валидации и I/O операций.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Результат операции Video Compiler\npub type Result\u003cT\u003e = std::result::Result\u003cT, VideoCompilerError\u003e;\n\n/// Основные типы ошибок Video Compiler\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum VideoCompilerError {\n  /// Ошибка валидации схемы проекта\n  ValidationError(String),\n\n  /// Ошибка FFmpeg (код выхода, stderr)\n  FFmpegError {\n    exit_code: Option\u003ci32\u003e,\n    stderr: String,\n    command: String,\n  },\n\n  /// Отсутствующая зависимость (FFmpeg, библиотеки)\n  DependencyMissing(String),\n\n  /// Ошибка ввода/вывода\n  IoError(String),\n\n  /// Ошибка сериализации/десериализации\n  SerializationError(String),\n\n  /// Медиа файл не найден или недоступен\n  MediaFileError { path: String, reason: String },\n\n  /// Неподдерживаемый формат медиа\n  UnsupportedFormat { format: String, file_path: String },\n\n  /// Ошибка рендеринга\n  RenderError {\n    job_id: String,\n    stage: String,\n    message: String,\n  },\n\n  /// Ошибка генерации превью\n  PreviewError { timestamp: f64, reason: String },\n\n  /// Ошибка кэша\n  CacheError(String),\n\n  /// Ошибка конфигурации\n  ConfigError(String),\n\n  /// Нехватка ресурсов (память, диск)\n  ResourceError {\n    resource_type: String,\n    available: String,\n    required: String,\n  },\n\n  /// Тайм-аут операции\n  TimeoutError {\n    operation: String,\n    timeout_seconds: u64,\n  },\n\n  /// Операция была отменена пользователем\n  CancelledError(String),\n\n  /// Ошибка GPU ускорения\n  GpuError(String),\n\n  /// GPU недоступен или не поддерживается\n  GpuUnavailable(String),\n\n  /// Ошибка ввода/вывода (переименовано для ясности)\n  Io(String),\n\n  /// Внутренняя ошибка\n  InternalError(String),\n\n  /// Неизвестная ошибка\n  Unknown(String),\n}\n\nimpl fmt::Display for VideoCompilerError {\n  fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    match self {\n      VideoCompilerError::ValidationError(msg) =\u003e {\n        write!(f, \"Ошибка валидации: {}\", msg)\n      }\n      VideoCompilerError::FFmpegError {\n        exit_code,\n        stderr,\n        command,\n      } =\u003e {\n        write!(\n          f,\n          \"Ошибка FFmpeg (код выхода: {:?}): {}\\nКоманда: {}\",\n          exit_code, stderr, command\n        )\n      }\n      VideoCompilerError::DependencyMissing(dep) =\u003e {\n        write!(f, \"Отсутствует зависимость: {}\", dep)\n      }\n      VideoCompilerError::IoError(msg) =\u003e {\n        write!(f, \"Ошибка ввода/вывода: {}\", msg)\n      }\n      VideoCompilerError::SerializationError(msg) =\u003e {\n        write!(f, \"Ошибка сериализации: {}\", msg)\n      }\n      VideoCompilerError::MediaFileError { path, reason } =\u003e {\n        write!(f, \"Ошибка медиа файла '{}': {}\", path, reason)\n      }\n      VideoCompilerError::UnsupportedFormat { format, file_path } =\u003e {\n        write!(\n          f,\n          \"Неподдерживаемый формат '{}' для файла '{}'\",\n          format, file_path\n        )\n      }\n      VideoCompilerError::RenderError {\n        job_id,\n        stage,\n        message,\n      } =\u003e {\n        write!(\n          f,\n          \"Ошибка рендеринга [{}] на этапе '{}': {}\",\n          job_id, stage, message\n        )\n      }\n      VideoCompilerError::PreviewError { timestamp, reason } =\u003e {\n        write!(f, \"Ошибка генерации превью на {}с: {}\", timestamp, reason)\n      }\n      VideoCompilerError::CacheError(msg) =\u003e {\n        write!(f, \"Ошибка кэша: {}\", msg)\n      }\n      VideoCompilerError::ConfigError(msg) =\u003e {\n        write!(f, \"Ошибка конфигурации: {}\", msg)\n      }\n      VideoCompilerError::ResourceError {\n        resource_type,\n        available,\n        required,\n      } =\u003e {\n        write!(\n          f,\n          \"Нехватка ресурса '{}': доступно {}, требуется {}\",\n          resource_type, available, required\n        )\n      }\n      VideoCompilerError::TimeoutError {\n        operation,\n        timeout_seconds,\n      } =\u003e {\n        write!(\n          f,\n          \"Тайм-аут операции '{}' ({}с)\",\n          operation, timeout_seconds\n        )\n      }\n      VideoCompilerError::CancelledError(msg) =\u003e {\n        write!(f, \"Операция отменена: {}\", msg)\n      }\n      VideoCompilerError::GpuError(msg) =\u003e {\n        write!(f, \"Ошибка GPU: {}\", msg)\n      }\n      VideoCompilerError::GpuUnavailable(msg) =\u003e {\n        write!(f, \"GPU недоступен: {}\", msg)\n      }\n      VideoCompilerError::Io(msg) =\u003e {\n        write!(f, \"Ошибка ввода/вывода: {}\", msg)\n      }\n      VideoCompilerError::InternalError(msg) =\u003e {\n        write!(f, \"Внутренняя ошибка: {}\", msg)\n      }\n      VideoCompilerError::Unknown(msg) =\u003e {\n        write!(f, \"Неизвестная ошибка: {}\", msg)\n      }\n    }\n  }\n}\n\nimpl std::error::Error for VideoCompilerError {}\n\nimpl VideoCompilerError {\n  /// Создать ошибку GPU\n  pub fn gpu(message: impl Into\u003cString\u003e) -\u003e Self {\n    VideoCompilerError::GpuError(message.into())\n  }\n\n  /// Создать ошибку недоступности GPU\n  pub fn gpu_unavailable(message: impl Into\u003cString\u003e) -\u003e Self {\n    VideoCompilerError::GpuUnavailable(message.into())\n  }\n\n  /// Создать ошибку I/O\n  pub fn io(message: impl Into\u003cString\u003e) -\u003e Self {\n    VideoCompilerError::Io(message.into())\n  }\n\n  /// Проверить, является ли ошибка связанной с GPU\n  pub fn is_gpu_related(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::GpuError(_) | VideoCompilerError::GpuUnavailable(_)\n    )\n  }\n\n  /// Получить сообщение об ошибке\n  pub fn message(\u0026self) -\u003e String {\n    self.to_string()\n  }\n\n  /// Проверить, можно ли использовать fallback на CPU\n  pub fn should_fallback_to_cpu(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::GpuError(_) | VideoCompilerError::GpuUnavailable(_)\n    )\n  }\n}\n\n// Конверсии из стандартных ошибок\nimpl From\u003cstd::io::Error\u003e for VideoCompilerError {\n  fn from(error: std::io::Error) -\u003e Self {\n    VideoCompilerError::IoError(error.to_string())\n  }\n}\n\nimpl From\u003cserde_json::Error\u003e for VideoCompilerError {\n  fn from(error: serde_json::Error) -\u003e Self {\n    VideoCompilerError::SerializationError(error.to_string())\n  }\n}\n\nimpl From\u003cuuid::Error\u003e for VideoCompilerError {\n  fn from(error: uuid::Error) -\u003e Self {\n    VideoCompilerError::InternalError(format!(\"UUID error: {}\", error))\n  }\n}\n\nimpl From\u003ctokio::time::error::Elapsed\u003e for VideoCompilerError {\n  fn from(_error: tokio::time::error::Elapsed) -\u003e Self {\n    VideoCompilerError::TimeoutError {\n      operation: \"Unknown\".to_string(),\n      timeout_seconds: 0,\n    }\n  }\n}\n\n/// Вспомогательные функции для создания ошибок\nimpl VideoCompilerError {\n  /// Создать ошибку валидации\n  pub fn validation\u003cS: Into\u003cString\u003e\u003e(message: S) -\u003e Self {\n    VideoCompilerError::ValidationError(message.into())\n  }\n\n  /// Создать ошибку FFmpeg\n  pub fn ffmpeg\u003cS1: Into\u003cString\u003e, S2: Into\u003cString\u003e\u003e(\n    exit_code: Option\u003ci32\u003e,\n    stderr: S1,\n    command: S2,\n  ) -\u003e Self {\n    VideoCompilerError::FFmpegError {\n      exit_code,\n      stderr: stderr.into(),\n      command: command.into(),\n    }\n  }\n\n  /// Создать ошибку медиа файла\n  pub fn media_file\u003cP: Into\u003cString\u003e, R: Into\u003cString\u003e\u003e(path: P, reason: R) -\u003e Self {\n    VideoCompilerError::MediaFileError {\n      path: path.into(),\n      reason: reason.into(),\n    }\n  }\n\n  /// Создать ошибку неподдерживаемого формата\n  pub fn unsupported_format\u003cF: Into\u003cString\u003e, P: Into\u003cString\u003e\u003e(format: F, file_path: P) -\u003e Self {\n    VideoCompilerError::UnsupportedFormat {\n      format: format.into(),\n      file_path: file_path.into(),\n    }\n  }\n\n  /// Создать ошибку рендеринга\n  pub fn render\u003cJ: Into\u003cString\u003e, S: Into\u003cString\u003e, M: Into\u003cString\u003e\u003e(\n    job_id: J,\n    stage: S,\n    message: M,\n  ) -\u003e Self {\n    VideoCompilerError::RenderError {\n      job_id: job_id.into(),\n      stage: stage.into(),\n      message: message.into(),\n    }\n  }\n\n  /// Создать ошибку превью\n  pub fn preview(timestamp: f64, reason: String) -\u003e Self {\n    VideoCompilerError::PreviewError { timestamp, reason }\n  }\n\n  /// Создать ошибку ресурсов\n  pub fn resource\u003cS: Into\u003cString\u003e\u003e(resource_type: S, available: S, required: S) -\u003e Self {\n    VideoCompilerError::ResourceError {\n      resource_type: resource_type.into(),\n      available: available.into(),\n      required: required.into(),\n    }\n  }\n\n  /// Создать ошибку тайм-аута\n  pub fn timeout\u003cS: Into\u003cString\u003e\u003e(operation: S, timeout_seconds: u64) -\u003e Self {\n    VideoCompilerError::TimeoutError {\n      operation: operation.into(),\n      timeout_seconds,\n    }\n  }\n\n  /// Проверить, является ли ошибка критической (требует остановки процесса)\n  pub fn is_critical(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::DependencyMissing(_)\n        | VideoCompilerError::ResourceError { .. }\n        | VideoCompilerError::InternalError(_)\n    )\n  }\n\n  /// Проверить, можно ли повторить операцию\n  pub fn is_retryable(\u0026self) -\u003e bool {\n    matches!(\n      self,\n      VideoCompilerError::IoError(_)\n        | VideoCompilerError::TimeoutError { .. }\n        | VideoCompilerError::CacheError(_)\n    )\n  }\n\n  /// Получить код ошибки для логирования\n  pub fn error_code(\u0026self) -\u003e \u0026'static str {\n    match self {\n      VideoCompilerError::ValidationError(_) =\u003e \"VALIDATION_ERROR\",\n      VideoCompilerError::FFmpegError { .. } =\u003e \"FFMPEG_ERROR\",\n      VideoCompilerError::DependencyMissing(_) =\u003e \"DEPENDENCY_MISSING\",\n      VideoCompilerError::IoError(_) =\u003e \"IO_ERROR\",\n      VideoCompilerError::SerializationError(_) =\u003e \"SERIALIZATION_ERROR\",\n      VideoCompilerError::MediaFileError { .. } =\u003e \"MEDIA_FILE_ERROR\",\n      VideoCompilerError::UnsupportedFormat { .. } =\u003e \"UNSUPPORTED_FORMAT\",\n      VideoCompilerError::RenderError { .. } =\u003e \"RENDER_ERROR\",\n      VideoCompilerError::PreviewError { .. } =\u003e \"PREVIEW_ERROR\",\n      VideoCompilerError::CacheError(_) =\u003e \"CACHE_ERROR\",\n      VideoCompilerError::ConfigError(_) =\u003e \"CONFIG_ERROR\",\n      VideoCompilerError::ResourceError { .. } =\u003e \"RESOURCE_ERROR\",\n      VideoCompilerError::TimeoutError { .. } =\u003e \"TIMEOUT_ERROR\",\n      VideoCompilerError::CancelledError(_) =\u003e \"CANCELLED_ERROR\",\n      VideoCompilerError::GpuError(_) =\u003e \"GPU_ERROR\",\n      VideoCompilerError::GpuUnavailable(_) =\u003e \"GPU_UNAVAILABLE\",\n      VideoCompilerError::Io(_) =\u003e \"IO_ERROR\",\n      VideoCompilerError::InternalError(_) =\u003e \"INTERNAL_ERROR\",\n      VideoCompilerError::Unknown(_) =\u003e \"UNKNOWN_ERROR\",\n    }\n  }\n}\n\n/// Результат операции с дополнительной информацией\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DetailedResult\u003cT\u003e {\n  /// Результат операции\n  pub result: Result\u003cT\u003e,\n  /// Дополнительная информация (предупреждения, метрики)\n  pub metadata: OperationMetadata,\n}\n\n/// Метаданные операции\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OperationMetadata {\n  /// Время выполнения операции\n  pub duration_ms: u64,\n  /// Предупреждения\n  pub warnings: Vec\u003cString\u003e,\n  /// Использованные ресурсы\n  pub resources_used: ResourceUsage,\n  /// Дополнительная информация\n  pub extra: serde_json::Value,\n}\n\n/// Информация об использованных ресурсах\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct ResourceUsage {\n  /// Использовано памяти (байты)\n  pub memory_bytes: u64,\n  /// Использовано места на диске (байты)\n  pub disk_bytes: u64,\n  /// Время CPU (миллисекунды)\n  pub cpu_time_ms: u64,\n  /// Количество обработанных кадров\n  pub frames_processed: u64,\n}\n\nimpl Default for OperationMetadata {\n  fn default() -\u003e Self {\n    Self {\n      duration_ms: 0,\n      warnings: Vec::new(),\n      resources_used: ResourceUsage::default(),\n      extra: serde_json::Value::Null,\n    }\n  }\n}\n\n/// Макрос для удобного создания ошибок валидации\n#[macro_export]\nmacro_rules! validation_error {\n    ($msg:expr) =\u003e {\n        VideoCompilerError::ValidationError($msg.to_string())\n    };\n    ($fmt:expr, $($arg:tt)*) =\u003e {\n        VideoCompilerError::ValidationError(format!($fmt, $($arg)*))\n    };\n}\n\n/// Макрос для удобного создания ошибок рендеринга\n#[macro_export]\nmacro_rules! render_error {\n  ($job_id:expr, $stage:expr, $msg:expr) =\u003e {\n    VideoCompilerError::RenderError {\n      job_id: $job_id.to_string(),\n      stage: $stage.to_string(),\n      message: $msg.to_string(),\n    }\n  };\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  #[allow(unused_imports)]\n  use tokio::time::{timeout, Duration as TokioDuration};\n\n  #[test]\n  fn test_error_creation() {\n    let error = VideoCompilerError::validation(\"Test validation error\");\n    assert!(matches!(error, VideoCompilerError::ValidationError(_)));\n    assert_eq!(error.error_code(), \"VALIDATION_ERROR\");\n  }\n\n  #[test]\n  fn test_error_display() {\n    let error = VideoCompilerError::ffmpeg(\n      Some(1),\n      \"FFmpeg stderr output\",\n      \"ffmpeg -i input.mp4 output.mp4\",\n    );\n    let display_str = error.to_string();\n    assert!(display_str.contains(\"FFmpeg\"));\n    assert!(display_str.contains(\"stderr output\"));\n  }\n\n  #[test]\n  fn test_error_classification() {\n    let critical_error = VideoCompilerError::DependencyMissing(\"FFmpeg\".to_string());\n    assert!(critical_error.is_critical());\n    assert!(!critical_error.is_retryable());\n\n    let retryable_error = VideoCompilerError::IoError(\"Temporary file error\".to_string());\n    assert!(!retryable_error.is_critical());\n    assert!(retryable_error.is_retryable());\n  }\n\n  #[test]\n  fn test_error_codes() {\n    let errors = vec![\n      VideoCompilerError::ValidationError(\"test\".to_string()),\n      VideoCompilerError::FFmpegError {\n        exit_code: Some(1),\n        stderr: \"test\".to_string(),\n        command: \"test\".to_string(),\n      },\n      VideoCompilerError::DependencyMissing(\"test\".to_string()),\n      VideoCompilerError::IoError(\"test\".to_string()),\n    ];\n\n    let expected_codes = [\n      \"VALIDATION_ERROR\",\n      \"FFMPEG_ERROR\",\n      \"DEPENDENCY_MISSING\",\n      \"IO_ERROR\",\n    ];\n\n    for (error, expected_code) in errors.iter().zip(expected_codes.iter()) {\n      assert_eq!(error.error_code(), *expected_code);\n    }\n  }\n\n  #[test]\n  fn test_serialization() {\n    let error = VideoCompilerError::media_file(\"/path/to/video.mp4\", \"File not found\");\n\n    // Сериализация\n    let json = serde_json::to_string(\u0026error).unwrap();\n    assert!(json.contains(\"MediaFileError\"));\n\n    // Десериализация\n    let deserialized: VideoCompilerError = serde_json::from_str(\u0026json).unwrap();\n    match deserialized {\n      VideoCompilerError::MediaFileError { path, reason } =\u003e {\n        assert_eq!(path, \"/path/to/video.mp4\");\n        assert_eq!(reason, \"File not found\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки после десериализации\"),\n    }\n  }\n\n  #[test]\n  fn test_conversion_from_std_errors() {\n    let io_error = std::io::Error::new(std::io::ErrorKind::NotFound, \"File not found\");\n    let video_error: VideoCompilerError = io_error.into();\n    assert!(matches!(video_error, VideoCompilerError::IoError(_)));\n\n    let json_error = serde_json::from_str::\u003cserde_json::Value\u003e(\"invalid json\").unwrap_err();\n    let video_error: VideoCompilerError = json_error.into();\n    assert!(matches!(\n      video_error,\n      VideoCompilerError::SerializationError(_)\n    ));\n  }\n\n  #[test]\n  fn test_detailed_result() {\n    let metadata = OperationMetadata {\n      duration_ms: 1500,\n      warnings: vec![\"Low memory warning\".to_string()],\n      resources_used: ResourceUsage {\n        memory_bytes: 1024 * 1024 * 100, // 100 MB\n        disk_bytes: 1024 * 1024 * 50,    // 50 MB\n        cpu_time_ms: 1200,\n        frames_processed: 300,\n      },\n      extra: serde_json::json!({\"test\": \"value\"}),\n    };\n\n    let detailed_result = DetailedResult {\n      result: Ok(\"Success\".to_string()),\n      metadata,\n    };\n\n    assert!(detailed_result.result.is_ok());\n    assert_eq!(detailed_result.metadata.duration_ms, 1500);\n    assert_eq!(detailed_result.metadata.warnings.len(), 1);\n  }\n\n  #[test]\n  fn test_validation_error_macro() {\n    let error = validation_error!(\"Simple message\");\n    assert!(matches!(error, VideoCompilerError::ValidationError(_)));\n\n    let error = validation_error!(\"Formatted {} message {}\", \"test\", 42);\n    if let VideoCompilerError::ValidationError(msg) = error {\n      assert_eq!(msg, \"Formatted test message 42\");\n    } else {\n      panic!(\"Ожидалась ValidationError\");\n    }\n  }\n\n  #[test]\n  fn test_render_error_macro() {\n    let error = render_error!(\"job-123\", \"encoding\", \"FFmpeg failed\");\n    if let VideoCompilerError::RenderError {\n      job_id,\n      stage,\n      message,\n    } = error\n    {\n      assert_eq!(job_id, \"job-123\");\n      assert_eq!(stage, \"encoding\");\n      assert_eq!(message, \"FFmpeg failed\");\n    } else {\n      panic!(\"Ожидалась RenderError\");\n    }\n  }\n\n  #[test]\n  fn test_all_error_displays() {\n    // Тестируем Display для всех вариантов ошибок\n    let errors: Vec\u003c(VideoCompilerError, \u0026str)\u003e = vec![\n      (VideoCompilerError::DependencyMissing(\"FFmpeg\".to_string()), \"Отсутствует зависимость: FFmpeg\"),\n      (VideoCompilerError::IoError(\"Disk full\".to_string()), \"Ошибка ввода/вывода: Disk full\"),\n      (VideoCompilerError::SerializationError(\"Invalid JSON\".to_string()), \"Ошибка сериализации: Invalid JSON\"),\n      (VideoCompilerError::MediaFileError { path: \"/test.mp4\".to_string(), reason: \"Not found\".to_string() }, \"Ошибка медиа файла '/test.mp4': Not found\"),\n      (VideoCompilerError::UnsupportedFormat { format: \"AVI\".to_string(), file_path: \"/test.avi\".to_string() }, \"Неподдерживаемый формат 'AVI' для файла '/test.avi'\"),\n      (VideoCompilerError::RenderError { job_id: \"123\".to_string(), stage: \"encoding\".to_string(), message: \"Failed\".to_string() }, \"Ошибка рендеринга [123] на этапе 'encoding': Failed\"),\n      (VideoCompilerError::PreviewError { timestamp: 10.5, reason: \"Frame extraction failed\".to_string() }, \"Ошибка генерации превью на 10.5с: Frame extraction failed\"),\n      (VideoCompilerError::CacheError(\"Cache corrupted\".to_string()), \"Ошибка кэша: Cache corrupted\"),\n      (VideoCompilerError::ConfigError(\"Invalid settings\".to_string()), \"Ошибка конфигурации: Invalid settings\"),\n      (VideoCompilerError::ResourceError { resource_type: \"memory\".to_string(), available: \"1GB\".to_string(), required: \"2GB\".to_string() }, \"Нехватка ресурса 'memory': доступно 1GB, требуется 2GB\"),\n      (VideoCompilerError::TimeoutError { operation: \"rendering\".to_string(), timeout_seconds: 30 }, \"Тайм-аут операции 'rendering' (30с)\"),\n      (VideoCompilerError::CancelledError(\"User cancelled\".to_string()), \"Операция отменена: User cancelled\"),\n      (VideoCompilerError::GpuError(\"CUDA out of memory\".to_string()), \"Ошибка GPU: CUDA out of memory\"),\n      (VideoCompilerError::GpuUnavailable(\"No GPU found\".to_string()), \"GPU недоступен: No GPU found\"),\n      (VideoCompilerError::Io(\"Permission denied\".to_string()), \"Ошибка ввода/вывода: Permission denied\"),\n      (VideoCompilerError::InternalError(\"Unexpected state\".to_string()), \"Внутренняя ошибка: Unexpected state\"),\n      (VideoCompilerError::Unknown(\"Something went wrong\".to_string()), \"Неизвестная ошибка: Something went wrong\"),\n    ];\n\n    for (error, expected_display) in errors {\n      let display_str = error.to_string();\n      assert_eq!(display_str, expected_display);\n    }\n  }\n\n  #[test]\n  fn test_all_error_codes() {\n    // Тестируем error_code для всех вариантов\n    let test_cases = vec![\n      (VideoCompilerError::ValidationError(\"test\".to_string()), \"VALIDATION_ERROR\"),\n      (VideoCompilerError::FFmpegError { exit_code: None, stderr: \"test\".to_string(), command: \"test\".to_string() }, \"FFMPEG_ERROR\"),\n      (VideoCompilerError::DependencyMissing(\"test\".to_string()), \"DEPENDENCY_MISSING\"),\n      (VideoCompilerError::IoError(\"test\".to_string()), \"IO_ERROR\"),\n      (VideoCompilerError::SerializationError(\"test\".to_string()), \"SERIALIZATION_ERROR\"),\n      (VideoCompilerError::MediaFileError { path: \"test\".to_string(), reason: \"test\".to_string() }, \"MEDIA_FILE_ERROR\"),\n      (VideoCompilerError::UnsupportedFormat { format: \"test\".to_string(), file_path: \"test\".to_string() }, \"UNSUPPORTED_FORMAT\"),\n      (VideoCompilerError::RenderError { job_id: \"test\".to_string(), stage: \"test\".to_string(), message: \"test\".to_string() }, \"RENDER_ERROR\"),\n      (VideoCompilerError::PreviewError { timestamp: 0.0, reason: \"test\".to_string() }, \"PREVIEW_ERROR\"),\n      (VideoCompilerError::CacheError(\"test\".to_string()), \"CACHE_ERROR\"),\n      (VideoCompilerError::ConfigError(\"test\".to_string()), \"CONFIG_ERROR\"),\n      (VideoCompilerError::ResourceError { resource_type: \"test\".to_string(), available: \"test\".to_string(), required: \"test\".to_string() }, \"RESOURCE_ERROR\"),\n      (VideoCompilerError::TimeoutError { operation: \"test\".to_string(), timeout_seconds: 0 }, \"TIMEOUT_ERROR\"),\n      (VideoCompilerError::CancelledError(\"test\".to_string()), \"CANCELLED_ERROR\"),\n      (VideoCompilerError::GpuError(\"test\".to_string()), \"GPU_ERROR\"),\n      (VideoCompilerError::GpuUnavailable(\"test\".to_string()), \"GPU_UNAVAILABLE\"),\n      (VideoCompilerError::Io(\"test\".to_string()), \"IO_ERROR\"),\n      (VideoCompilerError::InternalError(\"test\".to_string()), \"INTERNAL_ERROR\"),\n      (VideoCompilerError::Unknown(\"test\".to_string()), \"UNKNOWN_ERROR\"),\n    ];\n\n    for (error, expected_code) in test_cases {\n      assert_eq!(error.error_code(), expected_code);\n    }\n  }\n\n  #[test]\n  fn test_gpu_related_errors() {\n    let gpu_error = VideoCompilerError::gpu(\"CUDA initialization failed\");\n    assert!(gpu_error.is_gpu_related());\n    assert!(gpu_error.should_fallback_to_cpu());\n\n    let gpu_unavailable = VideoCompilerError::gpu_unavailable(\"No compatible GPU\");\n    assert!(gpu_unavailable.is_gpu_related());\n    assert!(gpu_unavailable.should_fallback_to_cpu());\n\n    let non_gpu_error = VideoCompilerError::io(\"File not found\");\n    assert!(!non_gpu_error.is_gpu_related());\n    assert!(!non_gpu_error.should_fallback_to_cpu());\n  }\n\n  #[test]\n  fn test_error_message_method() {\n    let error = VideoCompilerError::validation(\"Test error\");\n    assert_eq!(error.message(), \"Ошибка валидации: Test error\");\n  }\n\n  #[test]\n  fn test_helper_constructors() {\n    // Тестируем все вспомогательные конструкторы\n    let unsupported = VideoCompilerError::unsupported_format(\"MOV\", \"/test.mov\");\n    match unsupported {\n      VideoCompilerError::UnsupportedFormat { format, file_path } =\u003e {\n        assert_eq!(format, \"MOV\");\n        assert_eq!(file_path, \"/test.mov\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let render = VideoCompilerError::render(\"job-456\", \"audio-mixing\", \"No audio tracks\");\n    match render {\n      VideoCompilerError::RenderError { job_id, stage, message } =\u003e {\n        assert_eq!(job_id, \"job-456\");\n        assert_eq!(stage, \"audio-mixing\");\n        assert_eq!(message, \"No audio tracks\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let preview = VideoCompilerError::preview(15.5, \"Invalid timestamp\".to_string());\n    match preview {\n      VideoCompilerError::PreviewError { timestamp, reason } =\u003e {\n        assert_eq!(timestamp, 15.5);\n        assert_eq!(reason, \"Invalid timestamp\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let resource = VideoCompilerError::resource(\"disk space\", \"100MB\", \"500MB\");\n    match resource {\n      VideoCompilerError::ResourceError { resource_type, available, required } =\u003e {\n        assert_eq!(resource_type, \"disk space\");\n        assert_eq!(available, \"100MB\");\n        assert_eq!(required, \"500MB\");\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n\n    let timeout = VideoCompilerError::timeout(\"video encoding\", 120);\n    match timeout {\n      VideoCompilerError::TimeoutError { operation, timeout_seconds } =\u003e {\n        assert_eq!(operation, \"video encoding\");\n        assert_eq!(timeout_seconds, 120);\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n  }\n\n  #[test]\n  fn test_is_critical_comprehensive() {\n    // Критические ошибки\n    assert!(VideoCompilerError::DependencyMissing(\"test\".to_string()).is_critical());\n    assert!(VideoCompilerError::ResourceError { resource_type: \"test\".to_string(), available: \"test\".to_string(), required: \"test\".to_string() }.is_critical());\n    assert!(VideoCompilerError::InternalError(\"test\".to_string()).is_critical());\n\n    // Некритические ошибки\n    assert!(!VideoCompilerError::ValidationError(\"test\".to_string()).is_critical());\n    assert!(!VideoCompilerError::IoError(\"test\".to_string()).is_critical());\n    assert!(!VideoCompilerError::TimeoutError { operation: \"test\".to_string(), timeout_seconds: 0 }.is_critical());\n  }\n\n  #[test]\n  fn test_is_retryable_comprehensive() {\n    // Повторяемые ошибки\n    assert!(VideoCompilerError::IoError(\"test\".to_string()).is_retryable());\n    assert!(VideoCompilerError::TimeoutError { operation: \"test\".to_string(), timeout_seconds: 0 }.is_retryable());\n    assert!(VideoCompilerError::CacheError(\"test\".to_string()).is_retryable());\n\n    // Неповторяемые ошибки\n    assert!(!VideoCompilerError::ValidationError(\"test\".to_string()).is_retryable());\n    assert!(!VideoCompilerError::DependencyMissing(\"test\".to_string()).is_retryable());\n    assert!(!VideoCompilerError::UnsupportedFormat { format: \"test\".to_string(), file_path: \"test\".to_string() }.is_retryable());\n  }\n\n  #[test]\n  fn test_uuid_error_conversion() {\n    // Создаём UUID ошибку вручную\n    let uuid_error_str = \"invalid UUID\";\n    let error = VideoCompilerError::InternalError(format!(\"UUID error: {}\", uuid_error_str));\n    match error {\n      VideoCompilerError::InternalError(msg) =\u003e {\n        assert!(msg.contains(\"UUID error\"));\n      }\n      _ =\u003e panic!(\"Неожиданный тип ошибки\"),\n    }\n  }\n\n  #[tokio::test]\n  async fn test_tokio_elapsed_error_conversion() {\n    // Тестируем конверсию из tokio::time::error::Elapsed\n    // Создаём Elapsed ошибку через тайм-аут\n    let result = timeout(TokioDuration::from_millis(1), async {\n      tokio::time::sleep(TokioDuration::from_millis(10)).await;\n    }).await;\n    \n    if let Err(elapsed) = result {\n      let video_error: VideoCompilerError = elapsed.into();\n      match video_error {\n        VideoCompilerError::TimeoutError { operation, timeout_seconds } =\u003e {\n          assert_eq!(operation, \"Unknown\");\n          assert_eq!(timeout_seconds, 0);\n        }\n        _ =\u003e panic!(\"Ожидалась TimeoutError\"),\n      }\n    }\n  }\n\n  #[test]\n  fn test_operation_metadata_default() {\n    let metadata = OperationMetadata::default();\n    assert_eq!(metadata.duration_ms, 0);\n    assert!(metadata.warnings.is_empty());\n    assert_eq!(metadata.resources_used.memory_bytes, 0);\n    assert_eq!(metadata.resources_used.disk_bytes, 0);\n    assert_eq!(metadata.resources_used.cpu_time_ms, 0);\n    assert_eq!(metadata.resources_used.frames_processed, 0);\n    assert_eq!(metadata.extra, serde_json::Value::Null);\n  }\n\n  #[test]\n  fn test_resource_usage_default() {\n    let usage = ResourceUsage::default();\n    assert_eq!(usage.memory_bytes, 0);\n    assert_eq!(usage.disk_bytes, 0);\n    assert_eq!(usage.cpu_time_ms, 0);\n    assert_eq!(usage.frames_processed, 0);\n  }\n\n  #[test]\n  fn test_detailed_result_serialization() {\n    let metadata = OperationMetadata::default();\n    let detailed_result: DetailedResult\u003cString\u003e = DetailedResult {\n      result: Err(VideoCompilerError::validation(\"Test error\")),\n      metadata,\n    };\n\n    // Сериализация\n    let json = serde_json::to_string(\u0026detailed_result).unwrap();\n    assert!(json.contains(\"ValidationError\"));\n    assert!(json.contains(\"Test error\"));\n\n    // Десериализация\n    let deserialized: DetailedResult\u003cString\u003e = serde_json::from_str(\u0026json).unwrap();\n    assert!(deserialized.result.is_err());\n  }\n\n  #[test]\n  fn test_error_implements_error_trait() {\n    let error = VideoCompilerError::validation(\"Test\");\n    // Проверяем, что VideoCompilerError реализует std::error::Error\n    let _: \u0026dyn std::error::Error = \u0026error;\n  }\n}\n","traces":[{"line":89,"address":[],"length":0,"stats":{"Line":23}},{"line":90,"address":[],"length":0,"stats":{"Line":23}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":7}},{"line":259,"address":[],"length":0,"stats":{"Line":7}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":9}},{"line":278,"address":[],"length":0,"stats":{"Line":9}},{"line":279,"address":[],"length":0,"stats":{"Line":9}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":292,"address":[],"length":0,"stats":{"Line":5}},{"line":298,"address":[],"length":0,"stats":{"Line":5}},{"line":299,"address":[],"length":0,"stats":{"Line":5}},{"line":300,"address":[],"length":0,"stats":{"Line":5}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":8}},{"line":337,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":8}},{"line":347,"address":[],"length":0,"stats":{"Line":24}},{"line":348,"address":[],"length":0,"stats":{"Line":24}},{"line":349,"address":[],"length":0,"stats":{"Line":3}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":352,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":1}},{"line":365,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":2}}],"covered":133,"coverable":135},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","ffmpeg_builder.rs"],"content":"//! FFmpeg Builder - Модуль построения команд FFmpeg\n//!\n//! Этот модуль отвечает за построение команд FFmpeg на основе схемы проекта,\n//! включая обработку треков, клипов, эффектов и настроек экспорта.\n\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse tokio::process::Command;\n\nuse crate::video_compiler::error::Result;\nuse crate::video_compiler::schema::{\n  Clip, Effect, EffectParameter, EffectType, Filter, FilterType, OutputFormat, ProjectSchema,\n  StyleElementType, StyleTemplate, Subtitle, SubtitleAlignX, SubtitleAlignY, SubtitleAnimation,\n  SubtitleAnimationType, SubtitleDirection, SubtitleFontWeight, SubtitlePosition, Template, Track,\n  TrackType, Transition,\n};\n\n/// Построитель команд FFmpeg\n#[derive(Debug, Clone)]\npub struct FFmpegBuilder {\n  /// Схема проекта\n  project: ProjectSchema,\n  /// Настройки построения\n  settings: FFmpegBuilderSettings,\n}\n\nimpl FFmpegBuilder {\n  /// Создать новый построитель\n  pub fn new(project: ProjectSchema) -\u003e Self {\n    Self {\n      project,\n      settings: FFmpegBuilderSettings::default(),\n    }\n  }\n\n  /// Создать построитель с настройками\n  pub fn with_settings(project: ProjectSchema, settings: FFmpegBuilderSettings) -\u003e Self {\n    Self { project, settings }\n  }\n\n  /// Построить команду для рендеринга проекта\n  pub async fn build_render_command(\u0026self, output_path: \u0026Path) -\u003e Result\u003cCommand\u003e {\n    let mut cmd = Command::new(\u0026self.settings.ffmpeg_path);\n\n    // Добавляем входные файлы\n    self.add_input_sources(\u0026mut cmd).await?;\n\n    // Добавляем фильтры\n    self.add_filter_complex(\u0026mut cmd).await?;\n\n    // Добавляем настройки вывода\n    self.add_output_settings(\u0026mut cmd, output_path).await?;\n\n    // Добавляем глобальные параметры\n    self.add_global_options(\u0026mut cmd);\n\n    Ok(cmd)\n  }\n\n  /// Построить команду для генерации превью\n  pub async fn build_preview_command(\n    \u0026self,\n    input_path: \u0026Path,\n    timestamp: f64,\n    output_path: \u0026Path,\n    resolution: (u32, u32),\n  ) -\u003e Result\u003cCommand\u003e {\n    let mut cmd = Command::new(\u0026self.settings.ffmpeg_path);\n\n    // Переход к временной метке\n    cmd.args([\"-ss\", \u0026timestamp.to_string()]);\n\n    // Входной файл\n    cmd.args([\"-i\", \u0026input_path.to_string_lossy()]);\n\n    // Один кадр\n    cmd.args([\"-vframes\", \"1\"]);\n\n    // Масштабирование\n    cmd.args([\"-vf\", \u0026format!(\"scale={}:{}\", resolution.0, resolution.1)]);\n\n    // Качество\n    cmd.args([\"-q:v\", \"2\"]);\n\n    // Перезапись\n    cmd.arg(\"-y\");\n\n    // Выходной файл\n    cmd.arg(output_path);\n\n    Ok(cmd)\n  }\n\n  /// Построить команду для пререндера сегмента видео\n  pub async fn build_prerender_segment_command(\n    \u0026self,\n    start_time: f64,\n    end_time: f64,\n    output_path: \u0026Path,\n    apply_effects: bool,\n  ) -\u003e Result\u003cCommand\u003e {\n    let mut cmd = Command::new(\u0026self.settings.ffmpeg_path);\n\n    // Глобальные опции\n    self.add_global_options(\u0026mut cmd);\n\n    // Добавляем входные источники\n    self.add_input_sources(\u0026mut cmd).await?;\n\n    // Временной диапазон\n    let duration = end_time - start_time;\n\n    // Построить граф фильтров только для указанного сегмента\n    if apply_effects {\n      let filter_complex = self\n        .build_segment_filter_complex(start_time, end_time)\n        .await?;\n      if !filter_complex.is_empty() {\n        cmd.args([\"-filter_complex\", \u0026filter_complex]);\n      }\n    }\n\n    // Обрезаем по времени\n    cmd.args([\"-ss\", \u0026start_time.to_string()]);\n    cmd.args([\"-t\", \u0026duration.to_string()]);\n\n    // Настройки качества для быстрого пререндера\n    cmd.args([\"-c:v\", \"libx264\"]);\n    cmd.args([\"-preset\", \"ultrafast\"]); // Быстрое кодирование\n    cmd.args([\"-crf\", \"23\"]); // Хорошее качество\n\n    // Настройки аудио\n    cmd.args([\"-c:a\", \"aac\"]);\n    cmd.args([\"-b:a\", \"192k\"]);\n\n    // Разрешение и FPS как в проекте\n    let resolution = \u0026self.project.timeline.resolution;\n    cmd.args([\"-s\", \u0026format!(\"{}x{}\", resolution.0, resolution.1)]);\n    cmd.args([\"-r\", \u0026self.project.timeline.fps.to_string()]);\n\n    // Перезапись файла\n    cmd.arg(\"-y\");\n\n    // Выходной файл\n    cmd.arg(output_path);\n\n    Ok(cmd)\n  }\n\n  /// Добавить входные источники\n  async fn add_input_sources(\u0026self, cmd: \u0026mut Command) -\u003e Result\u003c()\u003e {\n    let input_sources = self.collect_input_sources().await?;\n\n    // Проверяем, используется ли аппаратное ускорение\n    if self.project.settings.export.hardware_acceleration {\n      // Добавляем аппаратное декодирование для поддерживаемых кодировщиков\n      if let Some(preferred) = \u0026self.project.settings.export.preferred_gpu_encoder {\n        match preferred.as_str() {\n          \"nvenc\" =\u003e {\n            // NVIDIA CUDA декодирование\n            cmd.args([\"-hwaccel\", \"cuda\"]);\n            cmd.args([\"-hwaccel_output_format\", \"cuda\"]);\n          }\n          \"quicksync\" =\u003e {\n            // Intel QuickSync декодирование\n            cmd.args([\"-hwaccel\", \"qsv\"]);\n            cmd.args([\"-c:v\", \"h264_qsv\"]);\n          }\n          \"vaapi\" =\u003e {\n            // VAAPI декодирование (Linux)\n            cmd.args([\"-hwaccel\", \"vaapi\"]);\n            cmd.args([\"-hwaccel_device\", \"/dev/dri/renderD128\"]);\n            cmd.args([\"-hwaccel_output_format\", \"vaapi\"]);\n          }\n          \"videotoolbox\" =\u003e {\n            // VideoToolbox декодирование (macOS)\n            cmd.args([\"-hwaccel\", \"videotoolbox\"]);\n          }\n          \"amf\" =\u003e {\n            // AMD AMF обычно использует D3D11VA\n            cmd.args([\"-hwaccel\", \"d3d11va\"]);\n          }\n          _ =\u003e {\n            // Без аппаратного декодирования\n          }\n        }\n      }\n    }\n\n    for source in input_sources {\n      // Добавляем входной файл\n      cmd.args([\"-i\", \u0026source.path.to_string_lossy()]);\n    }\n\n    Ok(())\n  }\n\n  /// Собрать список входных источников\n  async fn collect_input_sources(\u0026self) -\u003e Result\u003cVec\u003cInputSource\u003e\u003e {\n    let mut sources = Vec::new();\n    let mut input_index = 0;\n\n    for track in \u0026self.project.tracks {\n      if !track.enabled {\n        continue;\n      }\n\n      for clip in \u0026track.clips {\n        sources.push(InputSource {\n          path: clip.source_path.clone(),\n          start_time: clip.source_start,\n          duration: clip.get_source_duration(),\n          input_index,\n          track_type: track.track_type.clone(),\n        });\n        input_index += 1;\n      }\n    }\n\n    Ok(sources)\n  }\n\n  /// Добавить комплексные фильтры\n  async fn add_filter_complex(\u0026self, cmd: \u0026mut Command) -\u003e Result\u003c()\u003e {\n    let filter_complex = self.build_filter_complex().await?;\n\n    if !filter_complex.is_empty() {\n      cmd.args([\"-filter_complex\", \u0026filter_complex]);\n\n      // Маппинг выходов\n      let has_video = !self.get_video_tracks().is_empty();\n      let has_audio = !self.get_audio_tracks().is_empty();\n      let has_subtitles = !self.project.subtitles.is_empty();\n\n      if has_video {\n        if has_subtitles {\n          cmd.args([\"-map\", \"[outv_with_subs]\"]);\n        } else {\n          cmd.args([\"-map\", \"[outv]\"]);\n        }\n      }\n\n      if has_audio {\n        cmd.args([\"-map\", \"[outa]\"]);\n      }\n    }\n\n    Ok(())\n  }\n\n  /// Построить строку комплексных фильтров\n  async fn build_filter_complex(\u0026self) -\u003e Result\u003cString\u003e {\n    let mut filters = Vec::new();\n    let mut input_index = 0;\n\n    // Обрабатываем видео треки\n    let video_tracks = self.get_video_tracks();\n    if !video_tracks.is_empty() {\n      let video_filter = self\n        .build_video_filter_chain(\u0026video_tracks, \u0026mut input_index)\n        .await?;\n      if !video_filter.is_empty() {\n        filters.push(video_filter);\n      }\n    }\n\n    // Обрабатываем аудио треки\n    let audio_tracks = self.get_audio_tracks();\n    if !audio_tracks.is_empty() {\n      let audio_filter = self\n        .build_audio_filter_chain(\u0026audio_tracks, \u0026mut input_index)\n        .await?;\n      if !audio_filter.is_empty() {\n        filters.push(audio_filter);\n      }\n    }\n\n    // Обрабатываем субтитры\n    if !self.project.subtitles.is_empty() {\n      let subtitle_filter = self.build_subtitle_filter().await?;\n      if !subtitle_filter.is_empty() {\n        filters.push(subtitle_filter);\n      }\n    }\n\n    Ok(filters.join(\";\"))\n  }\n\n  /// Построить цепочку видео фильтров\n  async fn build_video_filter_chain(\n    \u0026self,\n    tracks: \u0026[\u0026Track],\n    input_index: \u0026mut usize,\n  ) -\u003e Result\u003cString\u003e {\n    // Проверяем, используются ли шаблоны\n    let mut template_clips: HashMap\u003cString, Vec\u003c(Clip, usize, String)\u003e\u003e = HashMap::new();\n    let mut regular_clips = Vec::new();\n\n    // Разделяем клипы на обычные и с шаблонами\n    for track in tracks {\n      for (clip_index, clip) in track.clips.iter().enumerate() {\n        if let Some(template_id) = \u0026clip.template_id {\n          let clip_filter_label = format!(\"v{}\", *input_index);\n          template_clips\n            .entry(template_id.clone())\n            .or_default()\n            .push((clip.clone(), *input_index, clip_filter_label));\n        } else {\n          regular_clips.push((clip.clone(), *input_index, clip_index));\n        }\n        *input_index += 1;\n      }\n    }\n\n    let mut all_filters = Vec::new();\n\n    // Обрабатываем клипы с шаблонами\n    for (template_id, clips) in template_clips {\n      if let Some(template) = self.find_template(\u0026template_id) {\n        let template_filter = self.build_template_filter(template, \u0026clips).await?;\n        all_filters.push(template_filter);\n      }\n    }\n\n    // Обрабатываем обычные клипы\n    for (clip, input_idx, clip_idx) in regular_clips {\n      let clip_filters = self.build_clip_filters(\u0026clip, input_idx, clip_idx).await?;\n      if !clip_filters.is_empty() {\n        all_filters.push(clip_filters);\n      }\n    }\n\n    // Обрабатываем переходы между клипами\n    for transition in \u0026self.project.transitions {\n      // Находим клипы для перехода\n      let from_clip = self.find_clip_by_id(\u0026transition.from_clip_id);\n      let to_clip = self.find_clip_by_id(\u0026transition.to_clip_id);\n\n      if let (Some(from_clip), Some(to_clip)) = (from_clip, to_clip) {\n        // Находим индексы входов для клипов\n        let from_input = self.get_clip_input_index(\u0026transition.from_clip_id);\n        let to_input = self.get_clip_input_index(\u0026transition.to_clip_id);\n\n        if let (Some(from_idx), Some(to_idx)) = (from_input, to_input) {\n          let transition_filter = self\n            .build_transition_filter(transition, from_clip, to_clip, from_idx, to_idx)\n            .await?;\n          all_filters.push(transition_filter);\n        }\n      }\n    }\n\n    // Если несколько видео элементов, объединяем их\n    if all_filters.len() \u003e 1 {\n      let concat_filter = format!(\n        \"{}concat=n={}:v=1:a=0[outv]\",\n        all_filters.join(\"\"),\n        all_filters.len()\n      );\n      Ok(concat_filter)\n    } else if all_filters.len() == 1 {\n      Ok(format!(\"{}[outv]\", all_filters[0]))\n    } else {\n      Ok(String::new())\n    }\n  }\n\n  /// Построить цепочку аудио фильтров\n  async fn build_audio_filter_chain(\n    \u0026self,\n    tracks: \u0026[\u0026Track],\n    input_index: \u0026mut usize,\n  ) -\u003e Result\u003cString\u003e {\n    let mut audio_clips = Vec::new();\n    let mut clip_global_index = 0;\n\n    // Собираем все аудио клипы с их временными позициями\n    for track in tracks {\n      for clip in \u0026track.clips {\n        let mut filters = Vec::new();\n\n        // Обрезка аудио по времени источника\n        if clip.source_start \u003e 0.0 || clip.get_source_duration() \u003e 0.0 {\n          filters.push(format!(\n            \"atrim=start={}:duration={}\",\n            clip.source_start,\n            clip.get_source_duration()\n          ));\n        }\n\n        // Изменение скорости аудио\n        if (clip.speed - 1.0).abs() \u003e 0.001 {\n          if clip.speed \u003e 0.5 \u0026\u0026 clip.speed \u003c 2.0 {\n            filters.push(format!(\"atempo={}\", clip.speed));\n          } else {\n            // Для больших изменений скорости используем цепочку atempo\n            let mut temp_speed = clip.speed;\n            while temp_speed \u003e 2.0 {\n              filters.push(\"atempo=2.0\".to_string());\n              temp_speed /= 2.0;\n            }\n            while temp_speed \u003c 0.5 {\n              filters.push(\"atempo=0.5\".to_string());\n              temp_speed *= 2.0;\n            }\n            if (temp_speed - 1.0).abs() \u003e 0.001 {\n              filters.push(format!(\"atempo={}\", temp_speed));\n            }\n          }\n        }\n\n        // Применяем эффекты трека\n        for effect_id in \u0026track.effects {\n          if let Some(effect) = self.find_effect(effect_id) {\n            if self.is_audio_effect(\u0026effect.effect_type) {\n              let effect_filter = self.build_effect_filter(effect).await?;\n              if !effect_filter.is_empty() {\n                filters.push(effect_filter);\n              }\n            }\n          }\n        }\n\n        // Применяем эффекты клипа\n        for effect_id in \u0026clip.effects {\n          if let Some(effect) = self.find_effect(effect_id) {\n            if self.is_audio_effect(\u0026effect.effect_type) {\n              let effect_filter = self.build_effect_filter(effect).await?;\n              if !effect_filter.is_empty() {\n                filters.push(effect_filter);\n              }\n            }\n          }\n        }\n\n        // Применяем громкость\n        let volume = track.volume * clip.volume;\n        if (volume - 1.0).abs() \u003e 0.001 {\n          filters.push(format!(\"volume={}\", volume));\n        }\n\n        // Добавляем задержку для правильного позиционирования на timeline\n        if clip.start_time \u003e 0.0 {\n          filters.push(format!(\"adelay={}s\", clip.start_time));\n        }\n\n        // Создаем цепочку фильтров для клипа\n        let filter_chain = if !filters.is_empty() {\n          format!(\"[{}:a]{}\", *input_index, filters.join(\",\"))\n        } else {\n          format!(\"[{}:a]anull\", *input_index)\n        };\n\n        audio_clips.push((\n          clip.start_time,\n          clip.end_time - clip.start_time,\n          format!(\"{}[a{}]\", filter_chain, clip_global_index),\n        ));\n\n        *input_index += 1;\n        clip_global_index += 1;\n      }\n    }\n\n    // Если нет аудио клипов, возвращаем пустую строку\n    if audio_clips.is_empty() {\n      return Ok(String::new());\n    }\n\n    // Сортируем клипы по времени начала для правильного микширования\n    audio_clips.sort_by(|a, b| a.0.partial_cmp(\u0026b.0).unwrap());\n\n    // Если только один клип, просто возвращаем его\n    if audio_clips.len() == 1 {\n      return Ok(format!(\"{}[outa]\", audio_clips[0].2));\n    }\n\n    // Для нескольких клипов проверяем перекрытия и добавляем кроссфейды\n    let mut processed_clips = Vec::new();\n    let mut _current_output = 0;\n\n    // Обрабатываем клипы попарно для определения перекрытий\n    for i in 0..audio_clips.len() {\n      let (start_time, duration, chain) = \u0026audio_clips[i];\n      let end_time = start_time + duration;\n\n      // Проверяем перекрытие со следующим клипом\n      if i \u003c audio_clips.len() - 1 {\n        let (next_start, _, _) = \u0026audio_clips[i + 1];\n\n        if next_start \u003c \u0026end_time {\n          // Есть перекрытие, добавляем кроссфейд\n          let overlap_duration = end_time - next_start;\n          let crossfade_duration = overlap_duration.min(1.0); // Максимум 1 секунда кроссфейда\n\n          // Применяем fade out к текущему клипу\n          let fade_out = format!(\n            \"{}afade=t=out:st={}:d={}[fade_out_{}]\",\n            chain,\n            duration - crossfade_duration,\n            crossfade_duration,\n            i\n          );\n\n          processed_clips.push(fade_out);\n        } else {\n          // Нет перекрытия, используем клип как есть\n          processed_clips.push(chain.clone());\n        }\n      } else {\n        // Последний клип\n        processed_clips.push(chain.clone());\n      }\n    }\n\n    // Создаем финальную цепочку микширования\n    let filter_chains = processed_clips.join(\";\");\n    let mix_inputs: Vec\u003cString\u003e = (0..audio_clips.len())\n      .map(|i| format!(\"[a{}]\", i))\n      .collect();\n\n    Ok(format!(\n      \"{}{}amix=inputs={}:duration=longest[outa]\",\n      filter_chains,\n      mix_inputs.join(\"\"),\n      audio_clips.len()\n    ))\n  }\n\n  /// Построить фильтр перехода между клипами\n  async fn build_transition_filter(\n    \u0026self,\n    transition: \u0026Transition,\n    from_clip: \u0026Clip,\n    _to_clip: \u0026Clip,\n    from_input: usize,\n    to_input: usize,\n  ) -\u003e Result\u003cString\u003e {\n    // Базовый шаблон для xfade\n    let base_template = if let Some(template) = \u0026transition.ffmpeg_command {\n      template.clone()\n    } else {\n      match transition.transition_type.as_str() {\n        \"fade\" =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\",\n        \"wipe-horizontal\" =\u003e \"xfade=transition=wipeleft:duration={duration}:offset={offset}\",\n        \"wipe-vertical\" =\u003e \"xfade=transition=wipedown:duration={duration}:offset={offset}\",\n        \"wipe-diagonal\" =\u003e \"xfade=transition=wipetl:duration={duration}:offset={offset}\",\n        \"radial-wipe\" =\u003e \"xfade=transition=radial:duration={duration}:offset={offset}\",\n        \"dissolve\" =\u003e \"xfade=transition=dissolve:duration={duration}:offset={offset}\",\n        \"pixelize\" =\u003e \"xfade=transition=pixelize:duration={duration}:offset={offset}\",\n        \"slide\" =\u003e \"xfade=transition=slideleft:duration={duration}:offset={offset}\",\n        \"zoom-blur\" =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\", // fallback\n        \"blinds\" =\u003e \"xfade=transition=hblur:duration={duration}:offset={offset}\",\n        \"iris\" =\u003e \"xfade=transition=circleclose:duration={duration}:offset={offset}\",\n        \"tv-static\" =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\", // fallback\n        // 3D и сложные переходы требуют gl фильтр\n        \"cube-3d\" =\u003e \"gl=transition=cube:duration={duration}:offset={offset}\",\n        \"page-turn\" =\u003e \"gl=transition=pagecurl:duration={duration}:offset={offset}\",\n        \"ripple\" =\u003e \"gl=transition=ripple:duration={duration}:offset={offset}\",\n        \"morph\" =\u003e \"gl=transition=morph:duration={duration}:offset={offset}\",\n        \"glitch\" =\u003e \"gl=transition=glitch:duration={duration}:offset={offset}\",\n        \"kaleidoscope\" =\u003e \"gl=transition=kaleidoscope:duration={duration}:offset={offset}\",\n        \"shatter\" =\u003e \"gl=transition=shatter:duration={duration}:offset={offset}\",\n        \"burn\" =\u003e \"gl=transition=burn:duration={duration}:offset={offset}\",\n        \"swirl\" =\u003e \"gl=transition=swirl:duration={duration}:offset={offset}\",\n        \"wave\" =\u003e \"gl=transition=wave:duration={duration}:offset={offset}\",\n        _ =\u003e \"xfade=transition=fade:duration={duration}:offset={offset}\", // Fallback к fade\n      }\n      .to_string()\n    };\n\n    // Подставляем параметры\n    let duration = transition.duration.current;\n    let offset = from_clip.end_time - duration; // Переход начинается за duration секунд до конца первого клипа\n\n    let filter_str = base_template\n      .replace(\"{duration}\", \u0026duration.to_string())\n      .replace(\"{offset}\", \u0026offset.to_string())\n      .replace(\"{fps}\", \u0026self.project.timeline.fps.to_string())\n      .replace(\"{width}\", \u0026self.project.timeline.resolution.0.to_string())\n      .replace(\"{height}\", \u0026self.project.timeline.resolution.1.to_string());\n\n    // Добавляем дополнительные параметры если они есть\n    let mut extra_params = Vec::new();\n\n    if let Some(crate::video_compiler::schema::EffectParameter::String(direction)) =\n      transition.parameters.get(\"direction\")\n    {\n      extra_params.push(format!(\":direction={}\", direction));\n    }\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(intensity)) =\n      transition.parameters.get(\"intensity\")\n    {\n      extra_params.push(format!(\":intensity={}\", intensity));\n    }\n\n    let final_filter = if !extra_params.is_empty() {\n      format!(\"{}{}\", filter_str, extra_params.join(\"\"))\n    } else {\n      filter_str\n    };\n\n    Ok(format!(\n      \"[{}:v][{}:v]{}\",\n      from_input, to_input, final_filter\n    ))\n  }\n\n  /// Построить фильтры для клипа\n  async fn build_clip_filters(\n    \u0026self,\n    clip: \u0026Clip,\n    input_index: usize,\n    clip_index: usize,\n  ) -\u003e Result\u003cString\u003e {\n    let mut filters = Vec::new();\n\n    // Обрезка по времени\n    if clip.source_start \u003e 0.0 || clip.get_source_duration() \u003e 0.0 {\n      filters.push(format!(\n        \"[{}:v]trim=start={}:duration={}\",\n        input_index,\n        clip.source_start,\n        clip.get_source_duration()\n      ));\n    } else {\n      filters.push(format!(\"[{}:v]\", input_index));\n    }\n\n    // Изменение скорости\n    if (clip.speed - 1.0).abs() \u003e 0.001 {\n      filters.push(format!(\"setpts={}*PTS\", 1.0 / clip.speed));\n    }\n\n    // Применяем эффекты клипа\n    for effect_id in \u0026clip.effects {\n      if let Some(effect) = self.find_effect(effect_id) {\n        let effect_filter = self.build_effect_filter(effect).await?;\n        if !effect_filter.is_empty() {\n          filters.push(effect_filter);\n        }\n      }\n    }\n\n    // Применяем фильтры клипа\n    for filter_id in \u0026clip.filters {\n      if let Some(filter) = self.find_filter(filter_id) {\n        let filter_str = self.build_filter_string(filter).await?;\n        if !filter_str.is_empty() {\n          filters.push(filter_str);\n        }\n      }\n    }\n\n    let mut filter_chain = if filters.len() \u003e 1 {\n      filters.join(\",\")\n    } else if filters.len() == 1 {\n      filters[0].clone()\n    } else {\n      format!(\"[{}:v]\", input_index)\n    };\n\n    // Применяем стильный шаблон если есть\n    if let Some(style_template_id) = \u0026clip.style_template_id {\n      if let Some(style_template) = self.find_style_template(style_template_id) {\n        let style_filter = self\n          .build_style_template_filter(style_template, clip, input_index)\n          .await?;\n        if !style_filter.is_empty() {\n          filter_chain = style_filter;\n        }\n      }\n    }\n\n    Ok(format!(\"{}[v{}];\", filter_chain, clip_index))\n  }\n\n  /// Построить фильтр для эффекта\n  async fn build_effect_filter(\u0026self, effect: \u0026Effect) -\u003e Result\u003cString\u003e {\n    if !effect.enabled {\n      return Ok(String::new());\n    }\n\n    // Если есть пользовательская FFmpeg команда, используем её\n    if let Some(template) = \u0026effect.ffmpeg_command {\n      return Ok(self.process_ffmpeg_template(template, effect));\n    }\n\n    match effect.effect_type {\n      EffectType::Blur =\u003e {\n        // Frontend использует \"radius\"\n        let radius = match effect.parameters.get(\"radius\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 2.0,\n        };\n        Ok(format!(\"boxblur={}:1\", radius))\n      }\n      EffectType::Brightness =\u003e {\n        // Frontend использует \"intensity\", также проверяем \"value\" для обратной совместимости\n        let value = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"value\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 0.0,\n          },\n        };\n        Ok(format!(\"eq=brightness={}\", value))\n      }\n      EffectType::Contrast =\u003e {\n        // Frontend использует \"intensity\", также проверяем \"value\" для обратной совместимости\n        let value = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"value\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 1.0,\n          },\n        };\n        Ok(format!(\"eq=contrast={}\", value))\n      }\n      EffectType::Saturation =\u003e {\n        // Frontend использует \"intensity\", также проверяем \"value\" для обратной совместимости\n        let value = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"value\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 1.0,\n          },\n        };\n        Ok(format!(\"eq=saturation={}\", value))\n      }\n      EffectType::Speed =\u003e {\n        let speed = match effect.parameters.get(\"speed\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"setpts={}*PTS\", 1.0 / speed))\n      }\n      EffectType::Reverse =\u003e Ok(\"reverse\".to_string()),\n      EffectType::Grayscale =\u003e Ok(\"hue=s=0\".to_string()),\n      EffectType::Sepia =\u003e {\n        Ok(\"colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\".to_string())\n      }\n      EffectType::HueRotate =\u003e {\n        let angle = match effect.parameters.get(\"angle\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        Ok(format!(\"hue=h={}\", angle))\n      }\n      EffectType::Vintage =\u003e Ok(\"curves=vintage\".to_string()),\n      EffectType::Duotone =\u003e {\n        let shadows = match effect.parameters.get(\"shadows\") {\n          Some(EffectParameter::Color(val)) =\u003e format!(\"#{:06x}\", val \u0026 0xFFFFFF),\n          _ =\u003e \"#1e3a8a\".to_string(),\n        };\n        let highlights = match effect.parameters.get(\"highlights\") {\n          Some(EffectParameter::Color(val)) =\u003e format!(\"#{:06x}\", val \u0026 0xFFFFFF),\n          _ =\u003e \"#fbbf24\".to_string(),\n        };\n        Ok(format!(\n          \"duotone=shadows={}:highlights={}\",\n          shadows, highlights\n        ))\n      }\n      EffectType::Dreamy =\u003e Ok(\"gblur=sigma=1,eq=brightness=0.1:contrast=0.9\".to_string()),\n      EffectType::Infrared =\u003e Ok(\n        \"colorchannelmixer=rr=0:rg=0:rb=0:ra=1:gr=1:gg=0:gb=0:ga=0:br=0:bg=0:bb=0:ba=0\".to_string(),\n      ),\n      EffectType::Matrix =\u003e {\n        Ok(\"colorchannelmixer=rr=0:rg=1:rb=0:gr=0:gg=1:gb=0:br=0:bg=1:bb=0\".to_string())\n      }\n      EffectType::Arctic =\u003e {\n        Ok(\"eq=brightness=0.2:contrast=1.1:saturation=0.8,colorbalance=rs=-0.2:bs=0.2\".to_string())\n      }\n      EffectType::Sunset =\u003e {\n        Ok(\"eq=brightness=0.1:contrast=1.1,colorbalance=rs=0.3:gs=0.1:bs=-0.2\".to_string())\n      }\n      EffectType::Lomo =\u003e Ok(\"curves=cross_process,vignette=angle=PI/4\".to_string()),\n      EffectType::Twilight =\u003e {\n        Ok(\"eq=brightness=-0.1:contrast=1.2,colorbalance=rs=0.1:gs=-0.1:bs=0.2\".to_string())\n      }\n      EffectType::Neon =\u003e Ok(\"eq=brightness=0.2:contrast=1.4:saturation=2.0,hue=h=30\".to_string()),\n      EffectType::Invert =\u003e Ok(\"negate\".to_string()),\n      EffectType::Vignette =\u003e {\n        // Frontend использует \"intensity\" и \"radius\"\n        let intensity = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"angle\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 0.3,\n          },\n        };\n        let _radius = match effect.parameters.get(\"radius\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.8,\n        };\n        // Простая виньетка, так как сложная формула из frontend не поддерживается напрямую\n        Ok(format!(\"vignette=angle={}:x0=w/2:y0=h/2\", 1.57 + intensity))\n      }\n      EffectType::FilmGrain =\u003e {\n        // Frontend использует \"intensity\"\n        let strength = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e match effect.parameters.get(\"strength\") {\n            Some(EffectParameter::Float(val)) =\u003e *val,\n            _ =\u003e 0.5,\n          },\n        };\n        Ok(format!(\"noise=alls={}:allf=t\", (strength * 20.0) as i32))\n      }\n      EffectType::ChromaticAberration =\u003e {\n        Ok(\"chromakey=0x00ff00:0.1,pad=iw+20:ih+20:10:10\".to_string())\n      }\n      EffectType::LensFlare =\u003e Ok(\"flare=x=0.7:y=0.3:s=100\".to_string()),\n      EffectType::Glow =\u003e {\n        let intensity = match effect.parameters.get(\"intensity\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\n          \"gblur=sigma={},blend=all_mode=screen\",\n          intensity * 2.0\n        ))\n      }\n      EffectType::Sharpen =\u003e {\n        let amount = match effect.parameters.get(\"amount\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"unsharp=5:5:{}\", amount))\n      }\n      EffectType::Stabilization =\u003e Ok(\"deshake\".to_string()),\n      EffectType::NoiseReduction =\u003e Ok(\"hqdn3d\".to_string()),\n      EffectType::Noir =\u003e {\n        // Noir эффект - черно-белый с высоким контрастом\n        Ok(\"hue=s=0,eq=contrast=1.5:brightness=-0.1\".to_string())\n      }\n      EffectType::Cyberpunk =\u003e {\n        // Cyberpunk - неоновые цвета с искажениями\n        Ok(\n          \"eq=brightness=0.1:contrast=1.8:saturation=1.5,colorbalance=rs=0.5:gs=-0.3:bs=0.8\"\n            .to_string(),\n        )\n      }\n      // Аудио эффекты\n      EffectType::AudioFadeIn =\u003e {\n        let duration = match effect.parameters.get(\"duration\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"afade=t=in:d={}\", duration))\n      }\n      EffectType::AudioFadeOut =\u003e {\n        let duration = match effect.parameters.get(\"duration\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"afade=t=out:d={}\", duration))\n      }\n      EffectType::AudioCrossfade =\u003e {\n        let duration = match effect.parameters.get(\"duration\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"acrossfade=d={}\", duration))\n      }\n      EffectType::AudioEqualizer =\u003e {\n        let gain_low = match effect.parameters.get(\"gain_low\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        let gain_mid = match effect.parameters.get(\"gain_mid\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        let gain_high = match effect.parameters.get(\"gain_high\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        Ok(format!(\n          \"equalizer=f=100:g={}:t=h,equalizer=f=1000:g={}:t=h,equalizer=f=10000:g={}:t=h\",\n          gain_low, gain_mid, gain_high\n        ))\n      }\n      EffectType::AudioCompressor =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -20.0,\n        };\n        let ratio = match effect.parameters.get(\"ratio\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 4.0,\n        };\n        let attack = match effect.parameters.get(\"attack\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 5.0,\n        };\n        let release = match effect.parameters.get(\"release\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 50.0,\n        };\n        Ok(format!(\n          \"acompressor=threshold={}:ratio={}:attack={}:release={}\",\n          threshold, ratio, attack, release\n        ))\n      }\n      EffectType::AudioReverb =\u003e {\n        let room_size = match effect.parameters.get(\"room_size\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        let _damping = match effect.parameters.get(\"damping\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        let _wet = match effect.parameters.get(\"wet\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.3,\n        };\n        Ok(format!(\n          \"aecho=0.8:0.9:{}:0.3,aecho=0.8:0.7:{}:0.25\",\n          60.0 + room_size * 40.0,\n          40.0 + room_size * 30.0\n        ))\n      }\n      EffectType::AudioDelay =\u003e {\n        let delay = match effect.parameters.get(\"delay\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        let decay = match effect.parameters.get(\"decay\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.3,\n        };\n        Ok(format!(\"aecho=0.8:{}:{}:0.5\", decay, delay * 1000.0))\n      }\n      EffectType::AudioChorus =\u003e {\n        let rate = match effect.parameters.get(\"rate\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        let depth = match effect.parameters.get(\"depth\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\"chorus=0.5:0.9:50:0.4:{}:{}:t\", depth, rate))\n      }\n      EffectType::AudioDistortion =\u003e {\n        let amount = match effect.parameters.get(\"amount\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\"aoverload={}:{}\", amount * 10.0, amount * 10.0))\n      }\n      EffectType::AudioNormalize =\u003e {\n        let target = match effect.parameters.get(\"target\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -23.0,\n        };\n        Ok(format!(\"loudnorm=I={}:TP=-1.5:LRA=11\", target))\n      }\n      EffectType::AudioDenoise =\u003e {\n        let amount = match effect.parameters.get(\"amount\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.5,\n        };\n        Ok(format!(\"afftdn=nr={}\", amount * 20.0))\n      }\n      EffectType::AudioPitch =\u003e {\n        let pitch = match effect.parameters.get(\"pitch\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        Ok(format!(\"asetrate=r=48000*2^({}/12),aresample=48000\", pitch))\n      }\n      EffectType::AudioTempo =\u003e {\n        let tempo = match effect.parameters.get(\"tempo\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"atempo={}\", tempo))\n      }\n      EffectType::AudioDucking =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -30.0,\n        };\n        let ratio = match effect.parameters.get(\"ratio\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 6.0,\n        };\n        Ok(format!(\n          \"sidechaincompress=threshold={}:ratio={}\",\n          threshold, ratio\n        ))\n      }\n      EffectType::AudioGate =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -35.0,\n        };\n        let attack = match effect.parameters.get(\"attack\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 5.0,\n        };\n        Ok(format!(\"agate=threshold={}:attack={}\", threshold, attack))\n      }\n      EffectType::AudioLimiter =\u003e {\n        let limit = match effect.parameters.get(\"limit\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -1.0,\n        };\n        Ok(format!(\"alimiter=limit={}\", limit))\n      }\n      EffectType::AudioExpander =\u003e {\n        let threshold = match effect.parameters.get(\"threshold\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e -40.0,\n        };\n        let ratio = match effect.parameters.get(\"ratio\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 2.0,\n        };\n        Ok(format!(\n          \"acompressor=threshold={}:ratio={}:knee=2.0:makeup=0\",\n          threshold,\n          1.0 / ratio\n        ))\n      }\n      EffectType::AudioPan =\u003e {\n        let pan = match effect.parameters.get(\"pan\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 0.0,\n        };\n        let left = 1.0 - (pan + 1.0) / 2.0;\n        let right = (pan + 1.0) / 2.0;\n        Ok(format!(\"pan=stereo|c0={}*c0|c1={}*c1\", left, right))\n      }\n      EffectType::AudioStereoWidth =\u003e {\n        let width = match effect.parameters.get(\"width\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1.0,\n        };\n        Ok(format!(\"stereowidth=width={}\", width))\n      }\n      EffectType::AudioHighpass =\u003e {\n        let frequency = match effect.parameters.get(\"frequency\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 100.0,\n        };\n        Ok(format!(\"highpass=f={}\", frequency))\n      }\n      EffectType::AudioLowpass =\u003e {\n        let frequency = match effect.parameters.get(\"frequency\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 10000.0,\n        };\n        Ok(format!(\"lowpass=f={}\", frequency))\n      }\n      EffectType::AudioBandpass =\u003e {\n        let frequency = match effect.parameters.get(\"frequency\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 1000.0,\n        };\n        let width = match effect.parameters.get(\"width\") {\n          Some(EffectParameter::Float(val)) =\u003e *val,\n          _ =\u003e 100.0,\n        };\n        Ok(format!(\"bandpass=f={}:w={}\", frequency, width))\n      }\n    }\n  }\n\n  /// Проверить, является ли эффект аудио эффектом\n  fn is_audio_effect(\u0026self, effect_type: \u0026EffectType) -\u003e bool {\n    matches!(\n      effect_type,\n      EffectType::AudioFadeIn\n        | EffectType::AudioFadeOut\n        | EffectType::AudioCrossfade\n        | EffectType::AudioEqualizer\n        | EffectType::AudioCompressor\n        | EffectType::AudioReverb\n        | EffectType::AudioDelay\n        | EffectType::AudioChorus\n        | EffectType::AudioDistortion\n        | EffectType::AudioNormalize\n        | EffectType::AudioDenoise\n        | EffectType::AudioPitch\n        | EffectType::AudioTempo\n        | EffectType::AudioDucking\n        | EffectType::AudioGate\n        | EffectType::AudioLimiter\n        | EffectType::AudioExpander\n        | EffectType::AudioPan\n        | EffectType::AudioStereoWidth\n        | EffectType::AudioHighpass\n        | EffectType::AudioLowpass\n        | EffectType::AudioBandpass\n    )\n  }\n\n  /// Обработать шаблон FFmpeg команды с параметрами эффекта\n  fn process_ffmpeg_template(\u0026self, template: \u0026str, effect: \u0026Effect) -\u003e String {\n    let mut result = template.to_string();\n\n    // Заменяем плейсхолдеры параметрами\n    for (key, value) in \u0026effect.parameters {\n      let placeholder = format!(\"{{{}}}\", key);\n      let value_str = match value {\n        EffectParameter::Float(v) =\u003e v.to_string(),\n        EffectParameter::Int(v) =\u003e v.to_string(),\n        EffectParameter::String(v) =\u003e v.clone(),\n        EffectParameter::Bool(v) =\u003e if *v { \"1\" } else { \"0\" }.to_string(),\n        EffectParameter::Color(v) =\u003e format!(\"#{:06x}\", v \u0026 0xFFFFFF),\n        EffectParameter::FloatArray(v) =\u003e v\n          .iter()\n          .map(|f| f.to_string())\n          .collect::\u003cVec\u003c_\u003e\u003e()\n          .join(\":\"),\n        EffectParameter::FilePath(v) =\u003e v.to_string_lossy().to_string(),\n      };\n      result = result.replace(\u0026placeholder, \u0026value_str);\n    }\n\n    result\n  }\n\n  /// Построить видео эффект\n  async fn build_video_effect_filter(\u0026self, effect: \u0026Effect) -\u003e Result\u003cString\u003e {\n    match effect.name.as_str() {\n      \"blur\" =\u003e {\n        if let Some(crate::video_compiler::schema::EffectParameter::Float(radius)) =\n          effect.parameters.get(\"radius\")\n        {\n          Ok(format!(\"boxblur={}\", radius))\n        } else {\n          Ok(\"boxblur=2\".to_string())\n        }\n      }\n      \"brightness\" =\u003e {\n        if let Some(crate::video_compiler::schema::EffectParameter::Float(value)) =\n          effect.parameters.get(\"brightness\")\n        {\n          Ok(format!(\"eq=brightness={}\", value))\n        } else {\n          Ok(String::new())\n        }\n      }\n      \"contrast\" =\u003e {\n        if let Some(crate::video_compiler::schema::EffectParameter::Float(value)) =\n          effect.parameters.get(\"contrast\")\n        {\n          Ok(format!(\"eq=contrast={}\", value))\n        } else {\n          Ok(String::new())\n        }\n      }\n      _ =\u003e Ok(String::new()),\n    }\n  }\n\n  /// Построить фильтр цветокоррекции\n  async fn build_color_correction_filter(\u0026self, effect: \u0026Effect) -\u003e Result\u003cString\u003e {\n    let mut eq_params = Vec::new();\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(brightness)) =\n      effect.parameters.get(\"brightness\")\n    {\n      eq_params.push(format!(\"brightness={}\", brightness));\n    }\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(contrast)) =\n      effect.parameters.get(\"contrast\")\n    {\n      eq_params.push(format!(\"contrast={}\", contrast));\n    }\n\n    if let Some(crate::video_compiler::schema::EffectParameter::Float(saturation)) =\n      effect.parameters.get(\"saturation\")\n    {\n      eq_params.push(format!(\"saturation={}\", saturation));\n    }\n\n    if !eq_params.is_empty() {\n      Ok(format!(\"eq={}\", eq_params.join(\":\")))\n    } else {\n      Ok(String::new())\n    }\n  }\n\n  /// Добавить настройки вывода\n  async fn add_output_settings(\u0026self, cmd: \u0026mut Command, output_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    let export_settings = \u0026self.project.settings.export;\n\n    // Аппаратное ускорение (устанавливает видео кодек)\n    if export_settings.hardware_acceleration {\n      self.add_hardware_acceleration(cmd).await;\n    } else {\n      // Программный кодек видео\n      self.add_cpu_encoding(cmd, export_settings.quality);\n    }\n\n    // Аудио кодек\n    match export_settings.format {\n      OutputFormat::Mp4 | OutputFormat::Mov =\u003e {\n        cmd.args([\"-c:a\", \"aac\"]);\n      }\n      OutputFormat::Avi =\u003e {\n        cmd.args([\"-c:a\", \"mp3\"]);\n      }\n      OutputFormat::Mkv =\u003e {\n        cmd.args([\"-c:a\", \"aac\"]);\n      }\n      OutputFormat::WebM =\u003e {\n        cmd.args([\"-c:a\", \"libopus\"]);\n      }\n      _ =\u003e {\n        cmd.args([\"-c:a\", \"aac\"]);\n      }\n    }\n\n    // Битрейт видео (только если не используется CQ/CRF режим)\n    if !export_settings.hardware_acceleration {\n      cmd.args([\"-b:v\", \u0026format!(\"{}k\", export_settings.video_bitrate)]);\n    }\n\n    // Битрейт аудио\n    cmd.args([\"-b:a\", \u0026format!(\"{}k\", export_settings.audio_bitrate)]);\n\n    // FPS\n    cmd.args([\"-r\", \u0026self.project.timeline.fps.to_string()]);\n\n    // Разрешение\n    cmd.args([\n      \"-s\",\n      \u0026format!(\n        \"{}x{}\",\n        self.project.timeline.resolution.0, self.project.timeline.resolution.1\n      ),\n    ]);\n\n    // Дополнительные аргументы\n    for arg in \u0026export_settings.ffmpeg_args {\n      cmd.arg(arg);\n    }\n\n    // Выходной файл\n    cmd.arg(output_path);\n\n    Ok(())\n  }\n\n  /// Добавить аппаратное ускорение\n  async fn add_hardware_acceleration(\u0026self, cmd: \u0026mut Command) {\n    use crate::video_compiler::gpu::{GpuDetector, GpuEncoder, GpuHelper};\n\n    // Создаем детектор GPU\n    let detector = GpuDetector::new(self.settings.ffmpeg_path.clone());\n\n    // Получаем качество из настроек экспорта\n    let quality = self.project.settings.export.quality;\n\n    // Получаем кодировщик: либо предпочитаемый пользователем, либо рекомендуемый системой\n    let encoder = if let Some(preferred) = \u0026self.project.settings.export.preferred_gpu_encoder {\n      // Пытаемся использовать предпочитаемый кодировщик\n      match preferred.as_str() {\n        \"nvenc\" =\u003e Some(GpuEncoder::Nvenc),\n        \"quicksync\" =\u003e Some(GpuEncoder::QuickSync),\n        \"vaapi\" =\u003e Some(GpuEncoder::Vaapi),\n        \"videotoolbox\" =\u003e Some(GpuEncoder::VideoToolbox),\n        \"amf\" =\u003e Some(GpuEncoder::AMF),\n        _ =\u003e detector.get_recommended_encoder().await.unwrap_or(None),\n      }\n    } else {\n      detector.get_recommended_encoder().await.unwrap_or(None)\n    };\n\n    // Пытаемся использовать выбранный кодировщик\n    if let Some(encoder) = encoder {\n      // Выбираем кодек в зависимости от формата\n      let codec = match self.project.settings.export.format {\n        OutputFormat::Mp4 | OutputFormat::Mov =\u003e encoder.h264_codec_name(),\n        OutputFormat::WebM =\u003e \"libvpx-vp9\", // WebM не поддерживает GPU кодирование\n        _ =\u003e encoder.h264_codec_name(),\n      };\n\n      // Если это GPU кодек\n      if encoder.is_hardware() \u0026\u0026 codec != \"libvpx-vp9\" {\n        cmd.args([\"-c:v\", codec]);\n\n        // Добавляем специфичные параметры для GPU\n        let gpu_params = GpuHelper::get_ffmpeg_params(\u0026encoder, quality);\n        for param in gpu_params {\n          cmd.arg(param);\n        }\n\n        // Добавляем специфичные параметры для платформы\n        match encoder {\n          GpuEncoder::Nvenc =\u003e {\n            // Дополнительные оптимизации для NVENC\n            cmd.args([\"-gpu\", \"0\"]); // Использовать первый GPU\n            cmd.args([\"-b:v\", \"0\"]); // Автоматический битрейт\n          }\n          GpuEncoder::QuickSync =\u003e {\n            // Дополнительные оптимизации для QuickSync\n            cmd.args([\"-init_hw_device\", \"qsv=hw\"]);\n            cmd.args([\"-filter_hw_device\", \"hw\"]);\n          }\n          GpuEncoder::VideoToolbox =\u003e {\n            // macOS специфичные настройки\n            cmd.args([\"-allow_sw\", \"1\"]);\n          }\n          _ =\u003e {}\n        }\n\n        log::info!(\n          \"Используется GPU кодировщик: {:?} ({}), качество: {}\",\n          encoder,\n          codec,\n          quality\n        );\n      } else {\n        // Fallback на CPU для WebM или если GPU недоступен\n        self.add_cpu_encoding(cmd, quality);\n      }\n    } else {\n      // Fallback на CPU кодирование\n      self.add_cpu_encoding(cmd, quality);\n      log::warn!(\"GPU ускорение недоступно, используется CPU кодирование\");\n    }\n  }\n\n  /// Добавить CPU кодирование\n  fn add_cpu_encoding(\u0026self, cmd: \u0026mut Command, quality: u8) {\n    match self.project.settings.export.format {\n      OutputFormat::Mp4 | OutputFormat::Mov | OutputFormat::Avi =\u003e {\n        cmd.args([\"-c:v\", \"libx264\"]);\n        let crf = self.quality_to_crf(quality);\n        cmd.args([\"-crf\", \u0026crf.to_string()]);\n        cmd.args([\"-preset\", \"medium\"]);\n      }\n      OutputFormat::WebM =\u003e {\n        cmd.args([\"-c:v\", \"libvpx-vp9\"]);\n        cmd.args([\"-b:v\", \"0\"]); // VBR\n        let crf = self.quality_to_crf(quality);\n        cmd.args([\"-crf\", \u0026crf.to_string()]);\n        cmd.args([\"-deadline\", \"good\"]);\n      }\n      OutputFormat::Mkv =\u003e {\n        cmd.args([\"-c:v\", \"libx265\"]);\n        let crf = self.quality_to_crf(quality);\n        cmd.args([\"-crf\", \u0026crf.to_string()]);\n        cmd.args([\"-preset\", \"medium\"]);\n      }\n      _ =\u003e {\n        cmd.args([\"-c:v\", \"libx264\"]);\n        cmd.args([\"-crf\", \"23\"]);\n      }\n    }\n  }\n\n  /// Добавить глобальные опции\n  fn add_global_options(\u0026self, cmd: \u0026mut Command) {\n    // Перезапись выходного файла\n    cmd.arg(\"-y\");\n\n    // Скрыть баннер\n    cmd.arg(\"-hide_banner\");\n\n    // Количество потоков\n    if let Some(threads) = self.settings.threads {\n      cmd.args([\"-threads\", \u0026threads.to_string()]);\n    }\n\n    // Логирование\n    cmd.args([\"-loglevel\", \"info\"]);\n\n    // Статистика прогресса\n    cmd.arg(\"-progress\");\n    cmd.arg(\"pipe:2\");\n  }\n\n  /// Конвертировать качество (0-100) в CRF (0-51)\n  fn quality_to_crf(\u0026self, quality: u8) -\u003e u8 {\n    // Инвертируем: высокое качество = низкий CRF\n    let quality = quality.min(100) as u32;\n    let crf = (51 * (100 - quality)) / 100;\n    crf.min(51) as u8\n  }\n\n  /// Получить видео треки\n  fn get_video_tracks(\u0026self) -\u003e Vec\u003c\u0026Track\u003e {\n    self\n      .project\n      .tracks\n      .iter()\n      .filter(|track| track.track_type == TrackType::Video \u0026\u0026 track.enabled)\n      .collect()\n  }\n\n  /// Получить аудио треки\n  fn get_audio_tracks(\u0026self) -\u003e Vec\u003c\u0026Track\u003e {\n    self\n      .project\n      .tracks\n      .iter()\n      .filter(|track| track.track_type == TrackType::Audio \u0026\u0026 track.enabled)\n      .collect()\n  }\n\n  /// Найти эффект по ID\n  fn find_effect(\u0026self, effect_id: \u0026str) -\u003e Option\u003c\u0026Effect\u003e {\n    self\n      .project\n      .effects\n      .iter()\n      .find(|effect| effect.id == effect_id)\n  }\n\n  /// Найти фильтр по ID\n  fn find_filter(\u0026self, filter_id: \u0026str) -\u003e Option\u003c\u0026Filter\u003e {\n    self\n      .project\n      .filters\n      .iter()\n      .find(|filter| filter.id == filter_id)\n  }\n\n  /// Найти клип по ID\n  fn find_clip_by_id(\u0026self, id: \u0026str) -\u003e Option\u003c\u0026Clip\u003e {\n    for track in \u0026self.project.tracks {\n      if let Some(clip) = track.clips.iter().find(|c| c.id == id) {\n        return Some(clip);\n      }\n    }\n    None\n  }\n\n  /// Получить индекс входа для клипа\n  fn get_clip_input_index(\u0026self, clip_id: \u0026str) -\u003e Option\u003cusize\u003e {\n    let mut index = 0;\n    for track in \u0026self.project.tracks {\n      for clip in \u0026track.clips {\n        if clip.id == clip_id {\n          return Some(index);\n        }\n        index += 1;\n      }\n    }\n    None\n  }\n\n  /// Найти шаблон по ID\n  fn find_template(\u0026self, template_id: \u0026str) -\u003e Option\u003c\u0026Template\u003e {\n    self\n      .project\n      .templates\n      .iter()\n      .find(|template| template.id == template_id)\n  }\n\n  /// Найти стильный шаблон по ID\n  fn find_style_template(\u0026self, style_template_id: \u0026str) -\u003e Option\u003c\u0026StyleTemplate\u003e {\n    self\n      .project\n      .style_templates\n      .iter()\n      .find(|template| template.id == style_template_id)\n  }\n\n  /// Построить строку фильтра для FFmpeg\n  async fn build_filter_string(\u0026self, filter: \u0026Filter) -\u003e Result\u003cString\u003e {\n    if !filter.enabled {\n      return Ok(String::new());\n    }\n\n    // Если есть пользовательская FFmpeg команда, используем её\n    if let Some(ffmpeg_cmd) = \u0026filter.ffmpeg_command {\n      return Ok(ffmpeg_cmd.clone());\n    }\n\n    // Генерируем фильтр на основе типа\n    match filter.filter_type {\n      FilterType::Brightness =\u003e {\n        let value = filter.parameters.get(\"brightness\").unwrap_or(\u00260.0);\n        // FFmpeg использует brightness от -1 до 1, где 0 - нормальная яркость\n        Ok(format!(\"eq=brightness={}\", value))\n      }\n      FilterType::Contrast =\u003e {\n        let value = filter.parameters.get(\"contrast\").unwrap_or(\u00261.0);\n        // FFmpeg использует contrast от 0 до 2, где 1 - нормальный контраст\n        Ok(format!(\"eq=contrast={}\", value))\n      }\n      FilterType::Saturation =\u003e {\n        let value = filter.parameters.get(\"saturation\").unwrap_or(\u00261.0);\n        // FFmpeg использует saturation от 0 до 3, где 1 - нормальная насыщенность\n        Ok(format!(\"eq=saturation={}\", value))\n      }\n      FilterType::Gamma =\u003e {\n        let value = filter.parameters.get(\"gamma\").unwrap_or(\u00261.0);\n        // FFmpeg использует gamma от 0.1 до 10, где 1 - нормальная гамма\n        Ok(format!(\"eq=gamma={}\", value))\n      }\n      FilterType::Hue =\u003e {\n        let value = filter.parameters.get(\"hue\").unwrap_or(\u00260.0);\n        // FFmpeg использует hue в градусах\n        Ok(format!(\"hue=h={}\", value))\n      }\n      FilterType::Temperature =\u003e {\n        // Температура цвета через colortemperature фильтр\n        let value = filter.parameters.get(\"temperature\").unwrap_or(\u00266500.0);\n        Ok(format!(\"colortemperature=temperature={}\", value))\n      }\n      FilterType::Blur =\u003e {\n        let radius = filter.parameters.get(\"radius\").unwrap_or(\u00265.0);\n        Ok(format!(\"boxblur={}:{}\", radius, radius))\n      }\n      FilterType::Sharpen =\u003e {\n        let amount = filter.parameters.get(\"amount\").unwrap_or(\u00261.0);\n        Ok(format!(\"unsharp=5:5:{}:5:5:0\", amount))\n      }\n      FilterType::Vignette =\u003e {\n        let angle = filter.parameters.get(\"angle\").unwrap_or(\u00260.0);\n        let x0 = filter.parameters.get(\"x0\").unwrap_or(\u00260.5);\n        let y0 = filter.parameters.get(\"y0\").unwrap_or(\u00260.5);\n        Ok(format!(\"vignette=angle={}:x0={}:y0={}\", angle, x0, y0))\n      }\n      FilterType::Grain =\u003e {\n        let amount = filter.parameters.get(\"amount\").unwrap_or(\u00260.1);\n        Ok(format!(\"noise=alls={}:allf=t\", amount * 100.0))\n      }\n      _ =\u003e {\n        // Для остальных типов используем colorchannelmixer\n        Ok(self.build_color_channel_mixer_filter(filter))\n      }\n    }\n  }\n\n  /// Построить фильтр colorchannelmixer для сложных цветовых коррекций\n  fn build_color_channel_mixer_filter(\u0026self, filter: \u0026Filter) -\u003e String {\n    let mut params = Vec::new();\n\n    match filter.filter_type {\n      FilterType::Shadows =\u003e {\n        let value = filter.parameters.get(\"shadows\").unwrap_or(\u00260.0);\n        // Поднимаем тени\n        params.push(format!(\"aa={}\", 1.0 + value * 0.2));\n      }\n      FilterType::Highlights =\u003e {\n        let value = filter.parameters.get(\"highlights\").unwrap_or(\u00260.0);\n        // Опускаем светлые тона\n        params.push(format!(\"aa={}\", 1.0 - value * 0.2));\n      }\n      FilterType::Vibrance =\u003e {\n        let value = filter.parameters.get(\"vibrance\").unwrap_or(\u00260.0);\n        // Увеличиваем насыщенность менее насыщенных цветов\n        let factor = 1.0 + value * 0.5;\n        params.push(format!(\"rr={}:gg={}:bb={}\", factor, factor, factor));\n      }\n      _ =\u003e {}\n    }\n\n    if params.is_empty() {\n      String::new()\n    } else {\n      format!(\"colorchannelmixer={}\", params.join(\":\"))\n    }\n  }\n\n  /// Построить фильтр для шаблона многокамерной раскладки\n  async fn build_template_filter(\n    \u0026self,\n    template: \u0026Template,\n    clips: \u0026[(Clip, usize, String)],\n  ) -\u003e Result\u003cString\u003e {\n    let mut overlay_chain = Vec::new();\n    let resolution = self.project.timeline.resolution;\n    let base_width = resolution.0 as f32;\n    let base_height = resolution.1 as f32;\n\n    // Создаем черный фон\n    let background = format!(\"color=c=black:s={}x{}:d=1[bg]\", resolution.0, resolution.1);\n    overlay_chain.push(background);\n\n    // Обрабатываем каждый клип в шаблоне\n    for (clip, input_idx, _) in clips {\n      if let Some(cell_index) = clip.template_cell {\n        if let Some(cell) = template.cells.get(cell_index) {\n          // Применяем фильтры к клипу\n          let mut clip_filter = format!(\"[{}:v]\", input_idx);\n\n          // Масштабируем видео под размер ячейки\n          let cell_width = (base_width * cell.width / 100.0) as i32;\n          let cell_height = (base_height * cell.height / 100.0) as i32;\n\n          // Применяем режим масштабирования\n          match \u0026cell.fit_mode {\n            crate::video_compiler::schema::FitMode::Contain =\u003e {\n              // Вписываем с сохранением пропорций\n              clip_filter.push_str(\u0026format!(\n                \"scale={}:{}:force_original_aspect_ratio=decrease,pad={}:{}:(ow-iw)/2:(oh-ih)/2\",\n                cell_width, cell_height, cell_width, cell_height\n              ));\n            }\n            crate::video_compiler::schema::FitMode::Cover =\u003e {\n              // Заполняем с обрезкой\n              clip_filter.push_str(\u0026format!(\n                \"scale={}:{}:force_original_aspect_ratio=increase,crop={}:{}\",\n                cell_width, cell_height, cell_width, cell_height\n              ));\n            }\n            crate::video_compiler::schema::FitMode::Fill =\u003e {\n              // Растягиваем на весь размер\n              clip_filter.push_str(\u0026format!(\"scale={}:{}\", cell_width, cell_height));\n            }\n          }\n\n          // Применяем дополнительное масштабирование, если есть\n          if let Some(scale) = cell.scale {\n            if scale != 1.0 {\n              let scaled_width = (cell_width as f32 * scale) as i32;\n              let scaled_height = (cell_height as f32 * scale) as i32;\n              clip_filter.push_str(\u0026format!(\",scale={}:{}\", scaled_width, scaled_height));\n            }\n          }\n\n          // Добавляем метку для этого клипа\n          let clip_label = format!(\"clip{}\", cell_index);\n          clip_filter.push_str(\u0026format!(\"[{}]\", clip_label));\n          overlay_chain.push(clip_filter);\n\n          // Вычисляем позицию с учетом выравнивания\n          let x_pos = (base_width * cell.x / 100.0) as i32;\n          let y_pos = (base_height * cell.y / 100.0) as i32;\n\n          // Применяем overlay для размещения видео\n          let prev_label = if overlay_chain.len() == 2 {\n            \"bg\"\n          } else {\n            \u0026format!(\"comp{}\", overlay_chain.len() - 2)\n          };\n          let next_label = format!(\"comp{}\", overlay_chain.len() - 1);\n\n          let overlay = format!(\n            \"[{}][{}]overlay={}:{}[{}]\",\n            prev_label, clip_label, x_pos, y_pos, next_label\n          );\n          overlay_chain.push(overlay);\n        }\n      }\n    }\n\n    // Финальный вывод\n    let final_label = if overlay_chain.len() \u003e 1 {\n      format!(\"comp{}\", overlay_chain.len() - 2)\n    } else {\n      \"bg\".to_string()\n    };\n\n    Ok(format!(\"{};[{}]\", overlay_chain.join(\";\"), final_label))\n  }\n\n  /// Построить фильтр для стильного шаблона\n  async fn build_style_template_filter(\n    \u0026self,\n    template: \u0026StyleTemplate,\n    clip: \u0026Clip,\n    input_idx: usize,\n  ) -\u003e Result\u003cString\u003e {\n    let mut filter_chain = Vec::new();\n    let mut current_input = format!(\"[{}:v]\", input_idx);\n\n    // Обрабатываем каждый элемент шаблона\n    for (elem_idx, element) in template.elements.iter().enumerate() {\n      // Проверяем временные рамки элемента\n      let element_start = clip.start_time + element.timing.start;\n      let element_end = clip.start_time + element.timing.end.min(clip.get_timeline_duration());\n\n      match \u0026element.element_type {\n        StyleElementType::Text =\u003e {\n          // Генерируем текстовый оверлей\n          if let Some(text) = \u0026element.properties.text {\n            let mut drawtext_params = vec![\n              format!(\"text='{}'\", text.replace(\"'\", \"\\\\'\")),\n              format!(\"x=(w-text_w)*{}/100\", element.position.x / 100.0),\n              format!(\"y=(h-text_h)*{}/100\", element.position.y / 100.0),\n            ];\n\n            if let Some(font_size) = element.properties.font_size {\n              drawtext_params.push(format!(\"fontsize={}\", font_size));\n            }\n\n            if let Some(color) = \u0026element.properties.color {\n              drawtext_params.push(format!(\"fontcolor={}\", color));\n            }\n\n            if let Some(font_family) = \u0026element.properties.font_family {\n              drawtext_params.push(format!(\"fontfile={}\", font_family));\n            }\n\n            // Добавляем временные ограничения\n            drawtext_params.push(format!(\n              \"enable='between(t,{},{})'\",\n              element_start, element_end\n            ));\n\n            let drawtext_filter = format!(\n              \"{}drawtext={}[text{}]\",\n              current_input,\n              drawtext_params.join(\":\"),\n              elem_idx\n            );\n\n            filter_chain.push(drawtext_filter);\n            current_input = format!(\"[text{}]\", elem_idx);\n          }\n        }\n\n        StyleElementType::Shape =\u003e {\n          // Генерируем оверлей для фигуры\n          if let Some(bg_color) = \u0026element.properties.background_color {\n            let shape_label = format!(\"shape{}\", elem_idx);\n\n            // Создаем цветной прямоугольник\n            let color_filter = format!(\n              \"color=c={}:s={}x{}:d=1[{}]\",\n              bg_color,\n              (element.size.width * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.size.height * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              shape_label\n            );\n            filter_chain.push(color_filter);\n\n            // Применяем прозрачность если есть\n            let mut shape_with_alpha = shape_label.clone();\n            if let Some(opacity) = element.properties.opacity {\n              let alpha_label = format!(\"shapealpha{}\", elem_idx);\n              let alpha_filter = format!(\n                \"[{}]colorchannelmixer=aa={}[{}]\",\n                shape_label, opacity, alpha_label\n              );\n              filter_chain.push(alpha_filter);\n              shape_with_alpha = alpha_label;\n            }\n\n            // Накладываем фигуру на видео\n            let overlay_filter = format!(\n              \"{}[{}]overlay={}:{}:enable='between(t,{},{})'[comp{}]\",\n              current_input,\n              shape_with_alpha,\n              (element.position.x * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.position.y * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              element_start,\n              element_end,\n              elem_idx\n            );\n            filter_chain.push(overlay_filter);\n            current_input = format!(\"[comp{}]\", elem_idx);\n          }\n        }\n\n        StyleElementType::Image =\u003e {\n          // Для изображений нужно будет загрузить файл\n          if let Some(src) = \u0026element.properties.src {\n            let img_label = format!(\"img{}\", elem_idx);\n\n            // Загружаем изображение и масштабируем\n            let img_filter = format!(\n              \"movie={}:loop=1,scale={}:{}[{}]\",\n              src,\n              (element.size.width * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.size.height * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              img_label\n            );\n            filter_chain.push(img_filter);\n\n            // Накладываем изображение\n            let overlay_filter = format!(\n              \"{}[{}]overlay={}:{}:enable='between(t,{},{})'[comp{}]\",\n              current_input,\n              img_label,\n              (element.position.x * self.project.timeline.resolution.0 as f32 / 100.0) as i32,\n              (element.position.y * self.project.timeline.resolution.1 as f32 / 100.0) as i32,\n              element_start,\n              element_end,\n              elem_idx\n            );\n            filter_chain.push(overlay_filter);\n            current_input = format!(\"[comp{}]\", elem_idx);\n          }\n        }\n\n        _ =\u003e {\n          // Другие типы элементов пока пропускаем\n          log::warn!(\n            \"Тип элемента {:?} еще не поддерживается\",\n            element.element_type\n          );\n        }\n      }\n\n      // Применяем анимации если есть\n      for animation in \u0026element.animations {\n        current_input = self\n          .apply_element_animation(\n            \u0026current_input,\n            animation,\n            element_start,\n            element_end,\n            elem_idx,\n          )\n          .await?;\n      }\n    }\n\n    Ok(format!(\"{}{}\", filter_chain.join(\";\"), current_input))\n  }\n\n  /// Применить анимацию к элементу\n  async fn apply_element_animation(\n    \u0026self,\n    input: \u0026str,\n    animation: \u0026crate::video_compiler::schema::ElementAnimation,\n    start_time: f64,\n    _end_time: f64,\n    elem_idx: usize,\n  ) -\u003e Result\u003cString\u003e {\n    use crate::video_compiler::schema::AnimationType;\n\n    let anim_start = start_time + animation.delay.unwrap_or(0.0);\n    let anim_end = anim_start + animation.duration;\n\n    match \u0026animation.animation_type {\n      AnimationType::FadeIn =\u003e {\n        // Анимация появления\n        Ok(format!(\n          \"{}fade=in:st={}:d={}[anim{}]\",\n          input, anim_start, animation.duration, elem_idx\n        ))\n      }\n      AnimationType::FadeOut =\u003e {\n        // Анимация исчезновения\n        Ok(format!(\n          \"{}fade=out:st={}:d={}[anim{}]\",\n          input,\n          anim_end - animation.duration,\n          animation.duration,\n          elem_idx\n        ))\n      }\n      AnimationType::SlideIn =\u003e {\n        // Анимация въезда\n        let direction = animation\n          .direction\n          .as_ref()\n          .unwrap_or(\u0026crate::video_compiler::schema::AnimationDirection::Right);\n        let (x_expr, y_expr) = match direction {\n          crate::video_compiler::schema::AnimationDirection::Left =\u003e (\"w*(1-t/{})\", \"0\"),\n          crate::video_compiler::schema::AnimationDirection::Right =\u003e (\"-w+w*t/{}\", \"0\"),\n          crate::video_compiler::schema::AnimationDirection::Up =\u003e (\"0\", \"h*(1-t/{})\"),\n          crate::video_compiler::schema::AnimationDirection::Down =\u003e (\"0\", \"-h+h*t/{}\"),\n        };\n\n        Ok(format!(\n          \"{}overlay=x='if(between(t,{},{}),{},0)':y='if(between(t,{},{}),{},0)'[anim{}]\",\n          input,\n          anim_start,\n          anim_end,\n          x_expr.replace(\"{}\", \u0026animation.duration.to_string()),\n          anim_start,\n          anim_end,\n          y_expr.replace(\"{}\", \u0026animation.duration.to_string()),\n          elem_idx\n        ))\n      }\n      _ =\u003e {\n        // Другие анимации пока не реализованы\n        log::warn!(\n          \"Анимация {:?} еще не поддерживается\",\n          animation.animation_type\n        );\n        Ok(input.to_string())\n      }\n    }\n  }\n\n  /// Построить фильтр субтитров\n  async fn build_subtitle_filter(\u0026self) -\u003e Result\u003cString\u003e {\n    let mut subtitle_filters = Vec::new();\n\n    for subtitle in \u0026self.project.subtitles {\n      if !subtitle.enabled {\n        continue;\n      }\n\n      let filter = self.build_single_subtitle_filter(subtitle).await?;\n      if !filter.is_empty() {\n        subtitle_filters.push(filter);\n      }\n    }\n\n    if subtitle_filters.is_empty() {\n      return Ok(String::new());\n    }\n\n    // Соединяем субтитры с видео\n    // Предполагаем, что видео уже доступно как [outv]\n    let mut final_filter = \"[outv]\".to_string();\n\n    for (index, filter) in subtitle_filters.iter().enumerate() {\n      let input_label = if index == 0 {\n        \"[outv]\"\n      } else {\n        \u0026format!(\"[sub{}]\", index - 1)\n      };\n      let output_label = if index == subtitle_filters.len() - 1 {\n        \"[outv_with_subs]\"\n      } else {\n        \u0026format!(\"[sub{}]\", index)\n      };\n\n      final_filter = format!(\"{}{},{}{}\", final_filter, filter, input_label, output_label);\n    }\n\n    Ok(final_filter)\n  }\n\n  /// Построить фильтр для одного субтитра\n  async fn build_single_subtitle_filter(\u0026self, subtitle: \u0026Subtitle) -\u003e Result\u003cString\u003e {\n    let style = \u0026subtitle.style;\n    let pos = \u0026subtitle.position;\n\n    // Экранируем текст для FFmpeg\n    let escaped_text = self.escape_subtitle_text(\u0026subtitle.text);\n\n    // Построение основного drawtext фильтра\n    let mut drawtext_params = vec![\n      format!(\"text='{}'\", escaped_text),\n      format!(\"fontfile='{}'\", self.get_font_path(\u0026style.font_family)?),\n      format!(\"fontsize={}\", style.font_size),\n      format!(\"fontcolor={}\", style.color),\n    ];\n\n    // Позиционирование\n    let (x_pos, y_pos) = self.calculate_subtitle_position(pos);\n    drawtext_params.push(format!(\"x={}\", x_pos));\n    drawtext_params.push(format!(\"y={}\", y_pos));\n\n    // Толщина шрифта\n    let weight = match style.font_weight {\n      SubtitleFontWeight::Thin =\u003e \"thin\",\n      SubtitleFontWeight::Light =\u003e \"light\",\n      SubtitleFontWeight::Normal =\u003e \"normal\",\n      SubtitleFontWeight::Medium =\u003e \"medium\",\n      SubtitleFontWeight::Bold =\u003e \"bold\",\n      SubtitleFontWeight::Black =\u003e \"black\",\n    };\n    drawtext_params.push(format!(\"fontweight={}\", weight));\n\n    // Временные параметры\n    drawtext_params.push(format!(\n      \"enable='between(t,{},{})' \",\n      subtitle.start_time, subtitle.end_time\n    ));\n\n    // Обводка\n    if let Some(stroke_color) = \u0026style.stroke_color {\n      if style.stroke_width \u003e 0.0 {\n        drawtext_params.push(format!(\"bordercolor={}\", stroke_color));\n        drawtext_params.push(format!(\"borderw={}\", style.stroke_width));\n      }\n    }\n\n    // Тень\n    if let Some(shadow_color) = \u0026style.shadow_color {\n      if style.shadow_blur \u003e 0.0 {\n        drawtext_params.push(format!(\"shadowcolor={}\", shadow_color));\n        drawtext_params.push(format!(\"shadowx={}\", style.shadow_x));\n        drawtext_params.push(format!(\"shadowy={}\", style.shadow_y));\n      }\n    }\n\n    // Фон\n    if let Some(bg_color) = \u0026style.background_color {\n      drawtext_params.push(\"box=1\".to_string());\n      drawtext_params.push(format!(\"boxcolor={}\", bg_color));\n      drawtext_params.push(format!(\n        \"boxborderw={}\",\n        style.padding.left.max(style.padding.right)\n      ));\n    }\n\n    // Максимальная ширина\n    if style.max_width \u003e 0.0 \u0026\u0026 style.max_width \u003c 100.0 {\n      let max_width_px =\n        (self.project.timeline.resolution.0 as f32 * style.max_width / 100.0) as u32;\n      drawtext_params.push(format!(\"text_w={}\", max_width_px));\n    }\n\n    // Построение финального фильтра\n    let mut filter = format!(\"drawtext={}\", drawtext_params.join(\":\"));\n\n    // Добавляем анимации если есть\n    if !subtitle.animations.is_empty() {\n      filter = self.apply_subtitle_animations(filter, subtitle).await?;\n    }\n\n    Ok(filter)\n  }\n\n  /// Применить анимации к субтитру\n  async fn apply_subtitle_animations(\n    \u0026self,\n    base_filter: String,\n    subtitle: \u0026Subtitle,\n  ) -\u003e Result\u003cString\u003e {\n    let mut filter = base_filter;\n\n    for animation in \u0026subtitle.animations {\n      filter = self\n        .apply_single_subtitle_animation(filter, animation, subtitle)\n        .await?;\n    }\n\n    Ok(filter)\n  }\n\n  /// Применить одну анимацию к субтитру\n  async fn apply_single_subtitle_animation(\n    \u0026self,\n    base_filter: String,\n    animation: \u0026SubtitleAnimation,\n    subtitle: \u0026Subtitle,\n  ) -\u003e Result\u003cString\u003e {\n    let start_time = subtitle.start_time + animation.delay;\n    let end_time = start_time + animation.duration;\n\n    match animation.animation_type {\n      SubtitleAnimationType::FadeIn =\u003e {\n        // Плавное появление через изменение alpha\n        Ok(format!(\n          \"{}:alpha='if(between(t,{},{}), (t-{})/{}*1.0, 1.0)'\",\n          base_filter, start_time, end_time, start_time, animation.duration\n        ))\n      }\n      SubtitleAnimationType::FadeOut =\u003e {\n        // Плавное исчезновение\n        Ok(format!(\n          \"{}:alpha='if(between(t,{},{}), 1.0-(t-{})/{}*1.0, 1.0)'\",\n          base_filter, start_time, end_time, start_time, animation.duration\n        ))\n      }\n      SubtitleAnimationType::SlideIn =\u003e {\n        // Въезд с указанного направления\n        if let Some(direction) = \u0026animation.direction {\n          let (start_x, _start_y, end_x, _end_y) =\n            self.calculate_slide_positions(direction, subtitle);\n          Ok(format!(\n            \"{}:x='if(between(t,{},{}), {}+({})*((t-{})/{}), {})'\",\n            base_filter,\n            start_time,\n            end_time,\n            start_x,\n            end_x - start_x,\n            start_time,\n            animation.duration,\n            end_x\n          ))\n        } else {\n          Ok(base_filter)\n        }\n      }\n      SubtitleAnimationType::SlideOut =\u003e {\n        // Выезд в указанном направлении\n        if let Some(direction) = \u0026animation.direction {\n          let (start_x, _start_y, end_x, _end_y) =\n            self.calculate_slide_positions(direction, subtitle);\n          Ok(format!(\n            \"{}:x='if(between(t,{},{}), {}+({})*((t-{})/{}), {})'\",\n            base_filter,\n            start_time,\n            end_time,\n            start_x,\n            end_x - start_x,\n            start_time,\n            animation.duration,\n            start_x\n          ))\n        } else {\n          Ok(base_filter)\n        }\n      }\n      SubtitleAnimationType::ScaleIn =\u003e {\n        // Увеличение от 0 до полного размера\n        Ok(format!(\n          \"{}:fontsize='{}*if(between(t,{},{}), (t-{})/{}*1.0, 1.0)'\",\n          base_filter,\n          subtitle.style.font_size,\n          start_time,\n          end_time,\n          start_time,\n          animation.duration\n        ))\n      }\n      _ =\u003e {\n        // Для остальных типов анимаций пока возвращаем базовый фильтр\n        // TODO: Реализовать Typewriter, Wave, Bounce, Shake, Blink, Dissolve\n        Ok(base_filter)\n      }\n    }\n  }\n\n  /// Экранировать текст субтитра для FFmpeg\n  fn escape_subtitle_text(\u0026self, text: \u0026str) -\u003e String {\n    text\n      .replace(\"\\\\\", \"\\\\\\\\\") // Экранируем обратные слеши\n      .replace(\"'\", \"\\\\'\") // Экранируем одинарные кавычки\n      .replace(\":\", \"\\\\:\") // Экранируем двоеточия\n      .replace(\",\", \"\\\\,\") // Экранируем запятые\n      .replace(\"[\", \"\\\\[\") // Экранируем квадратные скобки\n      .replace(\"]\", \"\\\\]\")\n  }\n\n  /// Получить путь к шрифту\n  fn get_font_path(\u0026self, font_family: \u0026str) -\u003e Result\u003cString\u003e {\n    // В реальной реализации нужно искать шрифт в системе\n    // Пока используем стандартные пути\n    match font_family.to_lowercase().as_str() {\n      \"arial\" =\u003e Ok(\"/System/Library/Fonts/Arial.ttf\".to_string()),\n      \"helvetica\" =\u003e Ok(\"/System/Library/Fonts/Helvetica.ttc\".to_string()),\n      \"times\" | \"times new roman\" =\u003e Ok(\"/System/Library/Fonts/Times.ttc\".to_string()),\n      _ =\u003e {\n        // Пытаемся найти шрифт или используем fallback\n        Ok(\"/System/Library/Fonts/Arial.ttf\".to_string())\n      }\n    }\n  }\n\n  /// Вычислить позицию субтитра\n  fn calculate_subtitle_position(\u0026self, pos: \u0026SubtitlePosition) -\u003e (String, String) {\n    let resolution = \u0026self.project.timeline.resolution;\n    let screen_width = resolution.0 as f32;\n    let screen_height = resolution.1 as f32;\n\n    // Базовые координаты в пикселях\n    let base_x = (pos.x / 100.0) * screen_width;\n    let base_y = (pos.y / 100.0) * screen_height;\n\n    // Корректировка на основе выравнивания\n    let x_offset = match pos.align_x {\n      SubtitleAlignX::Left =\u003e 0.0,\n      SubtitleAlignX::Center =\u003e -0.5,\n      SubtitleAlignX::Right =\u003e -1.0,\n    };\n\n    let y_offset = match pos.align_y {\n      SubtitleAlignY::Top =\u003e 0.0,\n      SubtitleAlignY::Center =\u003e -0.5,\n      SubtitleAlignY::Bottom =\u003e -1.0,\n    };\n\n    // Добавляем отступы\n    let final_x = base_x + pos.margin.left;\n    let final_y = base_y + pos.margin.top;\n\n    // FFmpeg поддерживает выражения для центрирования\n    let x_expr = if x_offset != 0.0 {\n      format!(\"(w-text_w)*{:.1}+{}\", (x_offset as f32).abs(), final_x)\n    } else {\n      format!(\"{}\", final_x)\n    };\n\n    let y_expr = if y_offset != 0.0 {\n      format!(\"(h-text_h)*{:.1}+{}\", (y_offset as f32).abs(), final_y)\n    } else {\n      format!(\"{}\", final_y)\n    };\n\n    (x_expr, y_expr)\n  }\n\n  /// Вычислить позиции для анимации слайда\n  fn calculate_slide_positions(\n    \u0026self,\n    direction: \u0026SubtitleDirection,\n    subtitle: \u0026Subtitle,\n  ) -\u003e (f32, f32, f32, f32) {\n    let resolution = \u0026self.project.timeline.resolution;\n    let screen_width = resolution.0 as f32;\n    let screen_height = resolution.1 as f32;\n\n    let (normal_x, normal_y) = self.calculate_subtitle_position(\u0026subtitle.position);\n\n    // Парсим нормальные позиции (упрощенно)\n    let normal_x_val = normal_x.parse::\u003cf32\u003e().unwrap_or(screen_width / 2.0);\n    let normal_y_val = normal_y.parse::\u003cf32\u003e().unwrap_or(screen_height * 0.85);\n\n    match direction {\n      SubtitleDirection::Left =\u003e (-screen_width, normal_y_val, normal_x_val, normal_y_val),\n      SubtitleDirection::Right =\u003e (screen_width, normal_y_val, normal_x_val, normal_y_val),\n      SubtitleDirection::Top =\u003e (normal_x_val, -screen_height, normal_x_val, normal_y_val),\n      SubtitleDirection::Bottom =\u003e (normal_x_val, screen_height, normal_x_val, normal_y_val),\n      SubtitleDirection::Center =\u003e (normal_x_val, normal_y_val, normal_x_val, normal_y_val),\n    }\n  }\n  /// Построить граф фильтров для конкретного сегмента\n  async fn build_segment_filter_complex(\u0026self, start_time: f64, end_time: f64) -\u003e Result\u003cString\u003e {\n    let mut filter_chain = String::new();\n    let mut input_index = 0;\n\n    // Получаем только те треки и клипы, которые попадают в заданный временной диапазон\n    let video_tracks: Vec\u003c\u0026Track\u003e = self\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.enabled \u0026\u0026 t.track_type == TrackType::Video)\n      .filter(|t| {\n        // Проверяем, есть ли клипы в нужном диапазоне\n        t.clips.iter().any(|c| {\n          let clip_start = c.start_time;\n          let clip_end = c.end_time;\n          // Клип пересекается с диапазоном пререндера\n          clip_start \u003c end_time \u0026\u0026 clip_end \u003e start_time\n        })\n      })\n      .collect();\n\n    let audio_tracks: Vec\u003c\u0026Track\u003e = self\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.enabled \u0026\u0026 t.track_type == TrackType::Audio)\n      .filter(|t| {\n        t.clips.iter().any(|c| {\n          let clip_start = c.start_time;\n          let clip_end = c.end_time;\n          clip_start \u003c end_time \u0026\u0026 clip_end \u003e start_time\n        })\n      })\n      .collect();\n\n    // Строим видео цепочку\n    if !video_tracks.is_empty() {\n      let video_filter = self\n        .build_video_filter_chain(\u0026video_tracks, \u0026mut input_index)\n        .await?;\n      filter_chain.push_str(\u0026video_filter);\n    }\n\n    // Строим аудио цепочку\n    if !audio_tracks.is_empty() {\n      if !filter_chain.is_empty() {\n        filter_chain.push_str(\"; \");\n      }\n      let audio_filter = self\n        .build_audio_filter_chain(\u0026audio_tracks, \u0026mut input_index)\n        .await?;\n      filter_chain.push_str(\u0026audio_filter);\n    }\n\n    Ok(filter_chain)\n  }\n}\n\n/// Входной источник для FFmpeg\n#[derive(Debug, Clone)]\npub struct InputSource {\n  /// Путь к файлу\n  pub path: PathBuf,\n  /// Время начала в файле\n  pub start_time: f64,\n  /// Длительность\n  pub duration: f64,\n  /// Индекс входа в FFmpeg\n  pub input_index: usize,\n  /// Тип трека\n  pub track_type: TrackType,\n}\n\n/// Настройки построителя FFmpeg\n#[derive(Debug, Clone)]\npub struct FFmpegBuilderSettings {\n  /// Путь к FFmpeg\n  pub ffmpeg_path: String,\n  /// Количество потоков\n  pub threads: Option\u003cu32\u003e,\n  /// Предпочитать NVENC\n  pub prefer_nvenc: bool,\n  /// Предпочитать QuickSync\n  pub prefer_quicksync: bool,\n  /// Дополнительные глобальные параметры\n  pub global_args: Vec\u003cString\u003e,\n}\n\nimpl Default for FFmpegBuilderSettings {\n  fn default() -\u003e Self {\n    Self {\n      ffmpeg_path: \"ffmpeg\".to_string(),\n      threads: None, // Автоматическое определение\n      prefer_nvenc: true,\n      prefer_quicksync: false,\n      global_args: Vec::new(),\n    }\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::schema::{\n    Clip, Effect, EffectParameter, EffectType, ProjectSchema, Track, TrackType,\n  };\n  use std::path::PathBuf;\n\n  #[tokio::test]\n  async fn test_blur_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_blur_effect(5.0);\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"boxblur=5:1\");\n  }\n\n  #[tokio::test]\n  async fn test_brightness_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_brightness_effect(0.3);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"eq=brightness=0.3\");\n  }\n\n  #[tokio::test]\n  async fn test_contrast_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_contrast_effect(1.5);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"eq=contrast=1.5\");\n  }\n\n  #[tokio::test]\n  async fn test_saturation_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_saturation_effect(0.8);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"eq=saturation=0.8\");\n  }\n\n  #[tokio::test]\n  async fn test_speed_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_speed_effect(2.0);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"setpts=0.5*PTS\");\n  }\n\n  #[tokio::test]\n  async fn test_grayscale_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_simple_effect(EffectType::Grayscale);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"hue=s=0\");\n  }\n\n  #[tokio::test]\n  async fn test_sepia_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_simple_effect(EffectType::Sepia);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(\n      result,\n      \"colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\"\n    );\n  }\n\n  #[tokio::test]\n  async fn test_vignette_effect_ffmpeg_command() {\n    let builder = create_test_builder();\n    let effect = create_vignette_effect(3.14);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"vignette=angle=4.71:x0=w/2:y0=h/2\");\n  }\n\n  #[tokio::test]\n  async fn test_custom_ffmpeg_template() {\n    let builder = create_test_builder();\n    let effect = create_custom_effect_with_template(\"blur=sigma={intensity}\", 2.5);\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"blur=sigma=2.5\");\n  }\n\n  #[tokio::test]\n  async fn test_disabled_effect() {\n    let builder = create_test_builder();\n    let mut effect = create_simple_effect(EffectType::Blur);\n    effect.enabled = false;\n\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(result, \"\");\n  }\n\n  // Project setup helper\n  fn create_test_project() -\u003e ProjectSchema {\n    let mut project = ProjectSchema::new(\"Test Project\".to_string());\n\n    // Add video track with clip\n    let mut video_track = Track::new(TrackType::Video, \"Video Track\".to_string());\n    let video_clip = Clip::new(PathBuf::from(\"/test/video.mp4\"), 0.0, 10.0);\n    video_track.clips.push(video_clip);\n    project.tracks.push(video_track);\n\n    project\n  }\n\n  #[test]\n  fn test_ffmpeg_builder_creation() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n    assert_eq!(builder.project.metadata.name, \"Test Project\");\n  }\n\n  #[test]\n  fn test_ffmpeg_builder_with_settings() {\n    let project = create_test_project();\n    let mut settings = FFmpegBuilderSettings::default();\n    settings.ffmpeg_path = \"/custom/path/ffmpeg\".to_string();\n    settings.threads = Some(8);\n    settings.prefer_nvenc = false;\n    settings.prefer_quicksync = true;\n    settings.global_args = vec![\"-hide_banner\".to_string()];\n\n    let builder = FFmpegBuilder::with_settings(project, settings.clone());\n    assert_eq!(builder.settings.ffmpeg_path, \"/custom/path/ffmpeg\");\n    assert_eq!(builder.settings.threads, Some(8));\n    assert!(!builder.settings.prefer_nvenc);\n    assert!(builder.settings.prefer_quicksync);\n    assert_eq!(\n      builder.settings.global_args,\n      vec![\"-hide_banner\".to_string()]\n    );\n  }\n\n  #[test]\n  fn test_quality_to_crf() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    assert_eq!(builder.quality_to_crf(100), 0); // Best quality\n    assert_eq!(builder.quality_to_crf(0), 51); // Worst quality\n    assert_eq!(builder.quality_to_crf(50), 25); // Medium quality\n  }\n\n  #[test]\n  fn test_get_video_tracks() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let video_tracks = builder.get_video_tracks();\n    assert_eq!(video_tracks.len(), 1);\n    assert_eq!(video_tracks[0].track_type, TrackType::Video);\n  }\n\n  #[test]\n  fn test_get_audio_tracks() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let audio_tracks = builder.get_audio_tracks();\n    assert_eq!(audio_tracks.len(), 0); // No audio tracks in test project\n  }\n\n  #[tokio::test]\n  async fn test_collect_input_sources() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let sources = builder.collect_input_sources().await.unwrap();\n    assert_eq!(sources.len(), 1);\n    assert_eq!(sources[0].input_index, 0);\n    assert_eq!(sources[0].track_type, TrackType::Video);\n  }\n\n  #[tokio::test]\n  async fn test_build_preview_command() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let input_path = PathBuf::from(\"/test/input.mp4\");\n    let output_path = PathBuf::from(\"/test/preview.jpg\");\n\n    let cmd = builder\n      .build_preview_command(\u0026input_path, 10.0, \u0026output_path, (640, 360))\n      .await\n      .unwrap();\n\n    // Check that command contains required arguments\n    let cmd_str = format!(\"{:?}\", cmd);\n    assert!(cmd_str.contains(\"ffmpeg\"));\n    assert!(cmd_str.contains(\"-ss\"));\n    assert!(cmd_str.contains(\"10\"));\n    assert!(cmd_str.contains(\"-vframes\"));\n    assert!(cmd_str.contains(\"1\"));\n  }\n\n  #[test]\n  fn test_ffmpeg_builder_settings_default() {\n    let settings = FFmpegBuilderSettings::default();\n    assert_eq!(settings.ffmpeg_path, \"ffmpeg\");\n    assert!(settings.prefer_nvenc);\n    assert!(!settings.prefer_quicksync);\n    assert!(settings.global_args.is_empty());\n  }\n\n  #[tokio::test]\n  async fn test_build_filter_complex_empty() {\n    let project = ProjectSchema::new(\"Empty Project\".to_string());\n    let builder = FFmpegBuilder::new(project);\n\n    let filter_complex = builder.build_filter_complex().await.unwrap();\n    assert!(filter_complex.is_empty());\n  }\n\n  #[tokio::test]\n  async fn test_build_render_command() {\n    let mut project = create_test_project();\n    project.timeline.resolution = (1920, 1080);\n    project.timeline.fps = 30;\n    project.settings.export.quality = 80;\n    project.settings.export.video_bitrate = 5000;\n    project.settings.export.audio_bitrate = 192;\n\n    let builder = FFmpegBuilder::new(project);\n    let output_path = PathBuf::from(\"/test/output.mp4\");\n\n    let cmd = builder.build_render_command(\u0026output_path).await.unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"ffmpeg\"));\n    assert!(cmd_str.contains(\"/test/output.mp4\"));\n  }\n\n  #[tokio::test]\n  async fn test_add_input_sources() {\n    let mut project = create_test_project();\n    let mut audio_track = Track::new(TrackType::Audio, \"Audio Track\".to_string());\n    let audio_clip = Clip::new(PathBuf::from(\"/test/audio.mp3\"), 0.0, 10.0);\n    audio_track.clips.push(audio_clip);\n    project.tracks.push(audio_track);\n\n    let builder = FFmpegBuilder::new(project);\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n\n    builder.add_input_sources(\u0026mut cmd).await.unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"/test/video.mp4\"));\n    assert!(cmd_str.contains(\"/test/audio.mp3\"));\n  }\n\n  #[tokio::test]\n  async fn test_add_filter_complex() {\n    let mut project = create_test_project();\n    // Add effect to test filter generation\n    let mut effect = Effect::new(EffectType::Blur, \"Test Blur\".to_string());\n    effect\n      .parameters\n      .insert(\"radius\".to_string(), EffectParameter::Float(5.0));\n    effect.id = \"test-effect-123\".to_string();\n    project.tracks[0].clips[0].effects.push(effect.id.clone());\n    project.effects.push(effect);\n\n    let builder = FFmpegBuilder::new(project);\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n\n    builder.add_filter_complex(\u0026mut cmd).await.unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"-filter_complex\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_video_filter_chain() {\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n    let video_tracks = builder.get_video_tracks();\n\n    let mut input_index = 0;\n    let filter_chain = builder\n      .build_video_filter_chain(\u0026video_tracks, \u0026mut input_index)\n      .await\n      .unwrap();\n    // Should have output label\n    assert!(filter_chain.contains(\"[outv]\") || filter_chain.contains(\"[v\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_audio_filter_chain() {\n    let mut project = create_test_project();\n    // Add audio track for testing\n    let mut audio_track = Track::new(TrackType::Audio, \"Audio Track\".to_string());\n    let audio_clip = Clip::new(PathBuf::from(\"/test/audio.mp3\"), 0.0, 10.0);\n    audio_track.clips.push(audio_clip);\n    project.tracks.push(audio_track);\n\n    let builder = FFmpegBuilder::new(project);\n    let audio_tracks = builder.get_audio_tracks();\n\n    let mut input_index = 0;\n    let filter_chain = builder\n      .build_audio_filter_chain(\u0026audio_tracks, \u0026mut input_index)\n      .await\n      .unwrap();\n    // Should have volume control and output\n    assert!(filter_chain.contains(\"volume=\") || filter_chain.contains(\"[outa]\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_clip_filters() {\n    let mut clip = Clip::new(PathBuf::from(\"/test/video.mp4\"), 0.0, 10.0);\n    clip.source_start = 2.0;\n    clip.source_end = 8.0;\n    clip.speed = 2.0; // Double speed to ensure setpts is added\n\n    let project = create_test_project();\n    let builder = FFmpegBuilder::new(project);\n\n    let filters = builder.build_clip_filters(\u0026clip, 0, 0).await.unwrap();\n    assert!(filters.contains(\"trim=\"));\n    assert!(filters.contains(\"setpts=\")); // Will be added because speed != 1.0\n    assert!(filters.contains(\"[v0]\")); // Output label\n  }\n\n  #[tokio::test]\n  async fn test_process_ffmpeg_template() {\n    let builder = create_test_builder();\n    let mut effect = Effect::new(EffectType::Blur, \"Custom Blur\".to_string());\n    effect\n      .parameters\n      .insert(\"blur\".to_string(), EffectParameter::Float(10.0));\n    effect\n      .parameters\n      .insert(\"intensity\".to_string(), EffectParameter::Float(0.8));\n    effect.ffmpeg_command = Some(\"boxblur={blur}:enable='between(t,0,{intensity})'\".to_string());\n\n    let template = effect.ffmpeg_command.as_ref().unwrap();\n    let result = builder.process_ffmpeg_template(template, \u0026effect);\n\n    assert_eq!(result, \"boxblur=10:enable='between(t,0,0.8)'\");\n  }\n\n  #[tokio::test]\n  async fn test_build_video_effect_filter() {\n    let builder = create_test_builder();\n    let mut effect = Effect::new(EffectType::HueRotate, \"Hue Rotate\".to_string());\n    effect\n      .parameters\n      .insert(\"angle\".to_string(), EffectParameter::Float(45.0));\n\n    // build_video_effect_filter is a private method, use build_effect_filter instead\n    let result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert!(result.contains(\"hue=h=45\"));\n  }\n\n  #[tokio::test]\n  async fn test_build_color_correction_filter() {\n    let builder = create_test_builder();\n    let mut effect = Effect::new(EffectType::Brightness, \"Brightness\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(0.2));\n\n    let mut contrast_effect = Effect::new(EffectType::Contrast, \"Contrast\".to_string());\n    contrast_effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(1.2));\n\n    let mut saturation_effect = Effect::new(EffectType::Saturation, \"Saturation\".to_string());\n    saturation_effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(1.1));\n\n    // Test individual color correction effects through build_effect_filter\n    let brightness_result = builder.build_effect_filter(\u0026effect).await.unwrap();\n    assert_eq!(brightness_result, \"eq=brightness=0.2\");\n\n    let contrast_result = builder.build_effect_filter(\u0026contrast_effect).await.unwrap();\n    assert_eq!(contrast_result, \"eq=contrast=1.2\");\n\n    let saturation_result = builder\n      .build_effect_filter(\u0026saturation_effect)\n      .await\n      .unwrap();\n    assert_eq!(saturation_result, \"eq=saturation=1.1\");\n  }\n\n  #[tokio::test]\n  async fn test_add_output_settings() {\n    let mut project = create_test_project();\n    project.settings.export.video_bitrate = 5000; // 5Mbps\n    project.settings.export.audio_bitrate = 192; // 192kbps\n    project.settings.export.quality = 80;\n    project.settings.export.hardware_acceleration = false; // Отключаем для теста битрейта\n\n    let builder = FFmpegBuilder::new(project);\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n    let output_path = PathBuf::from(\"/test/output.mp4\");\n\n    builder\n      .add_output_settings(\u0026mut cmd, \u0026output_path)\n      .await\n      .unwrap();\n    let cmd_str = format!(\"{:?}\", cmd);\n\n    assert!(cmd_str.contains(\"-c:v\"));\n    assert!(cmd_str.contains(\"-c:a\"));\n    assert!(cmd_str.contains(\"-b:v\"));\n    assert!(cmd_str.contains(\"-b:a\"));\n    assert!(cmd_str.contains(\"-crf\"));\n    assert!(cmd_str.contains(\"/test/output.mp4\"));\n  }\n\n  #[tokio::test]\n  async fn test_add_hardware_acceleration() {\n    let mut settings = FFmpegBuilderSettings::default();\n    settings.prefer_nvenc = true;\n    let project = create_test_project();\n    let builder = FFmpegBuilder::with_settings(project, settings);\n\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n    builder.add_hardware_acceleration(\u0026mut cmd).await;\n\n    let cmd_str = format!(\"{:?}\", cmd);\n    // Should contain video codec parameter\n    assert!(cmd_str.contains(\"-c:v\"));\n  }\n\n  #[test]\n  fn test_add_global_options() {\n    let mut settings = FFmpegBuilderSettings::default();\n    settings.threads = Some(4);\n    settings.global_args = vec![\n      \"-hide_banner\".to_string(),\n      \"-loglevel\".to_string(),\n      \"error\".to_string(),\n    ];\n\n    let project = create_test_project();\n    let builder = FFmpegBuilder::with_settings(project, settings);\n\n    let mut cmd = tokio::process::Command::new(\"ffmpeg\");\n    builder.add_global_options(\u0026mut cmd);\n\n    let cmd_str = format!(\"{:?}\", cmd);\n    assert!(cmd_str.contains(\"-threads\"));\n    assert!(cmd_str.contains(\"4\"));\n    assert!(cmd_str.contains(\"-hide_banner\"));\n    assert!(cmd_str.contains(\"-loglevel\"));\n    assert!(cmd_str.contains(\"info\")); // По умолчанию используется \"info\", а не \"error\"\n    assert!(cmd_str.contains(\"-progress\"));\n  }\n\n  #[test]\n  fn test_find_effect() {\n    let mut project = create_test_project();\n    let mut effect = Effect::new(EffectType::Blur, \"Test Effect\".to_string());\n    effect.id = \"test-effect-123\".to_string();\n    project.effects.push(effect);\n    project.tracks[0].clips[0]\n      .effects\n      .push(\"test-effect-123\".to_string());\n\n    let builder = FFmpegBuilder::new(project);\n\n    let found = builder.find_effect(\"test-effect-123\");\n    assert!(found.is_some());\n    assert_eq!(found.unwrap().name, \"Test Effect\");\n\n    let not_found = builder.find_effect(\"non-existent\");\n    assert!(not_found.is_none());\n  }\n\n  fn create_test_builder() -\u003e FFmpegBuilder {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    FFmpegBuilder::new(project)\n  }\n\n  fn create_blur_effect(radius: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Blur, \"Blur\".to_string());\n    effect\n      .parameters\n      .insert(\"radius\".to_string(), EffectParameter::Float(radius));\n    effect\n  }\n\n  fn create_brightness_effect(value: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Brightness, \"Brightness\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(value));\n    effect\n  }\n\n  fn create_contrast_effect(value: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Contrast, \"Contrast\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(value));\n    effect\n  }\n\n  fn create_saturation_effect(value: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Saturation, \"Saturation\".to_string());\n    effect\n      .parameters\n      .insert(\"value\".to_string(), EffectParameter::Float(value));\n    effect\n  }\n\n  fn create_speed_effect(speed: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Speed, \"Speed\".to_string());\n    effect\n      .parameters\n      .insert(\"speed\".to_string(), EffectParameter::Float(speed));\n    effect\n  }\n\n  fn create_vignette_effect(angle: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Vignette, \"Vignette\".to_string());\n    effect\n      .parameters\n      .insert(\"angle\".to_string(), EffectParameter::Float(angle));\n    effect\n  }\n\n  fn create_simple_effect(effect_type: EffectType) -\u003e Effect {\n    Effect::new(effect_type, \"Test Effect\".to_string())\n  }\n\n  fn create_custom_effect_with_template(template: \u0026str, intensity: f32) -\u003e Effect {\n    let mut effect = Effect::new(EffectType::Noir, \"Custom Effect\".to_string());\n    effect.ffmpeg_command = Some(template.to_string());\n    effect\n      .parameters\n      .insert(\"intensity\".to_string(), EffectParameter::Float(intensity));\n    effect\n  }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":33}},{"line":32,"address":[],"length":0,"stats":{"Line":33}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":203,"address":[],"length":0,"stats":{"Line":11}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":9}},{"line":301,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":3}},{"line":318,"address":[],"length":0,"stats":{"Line":3}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":9}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":3}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":3}},{"line":362,"address":[],"length":0,"stats":{"Line":3}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":3}},{"line":379,"address":[],"length":0,"stats":{"Line":3}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[],"length":0,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":1}},{"line":386,"address":[],"length":0,"stats":{"Line":1}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":1}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":1}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":4}},{"line":617,"address":[],"length":0,"stats":{"Line":4}},{"line":620,"address":[],"length":0,"stats":{"Line":11}},{"line":621,"address":[],"length":0,"stats":{"Line":4}},{"line":622,"address":[],"length":0,"stats":{"Line":4}},{"line":623,"address":[],"length":0,"stats":{"Line":4}},{"line":624,"address":[],"length":0,"stats":{"Line":4}},{"line":625,"address":[],"length":0,"stats":{"Line":4}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":5}},{"line":633,"address":[],"length":0,"stats":{"Line":1}},{"line":637,"address":[],"length":0,"stats":{"Line":6}},{"line":638,"address":[],"length":0,"stats":{"Line":2}},{"line":639,"address":[],"length":0,"stats":{"Line":1}},{"line":640,"address":[],"length":0,"stats":{"Line":1}},{"line":641,"address":[],"length":0,"stats":{"Line":1}},{"line":647,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":4}},{"line":657,"address":[],"length":0,"stats":{"Line":2}},{"line":658,"address":[],"length":0,"stats":{"Line":2}},{"line":659,"address":[],"length":0,"stats":{"Line":2}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":4}},{"line":680,"address":[],"length":0,"stats":{"Line":30}},{"line":681,"address":[],"length":0,"stats":{"Line":15}},{"line":682,"address":[],"length":0,"stats":{"Line":1}},{"line":686,"address":[],"length":0,"stats":{"Line":15}},{"line":690,"address":[],"length":0,"stats":{"Line":13}},{"line":693,"address":[],"length":0,"stats":{"Line":2}},{"line":694,"address":[],"length":0,"stats":{"Line":2}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":4}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":2}},{"line":704,"address":[],"length":0,"stats":{"Line":2}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":2}},{"line":712,"address":[],"length":0,"stats":{"Line":4}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":2}},{"line":715,"address":[],"length":0,"stats":{"Line":2}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":2}},{"line":723,"address":[],"length":0,"stats":{"Line":4}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":2}},{"line":726,"address":[],"length":0,"stats":{"Line":2}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":2}},{"line":733,"address":[],"length":0,"stats":{"Line":2}},{"line":734,"address":[],"length":0,"stats":{"Line":1}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":1}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":1}},{"line":742,"address":[],"length":0,"stats":{"Line":1}},{"line":745,"address":[],"length":0,"stats":{"Line":2}},{"line":746,"address":[],"length":0,"stats":{"Line":1}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":1}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":2}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":790,"address":[],"length":0,"stats":{"Line":1}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":2}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":1}},{"line":799,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":2}},{"line":1106,"address":[],"length":0,"stats":{"Line":2}},{"line":1109,"address":[],"length":0,"stats":{"Line":8}},{"line":1112,"address":[],"length":0,"stats":{"Line":3}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":2}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":4}},{"line":1195,"address":[],"length":0,"stats":{"Line":2}},{"line":1198,"address":[],"length":0,"stats":{"Line":2}},{"line":1199,"address":[],"length":0,"stats":{"Line":1}},{"line":1202,"address":[],"length":0,"stats":{"Line":1}},{"line":1206,"address":[],"length":0,"stats":{"Line":2}},{"line":1207,"address":[],"length":0,"stats":{"Line":2}},{"line":1208,"address":[],"length":0,"stats":{"Line":2}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":1}},{"line":1226,"address":[],"length":0,"stats":{"Line":1}},{"line":1245,"address":[],"length":0,"stats":{"Line":2}},{"line":1256,"address":[],"length":0,"stats":{"Line":4}},{"line":1260,"address":[],"length":0,"stats":{"Line":2}},{"line":1263,"address":[],"length":0,"stats":{"Line":2}},{"line":1266,"address":[],"length":0,"stats":{"Line":4}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1270,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":4}},{"line":1281,"address":[],"length":0,"stats":{"Line":2}},{"line":1284,"address":[],"length":0,"stats":{"Line":2}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":2}},{"line":1291,"address":[],"length":0,"stats":{"Line":2}},{"line":1294,"address":[],"length":0,"stats":{"Line":2}},{"line":1295,"address":[],"length":0,"stats":{"Line":34}},{"line":1300,"address":[],"length":0,"stats":{"Line":2}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1304,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":2}},{"line":1313,"address":[],"length":0,"stats":{"Line":2}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":2}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":1}},{"line":1337,"address":[],"length":0,"stats":{"Line":1}},{"line":1338,"address":[],"length":0,"stats":{"Line":1}},{"line":1339,"address":[],"length":0,"stats":{"Line":1}},{"line":1340,"address":[],"length":0,"stats":{"Line":1}},{"line":1341,"address":[],"length":0,"stats":{"Line":1}},{"line":1342,"address":[],"length":0,"stats":{"Line":1}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":2}},{"line":1367,"address":[],"length":0,"stats":{"Line":2}},{"line":1370,"address":[],"length":0,"stats":{"Line":2}},{"line":1373,"address":[],"length":0,"stats":{"Line":3}},{"line":1378,"address":[],"length":0,"stats":{"Line":2}},{"line":1381,"address":[],"length":0,"stats":{"Line":2}},{"line":1382,"address":[],"length":0,"stats":{"Line":2}},{"line":1386,"address":[],"length":0,"stats":{"Line":4}},{"line":1388,"address":[],"length":0,"stats":{"Line":4}},{"line":1389,"address":[],"length":0,"stats":{"Line":4}},{"line":1390,"address":[],"length":0,"stats":{"Line":4}},{"line":1394,"address":[],"length":0,"stats":{"Line":7}},{"line":1395,"address":[],"length":0,"stats":{"Line":7}},{"line":1396,"address":[],"length":0,"stats":{"Line":7}},{"line":1397,"address":[],"length":0,"stats":{"Line":7}},{"line":1399,"address":[],"length":0,"stats":{"Line":26}},{"line":1404,"address":[],"length":0,"stats":{"Line":7}},{"line":1405,"address":[],"length":0,"stats":{"Line":7}},{"line":1406,"address":[],"length":0,"stats":{"Line":7}},{"line":1407,"address":[],"length":0,"stats":{"Line":7}},{"line":1409,"address":[],"length":0,"stats":{"Line":22}},{"line":1414,"address":[],"length":0,"stats":{"Line":3}},{"line":1415,"address":[],"length":0,"stats":{"Line":3}},{"line":1416,"address":[],"length":0,"stats":{"Line":3}},{"line":1417,"address":[],"length":0,"stats":{"Line":3}},{"line":1419,"address":[],"length":0,"stats":{"Line":9}},{"line":1423,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1457,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1513,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1556,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1559,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1581,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1623,"address":[],"length":0,"stats":{"Line":0}},{"line":1624,"address":[],"length":0,"stats":{"Line":0}},{"line":1625,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1659,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1678,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1695,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1723,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1766,"address":[],"length":0,"stats":{"Line":0}},{"line":1797,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1806,"address":[],"length":0,"stats":{"Line":0}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1822,"address":[],"length":0,"stats":{"Line":0}},{"line":1832,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1835,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1839,"address":[],"length":0,"stats":{"Line":0}},{"line":1840,"address":[],"length":0,"stats":{"Line":0}},{"line":1845,"address":[],"length":0,"stats":{"Line":0}},{"line":1846,"address":[],"length":0,"stats":{"Line":0}},{"line":1847,"address":[],"length":0,"stats":{"Line":0}},{"line":1848,"address":[],"length":0,"stats":{"Line":0}},{"line":1849,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1855,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1858,"address":[],"length":0,"stats":{"Line":0}},{"line":1859,"address":[],"length":0,"stats":{"Line":0}},{"line":1860,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1862,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1872,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[],"length":0,"stats":{"Line":0}},{"line":1874,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1880,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1890,"address":[],"length":0,"stats":{"Line":0}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":0}},{"line":1894,"address":[],"length":0,"stats":{"Line":0}},{"line":1895,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":0}},{"line":1941,"address":[],"length":0,"stats":{"Line":0}},{"line":1953,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1955,"address":[],"length":0,"stats":{"Line":0}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1969,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[],"length":0,"stats":{"Line":0}},{"line":1971,"address":[],"length":0,"stats":{"Line":0}},{"line":1972,"address":[],"length":0,"stats":{"Line":0}},{"line":1977,"address":[],"length":0,"stats":{"Line":0}},{"line":1978,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1986,"address":[],"length":0,"stats":{"Line":0}},{"line":1996,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2007,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2022,"address":[],"length":0,"stats":{"Line":0}},{"line":2023,"address":[],"length":0,"stats":{"Line":0}},{"line":2024,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2031,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2038,"address":[],"length":0,"stats":{"Line":0}},{"line":2040,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2044,"address":[],"length":0,"stats":{"Line":0}},{"line":2045,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[],"length":0,"stats":{"Line":0}},{"line":2077,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2097,"address":[],"length":0,"stats":{"Line":0}},{"line":2098,"address":[],"length":0,"stats":{"Line":0}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2100,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[],"length":0,"stats":{"Line":0}},{"line":2102,"address":[],"length":0,"stats":{"Line":0}},{"line":2103,"address":[],"length":0,"stats":{"Line":0}},{"line":2104,"address":[],"length":0,"stats":{"Line":0}},{"line":2110,"address":[],"length":0,"stats":{"Line":0}},{"line":2116,"address":[],"length":0,"stats":{"Line":0}},{"line":2117,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2130,"address":[],"length":0,"stats":{"Line":0}},{"line":2131,"address":[],"length":0,"stats":{"Line":0}},{"line":2132,"address":[],"length":0,"stats":{"Line":0}},{"line":2133,"address":[],"length":0,"stats":{"Line":0}},{"line":2136,"address":[],"length":0,"stats":{"Line":0}},{"line":2142,"address":[],"length":0,"stats":{"Line":0}},{"line":2143,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2148,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[],"length":0,"stats":{"Line":0}},{"line":2154,"address":[],"length":0,"stats":{"Line":0}},{"line":2155,"address":[],"length":0,"stats":{"Line":0}},{"line":2158,"address":[],"length":0,"stats":{"Line":0}},{"line":2159,"address":[],"length":0,"stats":{"Line":0}},{"line":2160,"address":[],"length":0,"stats":{"Line":0}},{"line":2161,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2169,"address":[],"length":0,"stats":{"Line":0}},{"line":2170,"address":[],"length":0,"stats":{"Line":0}},{"line":2172,"address":[],"length":0,"stats":{"Line":0}},{"line":2175,"address":[],"length":0,"stats":{"Line":0}},{"line":2176,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[],"length":0,"stats":{"Line":0}},{"line":2181,"address":[],"length":0,"stats":{"Line":0}},{"line":2185,"address":[],"length":0,"stats":{"Line":0}},{"line":2190,"address":[],"length":0,"stats":{"Line":0}},{"line":2191,"address":[],"length":0,"stats":{"Line":0}},{"line":2192,"address":[],"length":0,"stats":{"Line":0}},{"line":2194,"address":[],"length":0,"stats":{"Line":0}},{"line":2197,"address":[],"length":0,"stats":{"Line":0}},{"line":2198,"address":[],"length":0,"stats":{"Line":0}},{"line":2200,"address":[],"length":0,"stats":{"Line":0}},{"line":2201,"address":[],"length":0,"stats":{"Line":0}},{"line":2202,"address":[],"length":0,"stats":{"Line":0}},{"line":2203,"address":[],"length":0,"stats":{"Line":0}},{"line":2204,"address":[],"length":0,"stats":{"Line":0}},{"line":2205,"address":[],"length":0,"stats":{"Line":0}},{"line":2209,"address":[],"length":0,"stats":{"Line":0}},{"line":2210,"address":[],"length":0,"stats":{"Line":0}},{"line":2211,"address":[],"length":0,"stats":{"Line":0}},{"line":2214,"address":[],"length":0,"stats":{"Line":0}},{"line":2215,"address":[],"length":0,"stats":{"Line":0}},{"line":2216,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2219,"address":[],"length":0,"stats":{"Line":0}},{"line":2221,"address":[],"length":0,"stats":{"Line":0}},{"line":2222,"address":[],"length":0,"stats":{"Line":0}},{"line":2223,"address":[],"length":0,"stats":{"Line":0}},{"line":2225,"address":[],"length":0,"stats":{"Line":0}},{"line":2230,"address":[],"length":0,"stats":{"Line":0}},{"line":2231,"address":[],"length":0,"stats":{"Line":0}},{"line":2232,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2235,"address":[],"length":0,"stats":{"Line":0}},{"line":2236,"address":[],"length":0,"stats":{"Line":0}},{"line":2237,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2239,"address":[],"length":0,"stats":{"Line":0}},{"line":2245,"address":[],"length":0,"stats":{"Line":0}},{"line":2246,"address":[],"length":0,"stats":{"Line":0}},{"line":2247,"address":[],"length":0,"stats":{"Line":0}},{"line":2248,"address":[],"length":0,"stats":{"Line":0}},{"line":2249,"address":[],"length":0,"stats":{"Line":0}},{"line":2253,"address":[],"length":0,"stats":{"Line":0}},{"line":2254,"address":[],"length":0,"stats":{"Line":0}},{"line":2255,"address":[],"length":0,"stats":{"Line":0}},{"line":2257,"address":[],"length":0,"stats":{"Line":0}},{"line":2258,"address":[],"length":0,"stats":{"Line":0}},{"line":2259,"address":[],"length":0,"stats":{"Line":0}},{"line":2260,"address":[],"length":0,"stats":{"Line":0}},{"line":2263,"address":[],"length":0,"stats":{"Line":0}},{"line":2298,"address":[],"length":0,"stats":{"Line":37}},{"line":2300,"address":[],"length":0,"stats":{"Line":37}},{"line":2304,"address":[],"length":0,"stats":{"Line":37}}],"covered":208,"coverable":958},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","frame_extraction.rs"],"content":"//! Frame Extraction - Модуль извлечения кадров для различных целей\n//!\n//! Этот модуль обеспечивает извлечение кадров из видео для:\n//! - Превью на timeline\n//! - Распознавания объектов и сцен\n//! - Анализа субтитров\n//! - Кэширования для быстрого доступа\n\nuse crate::video_compiler::cache::RenderCache;\nuse crate::video_compiler::error::Result;\nuse crate::video_compiler::preview::{PreviewGenerator, VideoInfo};\nuse crate::video_compiler::schema::{Clip, PreviewFormat, Subtitle};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// Тип извлечения кадра\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum ExtractionPurpose {\n  /// Для превью на timeline\n  TimelinePreview,\n  /// Для распознавания объектов (YOLO)\n  ObjectDetection,\n  /// Для распознавания сцен\n  SceneRecognition,\n  /// Для распознавания текста (OCR)\n  TextRecognition,\n  /// Для анализа субтитров\n  SubtitleAnalysis,\n  /// Ключевой кадр (I-frame)\n  KeyFrame,\n  /// Пользовательский скриншот\n  UserScreenshot,\n}\n\n/// Стратегия извлечения кадров\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ExtractionStrategy {\n  /// Равномерное извлечение через интервалы\n  Interval {\n    /// Интервал в секундах\n    seconds: f64,\n  },\n  /// Извлечение по изменению сцены\n  SceneChange {\n    /// Чувствительность (0.0-1.0)\n    threshold: f32,\n  },\n  /// Извлечение по временным меткам субтитров\n  SubtitleSync {\n    /// Смещение от начала субтитра\n    offset_seconds: f64,\n  },\n  /// Извлечение ключевых кадров (I-frames)\n  KeyFrames,\n  /// Комбинированная стратегия\n  Combined {\n    /// Минимальный интервал между кадрами\n    min_interval: f64,\n    /// Включить изменения сцен\n    include_scene_changes: bool,\n    /// Включить ключевые кадры\n    include_keyframes: bool,\n  },\n}\n\n/// Настройки извлечения кадров\n#[derive(Debug, Clone)]\npub struct ExtractionSettings {\n  /// Стратегия извлечения\n  pub strategy: ExtractionStrategy,\n  /// Цель извлечения\n  pub purpose: ExtractionPurpose,\n  /// Разрешение кадров\n  pub resolution: (u32, u32),\n  /// Качество (0-100)\n  pub quality: u8,\n  /// Формат изображения\n  pub format: PreviewFormat,\n  /// Максимальное количество кадров\n  pub max_frames: Option\u003cusize\u003e,\n  /// Использовать GPU для декодирования\n  pub gpu_decode: bool,\n  /// Параллельная обработка\n  pub parallel_extraction: bool,\n  /// Количество потоков\n  pub thread_count: Option\u003cusize\u003e,\n}\n\nimpl Default for ExtractionSettings {\n  fn default() -\u003e Self {\n    Self {\n      strategy: ExtractionStrategy::Interval { seconds: 1.0 },\n      purpose: ExtractionPurpose::TimelinePreview,\n      resolution: (640, 360),\n      quality: 75,\n      format: PreviewFormat::Jpeg,\n      max_frames: None,\n      gpu_decode: false,\n      parallel_extraction: true,\n      thread_count: None,\n    }\n  }\n}\n\n/// Менеджер извлечения кадров\npub struct FrameExtractionManager {\n  /// Генератор превью\n  pub preview_generator: Arc\u003cPreviewGenerator\u003e,\n  /// Кэш\n  cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n  /// Настройки по умолчанию для разных целей\n  purpose_settings: HashMap\u003cExtractionPurpose, ExtractionSettings\u003e,\n  /// Путь к FFmpeg\n  ffmpeg_path: String,\n}\n\nimpl FrameExtractionManager {\n  /// Создать новый менеджер\n  pub fn new(cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e) -\u003e Self {\n    let preview_generator = Arc::new(PreviewGenerator::new(cache.clone()));\n    let mut purpose_settings = HashMap::new();\n\n    // Настройки для timeline превью\n    purpose_settings.insert(\n      ExtractionPurpose::TimelinePreview,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::Combined {\n          min_interval: 0.5,\n          include_scene_changes: true,\n          include_keyframes: true,\n        },\n        purpose: ExtractionPurpose::TimelinePreview,\n        resolution: (160, 90),\n        quality: 60,\n        format: PreviewFormat::Jpeg,\n        max_frames: Some(200),\n        gpu_decode: true,\n        parallel_extraction: true,\n        thread_count: None,\n      },\n    );\n\n    // Настройки для распознавания объектов\n    purpose_settings.insert(\n      ExtractionPurpose::ObjectDetection,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::Interval { seconds: 1.0 },\n        purpose: ExtractionPurpose::ObjectDetection,\n        resolution: (1280, 720), // Выше разрешение для лучшего распознавания\n        quality: 85,\n        format: PreviewFormat::Png, // PNG для лучшего качества\n        max_frames: None,\n        gpu_decode: true,\n        parallel_extraction: true,\n        thread_count: None,\n      },\n    );\n\n    // Настройки для распознавания сцен\n    purpose_settings.insert(\n      ExtractionPurpose::SceneRecognition,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::SceneChange { threshold: 0.3 },\n        purpose: ExtractionPurpose::SceneRecognition,\n        resolution: (960, 540),\n        quality: 80,\n        format: PreviewFormat::Jpeg,\n        max_frames: Some(500),\n        gpu_decode: true,\n        parallel_extraction: true,\n        thread_count: None,\n      },\n    );\n\n    // Настройки для анализа субтитров\n    purpose_settings.insert(\n      ExtractionPurpose::SubtitleAnalysis,\n      ExtractionSettings {\n        strategy: ExtractionStrategy::SubtitleSync {\n          offset_seconds: 0.5,\n        },\n        purpose: ExtractionPurpose::SubtitleAnalysis,\n        resolution: (1920, 1080), // Полное разрешение для OCR\n        quality: 90,\n        format: PreviewFormat::Png,\n        max_frames: None,\n        gpu_decode: true,\n        parallel_extraction: false, // Последовательно для синхронизации\n        thread_count: Some(1),\n      },\n    );\n\n    Self {\n      preview_generator,\n      cache,\n      purpose_settings,\n      ffmpeg_path: \"ffmpeg\".to_string(),\n    }\n  }\n\n  /// Извлечь кадры для клипа\n  pub async fn extract_frames_for_clip(\n    \u0026self,\n    clip: \u0026Clip,\n    settings: Option\u003cExtractionSettings\u003e,\n  ) -\u003e Result\u003cVec\u003cExtractedFrame\u003e\u003e {\n    let settings =\n      settings.unwrap_or_else(|| self.get_default_settings(ExtractionPurpose::TimelinePreview));\n\n    let video_path = \u0026clip.source_path;\n    let video_info = self.preview_generator.get_video_info(video_path).await?;\n\n    // Вычисляем временные метки для извлечения\n    let timestamps = self.calculate_timestamps(\n      \u0026settings.strategy,\n      clip.source_start,\n      clip.source_end,\n      \u0026video_info,\n      None,\n    )?;\n\n    // Извлекаем кадры\n    self\n      .extract_frames_batch(video_path, timestamps, \u0026settings)\n      .await\n  }\n\n  /// Извлечь кадры для субтитров\n  pub async fn extract_frames_for_subtitles(\n    \u0026self,\n    video_path: \u0026Path,\n    subtitles: \u0026[Subtitle],\n    settings: Option\u003cExtractionSettings\u003e,\n  ) -\u003e Result\u003cVec\u003cSubtitleFrame\u003e\u003e {\n    let settings =\n      settings.unwrap_or_else(|| self.get_default_settings(ExtractionPurpose::SubtitleAnalysis));\n\n    let mut frames = Vec::new();\n\n    for subtitle in subtitles {\n      if !subtitle.enabled {\n        continue;\n      }\n\n      // Вычисляем время кадра для субтитра\n      let timestamp = match \u0026settings.strategy {\n        ExtractionStrategy::SubtitleSync { offset_seconds } =\u003e subtitle.start_time + offset_seconds,\n        _ =\u003e subtitle.start_time + 0.5, // По умолчанию 0.5 сек от начала\n      };\n\n      // Извлекаем кадр\n      let frame_data = self\n        .preview_generator\n        .generate_preview(\n          video_path,\n          timestamp,\n          Some(settings.resolution),\n          Some(settings.quality),\n        )\n        .await?;\n\n      frames.push(SubtitleFrame {\n        subtitle_id: subtitle.id.clone(),\n        subtitle_text: subtitle.text.clone(),\n        timestamp,\n        frame_data,\n        start_time: subtitle.start_time,\n        end_time: subtitle.end_time,\n      });\n    }\n\n    Ok(frames)\n  }\n\n  /// Извлечь кадры для распознавания\n  pub async fn extract_frames_for_recognition(\n    \u0026self,\n    video_path: \u0026Path,\n    duration: f64,\n    purpose: ExtractionPurpose,\n  ) -\u003e Result\u003cVec\u003cRecognitionFrame\u003e\u003e {\n    let settings = self.get_default_settings(purpose);\n    let video_info = self.preview_generator.get_video_info(video_path).await?;\n\n    // Вычисляем временные метки\n    let timestamps = self.calculate_timestamps(\n      \u0026settings.strategy,\n      0.0,\n      duration,\n      \u0026video_info,\n      settings.max_frames,\n    )?;\n\n    // Извлекаем кадры\n    let extracted_frames = self\n      .extract_frames_batch(video_path, timestamps, \u0026settings)\n      .await?;\n\n    // Преобразуем в формат для распознавания\n    Ok(\n      extracted_frames\n        .into_iter()\n        .map(|frame| RecognitionFrame {\n          timestamp: frame.timestamp,\n          frame_data: frame.data,\n          resolution: frame.resolution,\n          scene_change_score: frame.scene_change_score,\n          is_keyframe: frame.is_keyframe,\n        })\n        .collect(),\n    )\n  }\n\n  /// Получить существующие скриншоты\n  pub async fn get_existing_screenshots(\u0026self, _video_path: \u0026Path) -\u003e Result\u003cVec\u003cExtractedFrame\u003e\u003e {\n    let _cache = self.cache.read().await;\n\n    // Здесь нужно реализовать получение скриншотов из кэша\n    // Пока возвращаем пустой вектор\n    Ok(Vec::new())\n  }\n\n  /// Получить настройки по умолчанию для цели\n  fn get_default_settings(\u0026self, purpose: ExtractionPurpose) -\u003e ExtractionSettings {\n    self\n      .purpose_settings\n      .get(\u0026purpose)\n      .cloned()\n      .unwrap_or_default()\n  }\n\n  /// Вычислить временные метки для извлечения\n  fn calculate_timestamps(\n    \u0026self,\n    strategy: \u0026ExtractionStrategy,\n    start_time: f64,\n    end_time: f64,\n    _video_info: \u0026VideoInfo,\n    max_frames: Option\u003cusize\u003e,\n  ) -\u003e Result\u003cVec\u003cf64\u003e\u003e {\n    let _duration = end_time - start_time;\n\n    let timestamps = match strategy {\n      ExtractionStrategy::Interval { seconds } =\u003e {\n        let mut timestamps = Vec::new();\n        let mut current = start_time;\n\n        while current \u003c= end_time {\n          timestamps.push(current);\n          current += seconds;\n        }\n\n        timestamps\n      }\n\n      ExtractionStrategy::SceneChange { threshold: _ } =\u003e {\n        // Здесь нужно использовать FFmpeg scene detection\n        // Пока используем простые интервалы\n        vec![] // TODO: Implement scene detection\n      }\n\n      ExtractionStrategy::KeyFrames =\u003e {\n        // Извлечение I-frames через FFmpeg\n        vec![] // TODO: Implement keyframe extraction\n      }\n\n      ExtractionStrategy::Combined {\n        min_interval,\n        include_scene_changes,\n        include_keyframes,\n      } =\u003e {\n        let mut timestamps = Vec::new();\n\n        // Добавляем равномерные интервалы\n        let mut current = start_time;\n        while current \u003c= end_time {\n          timestamps.push(current);\n          current += min_interval;\n        }\n\n        // Добавляем изменения сцен\n        if *include_scene_changes {\n          // TODO: Implement scene detection\n          // let scene_changes = self.detect_scene_changes(start_time, end_time, 0.3)?;\n          // timestamps.extend(scene_changes);\n        }\n\n        // Добавляем ключевые кадры\n        if *include_keyframes {\n          // TODO: Implement keyframe extraction\n          // let keyframes = self.extract_keyframe_timestamps(start_time, end_time)?;\n          // timestamps.extend(keyframes);\n        }\n\n        // Удаляем дубликаты и сортируем\n        timestamps.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        timestamps.dedup();\n\n        // Фильтруем по минимальному интервалу\n        let mut filtered = vec![timestamps[0]];\n        for \u0026ts in \u0026timestamps[1..] {\n          if ts - filtered.last().unwrap() \u003e= *min_interval {\n            filtered.push(ts);\n          }\n        }\n\n        filtered\n      }\n\n      ExtractionStrategy::SubtitleSync { .. } =\u003e {\n        // Обрабатывается отдельно в extract_frames_for_subtitles\n        vec![]\n      }\n    };\n\n    // Ограничиваем количество кадров если необходимо\n    Ok(if let Some(max) = max_frames {\n      timestamps.into_iter().take(max).collect()\n    } else {\n      timestamps\n    })\n  }\n\n  /// Обнаружить изменения сцен\n  async fn detect_scene_changes(\n    \u0026self,\n    _start_time: f64,\n    _end_time: f64,\n    _threshold: f32,\n  ) -\u003e Result\u003cVec\u003cf64\u003e\u003e {\n    // TODO: Реализовать через FFmpeg scene detection filter\n    // ffmpeg -i input.mp4 -filter:v \"select='gt(scene,0.3)',showinfo\" -f null -\n\n    // Пока возвращаем пустой вектор\n    Ok(vec![])\n  }\n\n  /// Извлечь временные метки ключевых кадров\n  async fn extract_keyframe_timestamps(\n    \u0026self,\n    _start_time: f64,\n    _end_time: f64,\n  ) -\u003e Result\u003cVec\u003cf64\u003e\u003e {\n    // TODO: Реализовать через FFmpeg\n    // ffmpeg -i input.mp4 -vf select='eq(pict_type\\,I)' -vsync vfr -f image2 keyframes-%04d.jpg\n\n    // Пока возвращаем пустой вектор\n    Ok(vec![])\n  }\n\n  /// Извлечь пакет кадров\n  async fn extract_frames_batch(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamps: Vec\u003cf64\u003e,\n    settings: \u0026ExtractionSettings,\n  ) -\u003e Result\u003cVec\u003cExtractedFrame\u003e\u003e {\n    let mut frames = Vec::new();\n\n    if settings.parallel_extraction {\n      // Параллельное извлечение\n      let results = self\n        .preview_generator\n        .generate_preview_batch_for_file(\n          video_path,\n          timestamps.clone(),\n          Some(settings.resolution),\n          Some(settings.quality),\n        )\n        .await?;\n\n      for (i, result) in results.into_iter().enumerate() {\n        match result.result {\n          Ok(data) =\u003e {\n            frames.push(ExtractedFrame {\n              timestamp: timestamps[i],\n              data,\n              resolution: settings.resolution,\n              purpose: settings.purpose.clone(),\n              scene_change_score: None,\n              is_keyframe: false,\n            });\n          }\n          Err(e) =\u003e {\n            log::warn!(\"Не удалось извлечь кадр на {:.2}s: {}\", timestamps[i], e);\n          }\n        }\n      }\n    } else {\n      // Последовательное извлечение\n      for timestamp in timestamps {\n        match self\n          .preview_generator\n          .generate_preview(\n            video_path,\n            timestamp,\n            Some(settings.resolution),\n            Some(settings.quality),\n          )\n          .await\n        {\n          Ok(data) =\u003e {\n            frames.push(ExtractedFrame {\n              timestamp,\n              data,\n              resolution: settings.resolution,\n              purpose: settings.purpose.clone(),\n              scene_change_score: None,\n              is_keyframe: false,\n            });\n          }\n          Err(e) =\u003e {\n            log::warn!(\"Не удалось извлечь кадр на {:.2}s: {}\", timestamp, e);\n          }\n        }\n      }\n    }\n\n    Ok(frames)\n  }\n}\n\n/// Извлеченный кадр\n#[derive(Debug, Clone)]\npub struct ExtractedFrame {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные изображения\n  pub data: Vec\u003cu8\u003e,\n  /// Разрешение\n  pub resolution: (u32, u32),\n  /// Цель извлечения\n  pub purpose: ExtractionPurpose,\n  /// Оценка изменения сцены (если доступно)\n  pub scene_change_score: Option\u003cf32\u003e,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Кадр для субтитра\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SubtitleFrame {\n  /// ID субтитра\n  pub subtitle_id: String,\n  /// Текст субтитра\n  pub subtitle_text: String,\n  /// Временная метка кадра\n  pub timestamp: f64,\n  /// Данные кадра\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Время начала субтитра\n  pub start_time: f64,\n  /// Время окончания субтитра\n  pub end_time: f64,\n}\n\n/// Кадр для распознавания\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RecognitionFrame {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные кадра\n  pub frame_data: Vec\u003cu8\u003e,\n  /// Разрешение\n  pub resolution: (u32, u32),\n  /// Оценка изменения сцены\n  pub scene_change_score: Option\u003cf32\u003e,\n  /// Является ли ключевым кадром\n  pub is_keyframe: bool,\n}\n\n/// Метаданные извлечения кадров\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExtractionMetadata {\n  /// Путь к видео\n  pub video_path: String,\n  /// Общее количество извлеченных кадров\n  pub total_frames: usize,\n  /// Использованная стратегия\n  pub strategy: ExtractionStrategy,\n  /// Цель извлечения\n  pub purpose: ExtractionPurpose,\n  /// Время извлечения (мс)\n  pub extraction_time_ms: u64,\n  /// Использовалось ли GPU ускорение\n  pub gpu_used: bool,\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::cache::{PreviewKey, PreviewData, MediaMetadata};\n  use crate::video_compiler::preview::VideoInfo;\n  use std::collections::HashMap;\n  use std::time::{Duration, SystemTime};\n  use tempfile::NamedTempFile;\n\n  #[test]\n  fn test_extraction_settings_default() {\n    let settings = ExtractionSettings::default();\n    assert_eq!(settings.resolution, (640, 360));\n    assert_eq!(settings.quality, 75);\n    assert!(settings.parallel_extraction);\n    assert!(!settings.gpu_decode);\n    assert_eq!(settings.max_frames, None);\n    assert_eq!(settings.thread_count, None);\n    assert!(matches!(settings.strategy, ExtractionStrategy::Interval { seconds } if seconds == 1.0));\n    assert_eq!(settings.purpose, ExtractionPurpose::TimelinePreview);\n    assert!(matches!(settings.format, PreviewFormat::Jpeg));\n  }\n\n  #[test]\n  fn test_extraction_purpose_equality() {\n    assert_eq!(\n      ExtractionPurpose::TimelinePreview,\n      ExtractionPurpose::TimelinePreview\n    );\n    assert_ne!(\n      ExtractionPurpose::TimelinePreview,\n      ExtractionPurpose::ObjectDetection\n    );\n  }\n\n  #[test]\n  fn test_extraction_purpose_serialization() {\n    let purpose = ExtractionPurpose::ObjectDetection;\n    let json = serde_json::to_string(\u0026purpose).unwrap();\n    assert!(json.contains(\"ObjectDetection\"));\n    \n    let deserialized: ExtractionPurpose = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized, purpose);\n  }\n\n  #[test]\n  fn test_extraction_strategy_serialization() {\n    let strategies = vec![\n      ExtractionStrategy::Interval { seconds: 2.5 },\n      ExtractionStrategy::SceneChange { threshold: 0.4 },\n      ExtractionStrategy::SubtitleSync { offset_seconds: 0.3 },\n      ExtractionStrategy::KeyFrames,\n      ExtractionStrategy::Combined {\n        min_interval: 1.0,\n        include_scene_changes: true,\n        include_keyframes: false,\n      },\n    ];\n\n    for strategy in strategies {\n      let json = serde_json::to_string(\u0026strategy).unwrap();\n      let deserialized: ExtractionStrategy = serde_json::from_str(\u0026json).unwrap();\n      \n      match (\u0026strategy, \u0026deserialized) {\n        (ExtractionStrategy::Interval { seconds: s1 }, ExtractionStrategy::Interval { seconds: s2 }) =\u003e {\n          assert_eq!(s1, s2);\n        }\n        (ExtractionStrategy::SceneChange { threshold: t1 }, ExtractionStrategy::SceneChange { threshold: t2 }) =\u003e {\n          assert_eq!(t1, t2);\n        }\n        _ =\u003e {}\n      }\n    }\n  }\n\n  #[tokio::test]\n  async fn test_frame_extraction_manager_new() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    assert_eq!(manager.ffmpeg_path, \"ffmpeg\");\n    assert!(!manager.purpose_settings.is_empty());\n    \n    // Check default settings for different purposes\n    let timeline_settings = manager.get_default_settings(ExtractionPurpose::TimelinePreview);\n    assert_eq!(timeline_settings.resolution, (160, 90));\n    assert_eq!(timeline_settings.quality, 60);\n    \n    let object_detection_settings = manager.get_default_settings(ExtractionPurpose::ObjectDetection);\n    assert_eq!(object_detection_settings.resolution, (1280, 720));\n    assert_eq!(object_detection_settings.quality, 85);\n  }\n\n  #[test]\n  fn test_preview_key_new() {\n    let key = PreviewKey::new(\n      \"/test/video.mp4\".to_string(),\n      10.5,\n      (1920, 1080),\n      85\n    );\n    \n    assert_eq!(key.file_path, \"/test/video.mp4\");\n    assert_eq!(key.timestamp, 10500); // 10.5 * 1000\n    assert_eq!(key.resolution, (1920, 1080));\n    assert_eq!(key.quality, 85);\n  }\n\n  #[test]\n  fn test_preview_data_is_expired() {\n    let data = PreviewData {\n      image_data: vec![1, 2, 3],\n      timestamp: SystemTime::now() - Duration::from_secs(3600),\n      access_count: 5,\n    };\n    \n    assert!(data.is_expired(Duration::from_secs(1800))); // Should be expired\n    assert!(!data.is_expired(Duration::from_secs(7200))); // Should not be expired\n  }\n\n  #[test]\n  fn test_media_metadata_serialization() {\n    let metadata = MediaMetadata {\n      file_path: \"/test/video.mp4\".to_string(),\n      file_size: 1024000,\n      modified_time: SystemTime::now(),\n      duration: 120.5,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n      cached_at: SystemTime::now(),\n    };\n    \n    let json = serde_json::to_string(\u0026metadata).unwrap();\n    assert!(json.contains(\"1024000\"));\n    assert!(json.contains(\"120.5\"));\n    \n    let deserialized: MediaMetadata = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.file_path, metadata.file_path);\n    assert_eq!(deserialized.duration, metadata.duration);\n  }\n\n  #[test]\n  fn test_subtitle_frame_serialization() {\n    let frame = SubtitleFrame {\n      subtitle_id: \"sub-001\".to_string(),\n      subtitle_text: \"Hello World\".to_string(),\n      timestamp: 15.5,\n      frame_data: vec![10, 20, 30],\n      start_time: 15.0,\n      end_time: 17.0,\n    };\n    \n    let json = serde_json::to_string(\u0026frame).unwrap();\n    assert!(json.contains(\"sub-001\"));\n    assert!(json.contains(\"Hello World\"));\n    assert!(json.contains(\"15.5\"));\n    \n    let deserialized: SubtitleFrame = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.subtitle_id, frame.subtitle_id);\n    assert_eq!(deserialized.timestamp, frame.timestamp);\n  }\n\n  #[test]\n  fn test_recognition_frame_serialization() {\n    let frame = RecognitionFrame {\n      timestamp: 20.0,\n      frame_data: vec![5, 10, 15],\n      resolution: (1280, 720),\n      scene_change_score: Some(0.75),\n      is_keyframe: true,\n    };\n    \n    let json = serde_json::to_string(\u0026frame).unwrap();\n    assert!(json.contains(\"20.0\"));\n    assert!(json.contains(\"1280\"));\n    assert!(json.contains(\"0.75\"));\n    assert!(json.contains(\"true\"));\n    \n    let deserialized: RecognitionFrame = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.timestamp, frame.timestamp);\n    assert_eq!(deserialized.scene_change_score, frame.scene_change_score);\n  }\n\n  #[test]\n  fn test_extraction_metadata_serialization() {\n    let metadata = ExtractionMetadata {\n      video_path: \"/test/video.mp4\".to_string(),\n      total_frames: 100,\n      strategy: ExtractionStrategy::Interval { seconds: 1.0 },\n      purpose: ExtractionPurpose::TimelinePreview,\n      extraction_time_ms: 5000,\n      gpu_used: true,\n    };\n    \n    let json = serde_json::to_string(\u0026metadata).unwrap();\n    assert!(json.contains(\"/test/video.mp4\"));\n    assert!(json.contains(\"100\"));\n    assert!(json.contains(\"5000\"));\n    \n    let deserialized: ExtractionMetadata = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.total_frames, metadata.total_frames);\n    assert_eq!(deserialized.gpu_used, metadata.gpu_used);\n  }\n\n  #[test]\n  fn test_extracted_frame_creation() {\n    let frame = ExtractedFrame {\n      timestamp: 5.0,\n      data: vec![1, 2, 3, 4, 5],\n      resolution: (640, 360),\n      purpose: ExtractionPurpose::TimelinePreview,\n      scene_change_score: Some(0.45),\n      is_keyframe: false,\n    };\n    \n    assert_eq!(frame.timestamp, 5.0);\n    assert_eq!(frame.data.len(), 5);\n    assert_eq!(frame.resolution, (640, 360));\n    assert_eq!(frame.scene_change_score, Some(0.45));\n  }\n\n  #[tokio::test]\n  async fn test_calculate_timestamps_interval_strategy() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    let strategy = ExtractionStrategy::Interval { seconds: 2.0 };\n    let video_info = VideoInfo {\n      duration: 10.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let timestamps = manager.calculate_timestamps(\n      \u0026strategy,\n      0.0,\n      10.0,\n      \u0026video_info,\n      None\n    ).unwrap();\n    \n    assert_eq!(timestamps.len(), 6); // 0, 2, 4, 6, 8, 10\n    assert_eq!(timestamps[0], 0.0);\n    assert_eq!(timestamps[1], 2.0);\n    assert_eq!(timestamps[5], 10.0);\n  }\n\n  #[tokio::test]\n  async fn test_calculate_timestamps_with_max_frames() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    let strategy = ExtractionStrategy::Interval { seconds: 1.0 };\n    let video_info = VideoInfo {\n      duration: 60.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let timestamps = manager.calculate_timestamps(\n      \u0026strategy,\n      0.0,\n      60.0,\n      \u0026video_info,\n      Some(5)\n    ).unwrap();\n    \n    assert_eq!(timestamps.len(), 5); // Limited to 5 frames\n  }\n\n  #[tokio::test]\n  async fn test_calculate_timestamps_combined_strategy() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    let strategy = ExtractionStrategy::Combined {\n      min_interval: 2.0,\n      include_scene_changes: false,\n      include_keyframes: false,\n    };\n    let video_info = VideoInfo {\n      duration: 10.0,\n      resolution: Some((1920, 1080)),\n      fps: Some(30.0),\n      bitrate: Some(8000000),\n      video_codec: Some(\"h264\".to_string()),\n      audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let timestamps = manager.calculate_timestamps(\n      \u0026strategy,\n      0.0,\n      10.0,\n      \u0026video_info,\n      None\n    ).unwrap();\n    \n    assert!(timestamps.len() \u003e 0);\n    assert_eq!(timestamps[0], 0.0);\n    \n    // Check minimum interval between timestamps\n    for i in 1..timestamps.len() {\n      assert!(timestamps[i] - timestamps[i-1] \u003e= 2.0);\n    }\n  }\n\n  #[tokio::test]\n  async fn test_default_purpose_settings() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let manager = FrameExtractionManager::new(cache);\n    \n    // Test Timeline Preview settings\n    let timeline_settings = manager.get_default_settings(ExtractionPurpose::TimelinePreview);\n    assert_eq!(timeline_settings.purpose, ExtractionPurpose::TimelinePreview);\n    assert_eq!(timeline_settings.resolution, (160, 90));\n    assert_eq!(timeline_settings.quality, 60);\n    assert_eq!(timeline_settings.max_frames, Some(200));\n    \n    // Test Object Detection settings\n    let object_settings = manager.get_default_settings(ExtractionPurpose::ObjectDetection);\n    assert_eq!(object_settings.purpose, ExtractionPurpose::ObjectDetection);\n    assert_eq!(object_settings.resolution, (1280, 720));\n    assert_eq!(object_settings.quality, 85);\n    assert!(matches!(object_settings.format, PreviewFormat::Png));\n    \n    // Test Scene Recognition settings  \n    let scene_settings = manager.get_default_settings(ExtractionPurpose::SceneRecognition);\n    assert_eq!(scene_settings.resolution, (960, 540));\n    assert_eq!(scene_settings.quality, 80);\n    assert_eq!(scene_settings.max_frames, Some(500));\n    \n    // Test Subtitle Analysis settings\n    let subtitle_settings = manager.get_default_settings(ExtractionPurpose::SubtitleAnalysis);\n    assert_eq!(subtitle_settings.resolution, (1920, 1080));\n    assert_eq!(subtitle_settings.quality, 90);\n    assert!(!subtitle_settings.parallel_extraction);\n  }\n\n  #[test]\n  fn test_all_extraction_purposes() {\n    let purposes = vec![\n      ExtractionPurpose::TimelinePreview,\n      ExtractionPurpose::ObjectDetection,\n      ExtractionPurpose::SceneRecognition,\n      ExtractionPurpose::TextRecognition,\n      ExtractionPurpose::SubtitleAnalysis,\n      ExtractionPurpose::KeyFrame,\n      ExtractionPurpose::UserScreenshot,\n    ];\n    \n    for purpose in purposes {\n      let json = serde_json::to_string(\u0026purpose).unwrap();\n      let deserialized: ExtractionPurpose = serde_json::from_str(\u0026json).unwrap();\n      assert_eq!(purpose, deserialized);\n    }\n  }\n\n  #[test]\n  fn test_purpose_hash_map() {\n    let mut map = HashMap::new();\n    map.insert(ExtractionPurpose::TimelinePreview, \"preview\");\n    map.insert(ExtractionPurpose::ObjectDetection, \"detection\");\n    \n    assert_eq!(map.get(\u0026ExtractionPurpose::TimelinePreview), Some(\u0026\"preview\"));\n    assert_eq!(map.get(\u0026ExtractionPurpose::ObjectDetection), Some(\u0026\"detection\"));\n  }\n}\n","traces":[{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":5}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":5}},{"line":129,"address":[],"length":0,"stats":{"Line":5}},{"line":130,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":5}},{"line":133,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":137,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":5}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":149,"address":[],"length":0,"stats":{"Line":5}},{"line":150,"address":[],"length":0,"stats":{"Line":5}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":5}},{"line":154,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":5}},{"line":156,"address":[],"length":0,"stats":{"Line":5}},{"line":157,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":5}},{"line":165,"address":[],"length":0,"stats":{"Line":5}},{"line":166,"address":[],"length":0,"stats":{"Line":5}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":5}},{"line":170,"address":[],"length":0,"stats":{"Line":5}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":172,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":5}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":179,"address":[],"length":0,"stats":{"Line":5}},{"line":180,"address":[],"length":0,"stats":{"Line":5}},{"line":181,"address":[],"length":0,"stats":{"Line":5}},{"line":182,"address":[],"length":0,"stats":{"Line":5}},{"line":183,"address":[],"length":0,"stats":{"Line":5}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":5}},{"line":189,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":192,"address":[],"length":0,"stats":{"Line":5}},{"line":200,"address":[],"length":0,"stats":{"Line":5}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":328,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":6}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":344,"address":[],"length":0,"stats":{"Line":3}},{"line":346,"address":[],"length":0,"stats":{"Line":6}},{"line":347,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":136}},{"line":352,"address":[],"length":0,"stats":{"Line":67}},{"line":353,"address":[],"length":0,"stats":{"Line":67}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":373,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":13}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":385,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":7}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":6}},{"line":405,"address":[],"length":0,"stats":{"Line":5}},{"line":406,"address":[],"length":0,"stats":{"Line":5}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":423,"address":[],"length":0,"stats":{"Line":2}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}}],"covered":92,"coverable":203},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","gpu.rs"],"content":"/*!\n * GPU ускорение для Video Compiler\n *\n * Этот модуль отвечает за:\n * - Автоматическое определение доступных GPU кодировщиков\n * - Выбор оптимального кодировщика для каждой платформы\n * - Мониторинг использования GPU во время рендеринга\n * - Fallback на CPU кодирование при недоступности GPU\n */\n\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse serde::{Deserialize, Serialize};\n\n/// Типы GPU кодировщиков\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum GpuEncoder {\n  /// Нет GPU ускорения (CPU only)\n  None,\n  /// NVIDIA NVENC\n  Nvenc,\n  /// Intel QuickSync Video\n  QuickSync,\n  /// Video Acceleration API (Linux)\n  Vaapi,\n  /// Apple VideoToolbox (macOS)\n  VideoToolbox,\n  /// AMD Advanced Media Framework\n  AMF,\n}\n\nimpl GpuEncoder {\n  /// Получить название FFmpeg кодека для H.264\n  pub fn h264_codec_name(\u0026self) -\u003e \u0026'static str {\n    match self {\n      GpuEncoder::None =\u003e \"libx264\",\n      GpuEncoder::Nvenc =\u003e \"h264_nvenc\",\n      GpuEncoder::QuickSync =\u003e \"h264_qsv\",\n      GpuEncoder::Vaapi =\u003e \"h264_vaapi\",\n      GpuEncoder::VideoToolbox =\u003e \"h264_videotoolbox\",\n      GpuEncoder::AMF =\u003e \"h264_amf\",\n    }\n  }\n\n  /// Получить название FFmpeg кодека для H.265/HEVC\n  pub fn hevc_codec_name(\u0026self) -\u003e \u0026'static str {\n    match self {\n      GpuEncoder::None =\u003e \"libx265\",\n      GpuEncoder::Nvenc =\u003e \"hevc_nvenc\",\n      GpuEncoder::QuickSync =\u003e \"hevc_qsv\",\n      GpuEncoder::Vaapi =\u003e \"hevc_vaapi\",\n      GpuEncoder::VideoToolbox =\u003e \"hevc_videotoolbox\",\n      GpuEncoder::AMF =\u003e \"hevc_amf\",\n    }\n  }\n\n  /// Проверить, является ли кодировщик аппаратным\n  pub fn is_hardware(\u0026self) -\u003e bool {\n    !matches!(self, GpuEncoder::None)\n  }\n}\n\n/// Информация о GPU\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GpuInfo {\n  pub name: String,\n  pub driver_version: Option\u003cString\u003e,\n  pub memory_total: Option\u003cu64\u003e,\n  pub memory_used: Option\u003cu64\u003e,\n  pub utilization: Option\u003cf32\u003e,\n  pub encoder_type: GpuEncoder,\n  pub supported_codecs: Vec\u003cString\u003e,\n}\n\n/// Возможности GPU системы\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GpuCapabilities {\n  pub available_encoders: Vec\u003cGpuEncoder\u003e,\n  pub recommended_encoder: Option\u003cGpuEncoder\u003e,\n  pub current_gpu: Option\u003cGpuInfo\u003e,\n  pub hardware_acceleration_supported: bool,\n}\n\n/// Детектор GPU возможностей\npub struct GpuDetector {\n  ffmpeg_path: String,\n}\n\nimpl GpuDetector {\n  pub fn new(ffmpeg_path: String) -\u003e Self {\n    Self { ffmpeg_path }\n  }\n\n  /// Определить все доступные GPU кодировщики\n  pub async fn detect_available_encoders(\u0026self) -\u003e Result\u003cVec\u003cGpuEncoder\u003e\u003e {\n    let mut available = Vec::new();\n\n    // Проверяем каждый тип кодировщика\n    let encoders_to_check = [\n      (GpuEncoder::Nvenc, \"h264_nvenc\"),\n      (GpuEncoder::QuickSync, \"h264_qsv\"),\n      (GpuEncoder::Vaapi, \"h264_vaapi\"),\n      (GpuEncoder::VideoToolbox, \"h264_videotoolbox\"),\n      (GpuEncoder::AMF, \"h264_amf\"),\n    ];\n\n    for (encoder_type, codec_name) in encoders_to_check {\n      if self.check_encoder_available(codec_name).await? {\n        available.push(encoder_type);\n      }\n    }\n\n    Ok(available)\n  }\n\n  /// Проверить доступность конкретного кодировщика\n  async fn check_encoder_available(\u0026self, codec: \u0026str) -\u003e Result\u003cbool\u003e {\n    let output = tokio::process::Command::new(\u0026self.ffmpeg_path)\n      .args([\"-encoders\"])\n      .output()\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to run ffmpeg: {}\", e)))?;\n\n    if output.status.success() {\n      let stdout = String::from_utf8_lossy(\u0026output.stdout);\n      Ok(stdout.contains(codec))\n    } else {\n      Ok(false)\n    }\n  }\n\n  /// Получить рекомендуемый кодировщик для текущей платформы\n  pub async fn get_recommended_encoder(\u0026self) -\u003e Result\u003cOption\u003cGpuEncoder\u003e\u003e {\n    let available = self.detect_available_encoders().await?;\n\n    if available.is_empty() {\n      return Ok(None);\n    }\n\n    // Приоритет кодировщиков по платформам\n    #[cfg(target_os = \"windows\")]\n    let priority = [GpuEncoder::Nvenc, GpuEncoder::QuickSync, GpuEncoder::AMF];\n\n    #[cfg(target_os = \"linux\")]\n    let priority = [GpuEncoder::Nvenc, GpuEncoder::Vaapi, GpuEncoder::QuickSync];\n\n    #[cfg(target_os = \"macos\")]\n    let priority = [GpuEncoder::VideoToolbox, GpuEncoder::Nvenc];\n\n    #[cfg(not(any(target_os = \"windows\", target_os = \"linux\", target_os = \"macos\")))]\n    let priority = [GpuEncoder::Nvenc];\n\n    // Находим первый доступный из приоритетного списка\n    for preferred in \u0026priority {\n      if available.contains(preferred) {\n        return Ok(Some(preferred.clone()));\n      }\n    }\n\n    // Если ни один приоритетный не найден, берем первый доступный\n    Ok(available.first().cloned())\n  }\n\n  /// Получить полную информацию о возможностях GPU\n  pub async fn get_gpu_capabilities(\u0026self) -\u003e Result\u003cGpuCapabilities\u003e {\n    let available_encoders = self.detect_available_encoders().await?;\n    let recommended_encoder = self.get_recommended_encoder().await?;\n    let current_gpu = self.get_current_gpu_info().await.ok();\n\n    Ok(GpuCapabilities {\n      available_encoders: available_encoders.clone(),\n      recommended_encoder,\n      current_gpu,\n      hardware_acceleration_supported: !available_encoders.is_empty(),\n    })\n  }\n\n  /// Получить информацию о текущем GPU\n  async fn get_current_gpu_info(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Пытаемся определить тип GPU и получить информацию\n\n    #[cfg(target_os = \"windows\")]\n    {\n      if let Ok(info) = self.get_nvidia_info_windows().await {\n        return Ok(info);\n      }\n      if let Ok(info) = self.get_intel_info_windows().await {\n        return Ok(info);\n      }\n      if let Ok(info) = self.get_amd_info_windows().await {\n        return Ok(info);\n      }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    {\n      if let Ok(info) = self.get_nvidia_info_linux().await {\n        return Ok(info);\n      }\n      if let Ok(info) = self.get_gpu_info_linux().await {\n        return Ok(info);\n      }\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n      if let Ok(info) = self.get_gpu_info_macos().await {\n        return Ok(info);\n      }\n    }\n\n    // Fallback: создаем базовую информацию\n    Ok(GpuInfo {\n      name: \"Unknown GPU\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::None,\n      supported_codecs: vec![\"libx264\".to_string()],\n    })\n  }\n\n  /// Получить информацию о NVIDIA GPU (Windows)\n  #[cfg(target_os = \"windows\")]\n  async fn get_nvidia_info_windows(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    let output = tokio::process::Command::new(\"nvidia-smi\")\n      .args([\n        \"--query-gpu=name,driver_version,memory.total,memory.used,utilization.gpu\",\n        \"--format=csv,noheader,nounits\",\n      ])\n      .output()\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to run nvidia-smi: {}\", e)))?;\n\n    if !output.status.success() {\n      return Err(VideoCompilerError::gpu(\"nvidia-smi failed\"));\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let line = stdout\n      .lines()\n      .next()\n      .ok_or_else(|| VideoCompilerError::gpu(\"No GPU data from nvidia-smi\"))?;\n\n    let parts: Vec\u003c\u0026str\u003e = line.split(\", \").collect();\n    if parts.len() \u003e= 5 {\n      Ok(GpuInfo {\n        name: parts[0].trim().to_string(),\n        driver_version: Some(parts[1].trim().to_string()),\n        memory_total: parts[2].trim().parse::\u003cu64\u003e().ok().map(|m| m * 1024 * 1024),\n        memory_used: parts[3].trim().parse::\u003cu64\u003e().ok().map(|m| m * 1024 * 1024),\n        utilization: parts[4].trim().parse().ok(),\n        encoder_type: GpuEncoder::Nvenc,\n        supported_codecs: vec![\"h264_nvenc\".to_string(), \"hevc_nvenc\".to_string()],\n      })\n    } else {\n      Err(VideoCompilerError::gpu(\"Invalid nvidia-smi output format\"))\n    }\n  }\n\n  /// Получить информацию о NVIDIA GPU (Linux)\n  #[cfg(target_os = \"linux\")]\n  async fn get_nvidia_info_linux(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Аналогично Windows версии\n    self.get_nvidia_info_windows().await\n  }\n\n  /// Получить информацию о Intel GPU (Windows)\n  #[cfg(target_os = \"windows\")]\n  async fn get_intel_info_windows(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Для Intel можно использовать WMI или другие системные API\n    // Пока простая заглушка\n    Ok(GpuInfo {\n      name: \"Intel Graphics\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::QuickSync,\n      supported_codecs: vec![\"h264_qsv\".to_string(), \"hevc_qsv\".to_string()],\n    })\n  }\n\n  /// Получить информацию о AMD GPU (Windows)\n  #[cfg(target_os = \"windows\")]\n  async fn get_amd_info_windows(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    Ok(GpuInfo {\n      name: \"AMD Graphics\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::AMF,\n      supported_codecs: vec![\"h264_amf\".to_string(), \"hevc_amf\".to_string()],\n    })\n  }\n\n  /// Получить информацию о GPU (Linux через /sys)\n  #[cfg(target_os = \"linux\")]\n  async fn get_gpu_info_linux(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Читаем информацию из /sys/class/drm\n    use tokio::fs;\n\n    let drm_cards = fs::read_dir(\"/sys/class/drm\")\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to read /sys/class/drm: {}\", e)))?;\n\n    // Ищем первую видеокарту\n    // Это упрощенная реализация, можно расширить\n    Ok(GpuInfo {\n      name: \"Linux GPU\".to_string(),\n      driver_version: None,\n      memory_total: None,\n      memory_used: None,\n      utilization: None,\n      encoder_type: GpuEncoder::Vaapi,\n      supported_codecs: vec![\"h264_vaapi\".to_string()],\n    })\n  }\n\n  /// Получить информацию о GPU (macOS)\n  #[cfg(target_os = \"macos\")]\n  async fn get_gpu_info_macos(\u0026self) -\u003e Result\u003cGpuInfo\u003e {\n    // Используем system_profiler для получения информации\n    let output = tokio::process::Command::new(\"system_profiler\")\n      .args([\"SPDisplaysDataType\", \"-json\"])\n      .output()\n      .await\n      .map_err(|e| VideoCompilerError::Io(format!(\"Failed to run system_profiler: {}\", e)))?;\n\n    if output.status.success() {\n      // Парсим JSON вывод system_profiler\n      // Упрощенная реализация\n      Ok(GpuInfo {\n        name: \"macOS GPU\".to_string(),\n        driver_version: None,\n        memory_total: None,\n        memory_used: None,\n        utilization: None,\n        encoder_type: GpuEncoder::VideoToolbox,\n        supported_codecs: vec![\n          \"h264_videotoolbox\".to_string(),\n          \"hevc_videotoolbox\".to_string(),\n        ],\n      })\n    } else {\n      Err(VideoCompilerError::gpu(\"system_profiler failed\"))\n    }\n  }\n}\n\n/// Помощник для выбора GPU параметров\npub struct GpuHelper;\n\nimpl GpuHelper {\n  /// Получить параметры FFmpeg для конкретного GPU кодировщика\n  pub fn get_ffmpeg_params(encoder: \u0026GpuEncoder, quality: u8) -\u003e Vec\u003cString\u003e {\n    match encoder {\n      GpuEncoder::None =\u003e Self::get_cpu_params(quality),\n      GpuEncoder::Nvenc =\u003e Self::get_nvenc_params(quality),\n      GpuEncoder::QuickSync =\u003e Self::get_quicksync_params(quality),\n      GpuEncoder::Vaapi =\u003e Self::get_vaapi_params(quality),\n      GpuEncoder::VideoToolbox =\u003e Self::get_videotoolbox_params(quality),\n      GpuEncoder::AMF =\u003e Self::get_amf_params(quality),\n    }\n  }\n\n  /// Параметры для CPU кодирования\n  fn get_cpu_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    let preset = match quality {\n      0..=30 =\u003e \"ultrafast\",\n      31..=50 =\u003e \"superfast\",\n      51..=70 =\u003e \"fast\",\n      71..=85 =\u003e \"medium\",\n      86..=95 =\u003e \"slow\",\n      _ =\u003e \"slower\",\n    };\n\n    vec![\n      \"-preset\".to_string(),\n      preset.to_string(),\n      \"-crf\".to_string(),\n      Self::quality_to_crf(quality).to_string(),\n    ]\n  }\n\n  /// Параметры для NVIDIA NVENC\n  fn get_nvenc_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    let preset = match quality {\n      0..=40 =\u003e \"p1\", // Fastest\n      41..=60 =\u003e \"p2\",\n      61..=75 =\u003e \"p3\",\n      76..=85 =\u003e \"p4\", // Balanced\n      86..=90 =\u003e \"p5\",\n      91..=95 =\u003e \"p6\",\n      _ =\u003e \"p7\", // Slowest/Best quality\n    };\n\n    vec![\n      \"-preset\".to_string(),\n      preset.to_string(),\n      \"-tune\".to_string(),\n      \"hq\".to_string(),\n      \"-rc\".to_string(),\n      \"vbr\".to_string(),\n      \"-cq\".to_string(),\n      Self::quality_to_nvenc_cq(quality).to_string(),\n      \"-rc-lookahead\".to_string(),\n      \"20\".to_string(),\n      \"-spatial_aq\".to_string(),\n      \"1\".to_string(),\n      \"-temporal_aq\".to_string(),\n      \"1\".to_string(),\n    ]\n  }\n\n  /// Параметры для Intel QuickSync\n  fn get_quicksync_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    let preset = match quality {\n      0..=50 =\u003e \"veryfast\",\n      51..=75 =\u003e \"fast\",\n      76..=85 =\u003e \"medium\",\n      _ =\u003e \"slow\",\n    };\n\n    vec![\n      \"-preset\".to_string(),\n      preset.to_string(),\n      \"-global_quality\".to_string(),\n      Self::quality_to_qsv_quality(quality).to_string(),\n      \"-look_ahead\".to_string(),\n      \"1\".to_string(),\n      \"-look_ahead_depth\".to_string(),\n      \"20\".to_string(),\n    ]\n  }\n\n  /// Параметры для VAAPI\n  fn get_vaapi_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    vec![\n      \"-vaapi_device\".to_string(),\n      \"/dev/dri/renderD128\".to_string(),\n      \"-vf\".to_string(),\n      \"format=nv12,hwupload\".to_string(),\n      \"-rc_mode\".to_string(),\n      \"VBR\".to_string(),\n      \"-quality\".to_string(),\n      Self::quality_to_vaapi_quality(quality).to_string(),\n    ]\n  }\n\n  /// Параметры для VideoToolbox\n  fn get_videotoolbox_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    vec![\n      \"-profile:v\".to_string(),\n      \"high\".to_string(),\n      \"-level\".to_string(),\n      \"4.1\".to_string(),\n      \"-q:v\".to_string(),\n      Self::quality_to_videotoolbox_quality(quality).to_string(),\n      \"-allow_sw\".to_string(),\n      \"1\".to_string(),\n    ]\n  }\n\n  /// Параметры для AMD AMF\n  fn get_amf_params(quality: u8) -\u003e Vec\u003cString\u003e {\n    vec![\n      \"-usage\".to_string(),\n      \"transcoding\".to_string(),\n      \"-quality\".to_string(),\n      \"balanced\".to_string(),\n      \"-rc\".to_string(),\n      \"vbr_peak\".to_string(),\n      \"-qp_i\".to_string(),\n      Self::quality_to_amf_qp(quality).to_string(),\n    ]\n  }\n\n  /// Конвертация качества (0-100) в CRF (0-51)\n  fn quality_to_crf(quality: u8) -\u003e u8 {\n    // Инвертируем: высокое качество = низкий CRF\n    51 - (quality as f32 * 0.51) as u8\n  }\n\n  /// Конвертация качества в NVENC CQ параметр\n  fn quality_to_nvenc_cq(quality: u8) -\u003e u8 {\n    // NVENC CQ: 0-51, где 0 = лучшее качество\n    51 - (quality as f32 * 0.51) as u8\n  }\n\n  /// Конвертация качества в QuickSync quality\n  fn quality_to_qsv_quality(quality: u8) -\u003e u8 {\n    // QSV качество обычно 1-51\n    51 - (quality as f32 * 0.5) as u8\n  }\n\n  /// Конвертация качества в VAAPI quality\n  fn quality_to_vaapi_quality(quality: u8) -\u003e u8 {\n    // VAAPI качество 1-8, где 1 = лучшее\n    8 - (quality as f32 * 0.07) as u8\n  }\n\n  /// Конвертация качества в VideoToolbox quality\n  fn quality_to_videotoolbox_quality(quality: u8) -\u003e u8 {\n    // VideoToolbox q:v 1-100\n    quality.max(1)\n  }\n\n  /// Конвертация качества в AMF QP\n  fn quality_to_amf_qp(quality: u8) -\u003e u8 {\n    // AMF QP 0-51\n    51 - (quality as f32 * 0.51) as u8\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[tokio::test]\n  async fn test_gpu_encoder_codec_names() {\n    assert_eq!(GpuEncoder::Nvenc.h264_codec_name(), \"h264_nvenc\");\n    assert_eq!(GpuEncoder::QuickSync.h264_codec_name(), \"h264_qsv\");\n    assert_eq!(GpuEncoder::None.h264_codec_name(), \"libx264\");\n  }\n\n  #[tokio::test]\n  async fn test_quality_conversion() {\n    // Тест конвертации качества в CRF\n    assert_eq!(GpuHelper::quality_to_crf(100), 0); // Лучшее качество\n    assert_eq!(GpuHelper::quality_to_crf(0), 51); // Худшее качество\n    assert_eq!(GpuHelper::quality_to_crf(50), 26); // Среднее качество\n  }\n\n  #[tokio::test]\n  async fn test_gpu_params_generation() {\n    let params = GpuHelper::get_ffmpeg_params(\u0026GpuEncoder::Nvenc, 85);\n    assert!(params.contains(\u0026\"-preset\".to_string()));\n    assert!(params.contains(\u0026\"p4\".to_string()));\n  }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":22}},{"line":107,"address":[],"length":0,"stats":{"Line":12}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":20}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":10}},{"line":121,"address":[],"length":0,"stats":{"Line":20}},{"line":124,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":358,"address":[],"length":0,"stats":{"Line":3}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":1}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":2}},{"line":454,"address":[],"length":0,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":2}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":458,"address":[],"length":0,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":2}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":3}},{"line":483,"address":[],"length":0,"stats":{"Line":3}},{"line":487,"address":[],"length":0,"stats":{"Line":1}},{"line":489,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}}],"covered":77,"coverable":188},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","mod.rs"],"content":"//! Video Compiler Module - Центральный модуль компиляции видео\n//!\n//! Этот модуль отвечает за компиляцию проектов Timeline Studio в финальное видео\n//! с использованием FFmpeg. Включает в себя:\n//! - Схему данных проекта (ProjectSchema)\n//! - Рендерер видео (VideoRenderer)\n//! - Генератор превью (PreviewGenerator)\n//! - Отслеживание прогресса (ProgressTracker)\n\npub mod cache;\npub mod commands;\npub mod error;\npub mod ffmpeg_builder;\npub mod frame_extraction;\npub mod gpu;\npub mod pipeline;\npub mod preview;\npub mod progress;\npub mod renderer;\npub mod schema;\n\n#[cfg(test)]\nmod test_integration;\n\n// Re-export основных типов для удобства использования\npub use commands::VideoCompilerState;\npub use error::{Result, VideoCompilerError};\npub use preview::PreviewGenerator;\npub use progress::RenderProgress;\n\nuse serde::{Deserialize, Serialize};\n\n/// Настройки компилятора видео\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CompilerSettings {\n  /// Максимальное количество одновременных задач рендеринга\n  pub max_concurrent_jobs: usize,\n  /// Размер кэша в мегабайтах\n  pub cache_size_mb: usize,\n  /// Временная директория для промежуточных файлов\n  pub temp_directory: std::path::PathBuf,\n  /// Путь к FFmpeg (если не в системном PATH)\n  pub ffmpeg_path: Option\u003cstd::path::PathBuf\u003e,\n  /// Использование аппаратного ускорения\n  pub hardware_acceleration: bool,\n  /// Качество превью (от 1 до 100)\n  pub preview_quality: u8,\n}\n\nimpl Default for CompilerSettings {\n  fn default() -\u003e Self {\n    Self {\n      max_concurrent_jobs: 2,\n      cache_size_mb: 512,\n      temp_directory: std::env::temp_dir().join(\"timeline-studio\"),\n      ffmpeg_path: None,\n      hardware_acceleration: true,\n      preview_quality: 75,\n    }\n  }\n}\n\n/// События Video Compiler для WebSocket\n#[derive(Serialize, Debug, Clone)]\n#[serde(tag = \"type\")]\npub enum VideoCompilerEvent {\n  /// Рендеринг начат\n  RenderStarted { job_id: String },\n  /// Прогресс рендеринга обновлен\n  RenderProgress {\n    job_id: String,\n    progress: RenderProgress,\n  },\n  /// Рендеринг завершен успешно\n  RenderCompleted { job_id: String, output_path: String },\n  /// Рендеринг завершился с ошибкой\n  RenderFailed { job_id: String, error: String },\n  /// Превью сгенерировано\n  PreviewGenerated { timestamp: f64, image_data: Vec\u003cu8\u003e },\n  /// Кэш обновлен\n  CacheUpdated { cache_size_mb: f64 },\n}\n\n/// Проверка зависимостей Video Compiler и возврат пути к FFmpeg\npub async fn check_dependencies() -\u003e Result\u003cString\u003e {\n  // Список возможных путей к FFmpeg в разных системах\n  let ffmpeg_paths = vec![\n    \"ffmpeg\",                                     // По умолчанию в PATH\n    \"/usr/bin/ffmpeg\",                            // Linux стандартный путь\n    \"/usr/local/bin/ffmpeg\",                      // macOS через brew (Intel)\n    \"/opt/homebrew/bin/ffmpeg\",                   // macOS через brew (Apple Silicon)\n    \"/snap/bin/ffmpeg\",                           // Linux через snap\n    \"C:\\\\Program Files\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\", // Windows стандартный путь\n    \"C:\\\\ffmpeg\\\\bin\\\\ffmpeg.exe\",                // Windows альтернативный путь\n  ];\n\n  // Пробуем найти FFmpeg\n  for path in \u0026ffmpeg_paths {\n    log::debug!(\"Проверка FFmpeg по пути: {}\", path);\n\n    let output = tokio::process::Command::new(path)\n      .arg(\"-version\")\n      .output()\n      .await;\n\n    if let Ok(output) = output {\n      if output.status.success() {\n        log::info!(\"FFmpeg найден по пути: {}\", path);\n\n        // Извлекаем версию FFmpeg\n        if let Ok(version_str) = String::from_utf8(output.stdout) {\n          if let Some(version_line) = version_str.lines().next() {\n            log::info!(\"Версия FFmpeg: {}\", version_line);\n          }\n        }\n\n        return Ok(path.to_string());\n      }\n    }\n  }\n\n  // Если не нашли FFmpeg, пробуем which/where команду\n  let which_cmd = if cfg!(target_os = \"windows\") {\n    \"where\"\n  } else {\n    \"which\"\n  };\n\n  if let Ok(output) = tokio::process::Command::new(which_cmd)\n    .arg(\"ffmpeg\")\n    .output()\n    .await\n  {\n    if output.status.success() {\n      if let Ok(path_str) = String::from_utf8(output.stdout) {\n        let path = path_str.trim().to_string();\n        log::info!(\"FFmpeg найден через {}: {}\", which_cmd, path);\n        return Ok(path);\n      }\n    }\n  }\n\n  Err(VideoCompilerError::DependencyMissing(\n    \"FFmpeg не найден в системе. Установите FFmpeg для работы Video Compiler.\\n\\\n     Инструкции по установке:\\n\\\n     - macOS: brew install ffmpeg\\n\\\n     - Ubuntu/Debian: sudo apt install ffmpeg\\n\\\n     - Windows: скачайте с https://ffmpeg.org/download.html\"\n      .to_string(),\n  ))\n}\n\n/// Инициализация Video Compiler модуля\npub async fn initialize() -\u003e Result\u003cVideoCompilerState\u003e {\n  log::info!(\"Инициализация Video Compiler модуля\");\n\n  // Проверяем зависимости и получаем путь к FFmpeg\n  let ffmpeg_path = check_dependencies().await?;\n\n  // Создаем состояние с найденным путем FFmpeg\n  let mut state = VideoCompilerState::new();\n  state.ffmpeg_path = ffmpeg_path;\n\n  // Обновляем настройки\n  {\n    let settings = state.settings.write().await;\n\n    // Создаем временную директорию если не существует\n    if !settings.temp_directory.exists() {\n      tokio::fs::create_dir_all(\u0026settings.temp_directory.clone())\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n  }\n\n  log::info!(\n    \"Video Compiler модуль успешно инициализирован с FFmpeg: {}\",\n    \u0026state.ffmpeg_path\n  );\n  Ok(state)\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[tokio::test]\n  async fn test_video_compiler_state_creation() {\n    let state = VideoCompilerState::new();\n    assert_eq!(state.active_jobs.read().await.len(), 0);\n\n    let settings = state.settings.read().await;\n    assert_eq!(settings.max_concurrent_jobs, 2);\n    assert_eq!(settings.cache_size_mb, 512);\n  }\n\n  #[tokio::test]\n  async fn test_compiler_settings_default() {\n    let settings = CompilerSettings::default();\n    assert_eq!(settings.max_concurrent_jobs, 2);\n    assert_eq!(settings.cache_size_mb, 512);\n    assert!(settings.hardware_acceleration);\n    assert_eq!(settings.preview_quality, 75);\n  }\n\n  #[tokio::test]\n  async fn test_check_dependencies() {\n    // Тест может не пройти если FFmpeg не установлен, но это ожидаемо\n    match check_dependencies().await {\n      Ok(_) =\u003e println!(\"FFmpeg найден и работает\"),\n      Err(e) =\u003e println!(\"FFmpeg недоступен: {:?}\", e),\n    }\n  }\n\n  #[test]\n  fn test_video_compiler_event_serialization() {\n    let event = VideoCompilerEvent::RenderStarted {\n      job_id: \"test-123\".to_string(),\n    };\n\n    let json = serde_json::to_string(\u0026event).unwrap();\n    assert!(json.contains(\"RenderStarted\"));\n    assert!(json.contains(\"test-123\"));\n  }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":32}},{"line":55,"address":[],"length":0,"stats":{"Line":32}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}}],"covered":18,"coverable":35},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","pipeline.rs"],"content":"//! Pipeline - Модуль конвейера обработки видео\n//!\n//! Этот модуль реализует конвейер обработки видео проектов,\n//! включая этапы валидации, предобработки, композиции и кодирования.\n\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::sync::RwLock;\n\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::progress::ProgressTracker;\nuse crate::video_compiler::schema::ProjectSchema;\nuse crate::video_compiler::CompilerSettings;\n\n/// Основной конвейер обработки видео\n#[derive(Debug)]\npub struct RenderPipeline {\n  /// Схема проекта\n  project: ProjectSchema,\n  /// Этапы конвейера\n  stages: Vec\u003cBox\u003cdyn PipelineStage\u003e\u003e,\n  /// Трекер прогресса\n  progress_tracker: Arc\u003cProgressTracker\u003e,\n  /// Настройки\n  settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n  /// Контекст выполнения\n  context: PipelineContext,\n}\n\nimpl RenderPipeline {\n  /// Создать новый конвейер\n  pub async fn new(\n    project: ProjectSchema,\n    progress_tracker: Arc\u003cProgressTracker\u003e,\n    settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n    output_path: PathBuf,\n  ) -\u003e Result\u003cSelf\u003e {\n    let context = PipelineContext::new(project.clone(), output_path);\n\n    let mut pipeline = Self {\n      project,\n      stages: Vec::new(),\n      progress_tracker,\n      settings,\n      context,\n    };\n\n    // Добавляем стандартные этапы\n    pipeline.add_default_stages().await?;\n\n    Ok(pipeline)\n  }\n\n  /// Добавить стандартные этапы конвейера\n  async fn add_default_stages(\u0026mut self) -\u003e Result\u003c()\u003e {\n    self.add_stage(Box::new(ValidationStage::new()));\n    self.add_stage(Box::new(PreprocessingStage::new()));\n    self.add_stage(Box::new(CompositionStage::new()));\n    self.add_stage(Box::new(EncodingStage::new()));\n    self.add_stage(Box::new(FinalizationStage::new()));\n    Ok(())\n  }\n\n  /// Добавить этап в конвейер\n  pub fn add_stage(\u0026mut self, stage: Box\u003cdyn PipelineStage\u003e) {\n    self.stages.push(stage);\n  }\n\n  /// Выполнить весь конвейер\n  pub async fn execute(\u0026mut self, job_id: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n    log::info!(\"=== Запуск конвейера обработки ===\");\n    log::info!(\"ID задачи: {}\", job_id);\n    log::info!(\"Проект: {}\", self.project.metadata.name);\n    log::info!(\"Выходной файл: {:?}\", self.context.output_path);\n    log::info!(\"Временная директория: {:?}\", self.context.temp_dir);\n    log::info!(\"Количество этапов: {}\", self.stages.len());\n\n    // Создаем временную директорию\n    self.context.ensure_temp_dir().await?;\n\n    let total_stages = self.stages.len();\n    let mut current_stage = 0;\n\n    for stage in \u0026self.stages {\n      current_stage += 1;\n      let stage_name = stage.name();\n\n      log::info!(\n        \"[{}/{}] Начало этапа: {}\",\n        current_stage,\n        total_stages,\n        stage_name\n      );\n\n      // Проверяем отмену\n      if self.context.is_cancelled() {\n        log::warn!(\"Конвейер отменен пользователем\");\n        return Err(VideoCompilerError::render(\n          job_id,\n          stage_name,\n          \"Операция отменена пользователем\".to_string(),\n        ));\n      }\n\n      // Обновляем прогресс\n      let progress_percentage = ((current_stage - 1) as f64 / total_stages as f64) * 100.0;\n      if let Err(e) = self\n        .update_progress(job_id, progress_percentage as u64, stage_name)\n        .await\n      {\n        log::warn!(\"Не удалось обновить прогресс: {}\", e);\n        // Продолжаем выполнение\n      }\n\n      // Выполняем этап\n      let start_time = SystemTime::now();\n\n      match stage.process(\u0026mut self.context).await {\n        Ok(_) =\u003e {\n          let duration = start_time.elapsed().unwrap_or(Duration::ZERO);\n          log::info!(\n            \"✓ Этап '{}' завершен за {:.2}с\",\n            stage_name,\n            duration.as_secs_f64()\n          );\n\n          // Обновляем статистику\n          // Для отслеживания прогресса используем frames_processed\n          self.context.statistics.frames_processed += 1;\n        }\n        Err(e) =\u003e {\n          log::error!(\"✗ Ошибка на этапе '{}': {}\", stage_name, e);\n          log::error!(\"  Код ошибки: {}\", e.error_code());\n          log::error!(\n            \"  Критическая: {}\",\n            if e.is_critical() { \"да\" } else { \"нет\" }\n          );\n          log::error!(\n            \"  Можно повторить: {}\",\n            if e.is_retryable() { \"да\" } else { \"нет\" }\n          );\n          log::debug!(\"Детали ошибки: {:?}\", e);\n\n          // Очищаем временные файлы при ошибке\n          if let Err(cleanup_err) = self.context.cleanup().await {\n            log::warn!(\"Не удалось очистить временные файлы: {}\", cleanup_err);\n          }\n\n          return Err(VideoCompilerError::render(\n            job_id,\n            stage_name,\n            e.to_string(),\n          ));\n        }\n      }\n    }\n\n    // Финальное обновление прогресса\n    self.update_progress(job_id, 100, \"Completed\").await?;\n\n    // Очищаем временные файлы\n    if let Err(e) = self.context.cleanup().await {\n      log::warn!(\"Не удалось очистить временные файлы: {}\", e);\n    }\n\n    log::info!(\"=== Конвейер обработки завершен успешно ===\");\n    log::info!(\"Выходной файл: {:?}\", self.context.output_path);\n    log::info!(\n      \"Общее время: {:.2}с\",\n      self.context.statistics.total_duration().as_secs_f64()\n    );\n\n    Ok(self.context.output_path.clone())\n  }\n\n  /// Обновить прогресс выполнения\n  async fn update_progress(\u0026self, job_id: \u0026str, percentage: u64, stage: \u0026str) -\u003e Result\u003c()\u003e {\n    let total_frames = (self.project.get_duration() * self.project.timeline.fps as f64) as u64;\n    let current_frame = (total_frames * percentage) / 100;\n\n    self\n      .progress_tracker\n      .update_progress(job_id, current_frame, stage.to_string(), None)\n      .await\n  }\n\n  /// Отменить выполнение конвейера\n  pub async fn cancel(\u0026mut self) -\u003e Result\u003c()\u003e {\n    self.context.cancelled = true;\n    log::info!(\"Конвейер отменен\");\n    Ok(())\n  }\n\n  /// Получить статистику выполнения\n  pub fn get_statistics(\u0026self) -\u003e PipelineStatistics {\n    self.context.statistics.clone()\n  }\n}\n\n/// Контекст выполнения конвейера\n#[derive(Debug)]\npub struct PipelineContext {\n  /// Схема проекта\n  pub project: ProjectSchema,\n  /// Путь к выходному файлу\n  pub output_path: PathBuf,\n  /// Временная директория\n  pub temp_dir: PathBuf,\n  /// Промежуточные файлы\n  pub intermediate_files: HashMap\u003cString, PathBuf\u003e,\n  /// Флаг отмены\n  pub cancelled: bool,\n  /// Пользовательские данные\n  pub user_data: HashMap\u003cString, serde_json::Value\u003e,\n  /// Статистика выполнения\n  pub statistics: PipelineStatistics,\n}\n\nimpl PipelineContext {\n  /// Создать новый контекст\n  pub fn new(project: ProjectSchema, output_path: PathBuf) -\u003e Self {\n    let temp_dir = std::env::temp_dir()\n      .join(\"timeline-studio\")\n      .join(\"pipeline\")\n      .join(uuid::Uuid::new_v4().to_string());\n\n    Self {\n      project,\n      output_path,\n      temp_dir,\n      intermediate_files: HashMap::new(),\n      cancelled: false,\n      user_data: HashMap::new(),\n      statistics: PipelineStatistics::default(),\n    }\n  }\n\n  /// Добавить промежуточный файл\n  pub fn add_intermediate_file(\u0026mut self, key: String, path: PathBuf) {\n    self.intermediate_files.insert(key, path);\n  }\n\n  /// Получить промежуточный файл\n  pub fn get_intermediate_file(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026PathBuf\u003e {\n    self.intermediate_files.get(key)\n  }\n\n  /// Проверить, отменено ли выполнение\n  pub fn is_cancelled(\u0026self) -\u003e bool {\n    self.cancelled\n  }\n\n  /// Создать временную директорию\n  pub async fn ensure_temp_dir(\u0026self) -\u003e Result\u003c()\u003e {\n    if !self.temp_dir.exists() {\n      tokio::fs::create_dir_all(\u0026self.temp_dir)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n    Ok(())\n  }\n\n  /// Очистить временные файлы\n  pub async fn cleanup(\u0026self) -\u003e Result\u003c()\u003e {\n    if self.temp_dir.exists() {\n      tokio::fs::remove_dir_all(\u0026self.temp_dir)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n    Ok(())\n  }\n}\n\n/// Трейт для этапа конвейера\n#[async_trait]\npub trait PipelineStage: Send + Sync + std::fmt::Debug {\n  /// Выполнить этап\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e;\n\n  /// Получить название этапа\n  fn name(\u0026self) -\u003e \u0026str;\n\n  /// Получить оценочную длительность этапа\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(10)\n  }\n\n  /// Проверить, можно ли пропустить этап\n  fn can_skip(\u0026self, _context: \u0026PipelineContext) -\u003e bool {\n    false\n  }\n}\n\n/// Этап валидации проекта\n#[derive(Debug)]\npub struct ValidationStage;\n\nimpl ValidationStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for ValidationStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало валидации проекта\");\n\n    // Валидация схемы проекта\n    context\n      .project\n      .validate()\n      .map_err(VideoCompilerError::validation)?;\n\n    // Проверка существования медиа файлов и их форматов\n    for track in \u0026context.project.tracks {\n      for clip in \u0026track.clips {\n        // Проверка существования\n        if !clip.source_path.exists() {\n          return Err(VideoCompilerError::media_file(\n            clip.source_path.to_string_lossy(),\n            \"Файл не найден\",\n          ));\n        }\n\n        // Проверка поддерживаемых форматов\n        let extension = clip\n          .source_path\n          .extension()\n          .and_then(|ext| ext.to_str())\n          .unwrap_or(\"\");\n\n        let supported_formats = match track.track_type {\n          crate::video_compiler::schema::TrackType::Video =\u003e {\n            vec![\n              \"mp4\", \"mov\", \"avi\", \"mkv\", \"webm\", \"flv\", \"m4v\", \"jpg\", \"jpeg\", \"png\", \"gif\", \"bmp\",\n              \"webp\",\n            ]\n          }\n          crate::video_compiler::schema::TrackType::Audio =\u003e {\n            vec![\"mp3\", \"wav\", \"aac\", \"m4a\", \"flac\", \"ogg\", \"wma\"]\n          }\n          crate::video_compiler::schema::TrackType::Subtitle =\u003e {\n            vec![\"srt\", \"vtt\", \"ass\", \"ssa\"]\n          }\n        };\n\n        if !supported_formats.contains(\u0026extension.to_lowercase().as_str()) {\n          return Err(VideoCompilerError::media_file(\n            clip.source_path.to_string_lossy(),\n            format!(\"Неподдерживаемый формат файла: .{}\", extension),\n          ));\n        }\n\n        // Проверка временных интервалов\n        if clip.start_time \u003c 0.0 {\n          return Err(VideoCompilerError::validation(format!(\n            \"Некорректное время начала клипа: {}\",\n            clip.start_time\n          )));\n        }\n\n        let duration = clip.end_time - clip.start_time;\n        if duration \u003c= 0.0 {\n          return Err(VideoCompilerError::validation(format!(\n            \"Некорректная длительность клипа: {}\",\n            duration\n          )));\n        }\n      }\n    }\n\n    // Создание временной директории\n    context.ensure_temp_dir().await?;\n\n    context.statistics.validation_time = SystemTime::now();\n    log::info!(\"Валидация проекта завершена успешно\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Validation\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(5)\n  }\n}\n\n/// Этап предобработки медиа\n#[derive(Debug)]\npub struct PreprocessingStage;\n\nimpl PreprocessingStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for PreprocessingStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало предобработки медиа\");\n\n    // Анализ медиа файлов\n    for track in \u0026context.project.tracks {\n      for clip in \u0026track.clips {\n        self.analyze_media_file(\u0026clip.source_path).await?;\n      }\n    }\n\n    // Подготовка промежуточных файлов\n    self.prepare_intermediate_files(context).await?;\n\n    context.statistics.preprocessing_time = SystemTime::now();\n    log::info!(\"Предобработка медиа завершена\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Preprocessing\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(30)\n  }\n}\n\nimpl PreprocessingStage {\n  /// Анализ медиа файла через FFprobe\n  async fn analyze_media_file(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    // Проверяем доступность файла\n    if !path.exists() {\n      return Err(VideoCompilerError::media_file(\n        path.to_string_lossy().to_string(),\n        \"Файл не существует\".to_string(),\n      ));\n    }\n\n    // Запускаем FFprobe для анализа\n    let output = Command::new(\"ffprobe\")\n      .args([\n        \"-v\",\n        \"error\",\n        \"-select_streams\",\n        \"v:0\",\n        \"-show_entries\",\n        \"stream=codec_name,width,height,r_frame_rate,duration\",\n        \"-of\",\n        \"json\",\n        path.to_str().unwrap(),\n      ])\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFprobe: {}\", e),\n          \"ffprobe\".to_string(),\n        )\n      })?;\n\n    if !output.status.success() {\n      let error = String::from_utf8_lossy(\u0026output.stderr);\n      return Err(VideoCompilerError::media_file(\n        path.to_string_lossy(),\n        format!(\"FFprobe ошибка: {}\", error),\n      ));\n    }\n\n    // Парсим JSON результат\n    let json_str = String::from_utf8_lossy(\u0026output.stdout);\n    let probe_data: serde_json::Value = serde_json::from_str(\u0026json_str).map_err(|e| {\n      VideoCompilerError::media_file(\n        path.to_string_lossy(),\n        format!(\"Ошибка парсинга FFprobe данных: {}\", e),\n      )\n    })?;\n\n    // Логируем информацию о файле\n    if let Some(streams) = probe_data[\"streams\"].as_array() {\n      if let Some(stream) = streams.first() {\n        log::info!(\n          \"Медиа файл {}: {}x{}, codec: {}, fps: {}\",\n          path.display(),\n          stream[\"width\"].as_u64().unwrap_or(0),\n          stream[\"height\"].as_u64().unwrap_or(0),\n          stream[\"codec_name\"].as_str().unwrap_or(\"unknown\"),\n          stream[\"r_frame_rate\"].as_str().unwrap_or(\"unknown\")\n        );\n      }\n    }\n\n    // Здесь можно добавить дополнительную логику анализа\n    log::debug!(\"Анализ файла: {:?}\", path);\n    Ok(())\n  }\n\n  /// Подготовка промежуточных файлов\n  async fn prepare_intermediate_files(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::debug!(\"Подготовка промежуточных файлов\");\n\n    // Собираем информацию о необходимых преобразованиях\n    let mut conversions = Vec::new();\n\n    for (track_idx, track) in context.project.tracks.iter().enumerate() {\n      for (clip_idx, clip) in track.clips.iter().enumerate() {\n        // Проверяем нужно ли конвертировать файл\n        let needs_conversion = self.check_needs_conversion(\u0026clip.source_path).await?;\n\n        if needs_conversion {\n          conversions.push((track_idx, clip_idx, clip.source_path.clone()));\n        }\n      }\n    }\n\n    // Теперь добавляем промежуточные файлы\n    for (track_idx, clip_idx, source_path) in conversions {\n      // Создаем путь для временного файла\n      let temp_file = context\n        .temp_dir\n        .join(format!(\"track_{}_clip_{}_temp.mp4\", track_idx, clip_idx));\n\n      // Сохраняем информацию о временном файле\n      let key = format!(\"track_{}_clip_{}\", track_idx, clip_idx);\n      context.add_intermediate_file(key, temp_file);\n\n      log::info!(\"Клип {} требует преобразования\", source_path.display());\n    }\n\n    // Создаем основные промежуточные файлы для композиции\n    let video_composite = context.temp_dir.join(\"video_composite.mp4\");\n    let audio_composite = context.temp_dir.join(\"audio_composite.wav\");\n\n    context.add_intermediate_file(\"video_composite\".to_string(), video_composite);\n    context.add_intermediate_file(\"audio_composite\".to_string(), audio_composite);\n\n    Ok(())\n  }\n\n  /// Проверка необходимости конвертации\n  async fn check_needs_conversion(\u0026self, path: \u0026Path) -\u003e Result\u003cbool\u003e {\n    // Простая проверка по расширению\n    // В реальности здесь должна быть проверка кодеков через FFprobe\n    let extension = path.extension().and_then(|ext| ext.to_str()).unwrap_or(\"\");\n\n    // Форматы, которые требуют конвертации\n    let needs_conversion_formats = [\"avi\", \"flv\", \"wmv\", \"mkv\"];\n\n    Ok(needs_conversion_formats.contains(\u0026extension.to_lowercase().as_str()))\n  }\n}\n\n/// Этап композиции видео\n#[derive(Debug)]\npub struct CompositionStage;\n\nimpl CompositionStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for CompositionStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало композиции видео\");\n\n    // Проверка отмены\n    if context.is_cancelled() {\n      return Err(VideoCompilerError::CancelledError(\n        \"Композиция отменена\".to_string(),\n      ));\n    }\n\n    // Композиция видео дорожек\n    self.compose_video_tracks(context).await?;\n\n    // Композиция аудио дорожек\n    self.compose_audio_tracks(context).await?;\n\n    context.statistics.composition_time = SystemTime::now();\n    log::info!(\"Композиция видео завершена\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Composition\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(120)\n  }\n}\n\nimpl CompositionStage {\n  /// Композиция видео дорожек\n  async fn compose_video_tracks(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    let video_tracks: Vec\u003c_\u003e = context\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.track_type == crate::video_compiler::schema::TrackType::Video)\n      .collect();\n\n    if video_tracks.is_empty() {\n      return Err(VideoCompilerError::validation(\n        \"Нет видео дорожек для композиции\",\n      ));\n    }\n\n    log::debug!(\"Композиция {} видео дорожек\", video_tracks.len());\n\n    // Строим команду FFmpeg для композиции видео\n    let ffmpeg_command = self.build_video_composition_command(context, \u0026video_tracks)?;\n\n    // Выполняем команду FFmpeg\n    log::info!(\"Запуск композиции видео\");\n    let output = Command::new(\u0026ffmpeg_command[0])\n      .args(\u0026ffmpeg_command[1..])\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFmpeg для видео композиции: {}\", e),\n          \"video composition\".to_string(),\n        )\n      })?;\n\n    if !output.status.success() {\n      let error = String::from_utf8_lossy(\u0026output.stderr);\n      return Err(VideoCompilerError::ffmpeg(\n        output.status.code(),\n        format!(\"FFmpeg видео композиция не удалась: {}\", error),\n        \"video composition\".to_string(),\n      ));\n    }\n\n    log::info!(\"Видео композиция завершена успешно\");\n    Ok(())\n  }\n\n  /// Построение команды FFmpeg для композиции видео\n  fn build_video_composition_command(\n    \u0026self,\n    context: \u0026PipelineContext,\n    video_tracks: \u0026[\u0026crate::video_compiler::schema::Track],\n  ) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut command = vec![\"ffmpeg\".to_string()];\n\n    // Добавляем входные файлы\n    let mut input_count = 0;\n    for track in video_tracks {\n      for clip in \u0026track.clips {\n        command.extend([\n          \"-i\".to_string(),\n          clip.source_path.to_string_lossy().to_string(),\n        ]);\n        input_count += 1;\n      }\n    }\n\n    // Если только один клип - простое копирование\n    if input_count == 1 {\n      command.extend([\n        \"-c:v\".to_string(),\n        \"copy\".to_string(),\n        \"-an\".to_string(), // Без аудио на этом этапе\n      ]);\n    } else {\n      // Сложная композиция с filter_complex\n      let mut filter_complex = String::new();\n\n      // Простой пример конкатенации\n      for i in 0..input_count {\n        filter_complex.push_str(\u0026format!(\"[{}:v]\", i));\n      }\n      filter_complex.push_str(\u0026format!(\"concat=n={}:v=1:a=0[outv]\", input_count));\n\n      command.extend([\n        \"-filter_complex\".to_string(),\n        filter_complex,\n        \"-map\".to_string(),\n        \"[outv]\".to_string(),\n      ]);\n    }\n\n    // Выходной файл\n    if let Some(video_composite) = context.intermediate_files.get(\"video_composite\") {\n      command.push(video_composite.to_string_lossy().to_string());\n    }\n\n    log::debug!(\"FFmpeg команда для видео: {:?}\", command);\n    Ok(command)\n  }\n\n  /// Композиция аудио дорожек\n  async fn compose_audio_tracks(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    let audio_tracks: Vec\u003c_\u003e = context\n      .project\n      .tracks\n      .iter()\n      .filter(|t| t.track_type == crate::video_compiler::schema::TrackType::Audio)\n      .collect();\n\n    if audio_tracks.is_empty() {\n      log::info!(\"Нет аудио дорожек для композиции\");\n      return Ok(());\n    }\n\n    log::debug!(\"Композиция {} аудио дорожек\", audio_tracks.len());\n\n    // Строим команду FFmpeg для композиции аудио\n    let ffmpeg_command = self.build_audio_composition_command(context, \u0026audio_tracks)?;\n\n    // Выполняем команду FFmpeg\n    log::info!(\"Запуск композиции аудио\");\n    let output = Command::new(\u0026ffmpeg_command[0])\n      .args(\u0026ffmpeg_command[1..])\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFmpeg для аудио композиции: {}\", e),\n          \"audio composition\".to_string(),\n        )\n      })?;\n\n    if !output.status.success() {\n      let error = String::from_utf8_lossy(\u0026output.stderr);\n      return Err(VideoCompilerError::ffmpeg(\n        output.status.code(),\n        format!(\"FFmpeg аудио композиция не удалась: {}\", error),\n        \"audio composition\".to_string(),\n      ));\n    }\n\n    log::info!(\"Аудио композиция завершена успешно\");\n    Ok(())\n  }\n\n  /// Построение команды FFmpeg для композиции аудио\n  fn build_audio_composition_command(\n    \u0026self,\n    context: \u0026PipelineContext,\n    audio_tracks: \u0026[\u0026crate::video_compiler::schema::Track],\n  ) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut command = vec![\"ffmpeg\".to_string()];\n\n    // Добавляем входные файлы\n    let mut input_count = 0;\n    for track in audio_tracks {\n      for clip in \u0026track.clips {\n        command.extend([\n          \"-i\".to_string(),\n          clip.source_path.to_string_lossy().to_string(),\n        ]);\n        input_count += 1;\n      }\n    }\n\n    // Если только один аудио клип - простое копирование\n    if input_count == 1 {\n      command.extend([\n        \"-c:a\".to_string(),\n        \"copy\".to_string(),\n        \"-vn\".to_string(), // Без видео на этом этапе\n      ]);\n    } else {\n      // Сложное микширование с amerge или amix\n      let mut filter_complex = String::new();\n\n      // Используем amix для микширования нескольких аудио потоков\n      for i in 0..input_count {\n        filter_complex.push_str(\u0026format!(\"[{}:a]\", i));\n      }\n      filter_complex.push_str(\u0026format!(\n        \"amix=inputs={}:duration=longest:dropout_transition=2[outa]\",\n        input_count\n      ));\n\n      command.extend([\n        \"-filter_complex\".to_string(),\n        filter_complex,\n        \"-map\".to_string(),\n        \"[outa]\".to_string(),\n      ]);\n    }\n\n    // Выходной файл\n    if let Some(audio_composite) = context.intermediate_files.get(\"audio_composite\") {\n      command.push(audio_composite.to_string_lossy().to_string());\n    }\n\n    log::debug!(\"FFmpeg команда для аудио: {:?}\", command);\n    Ok(command)\n  }\n}\n\n/// Этап кодирования\n#[derive(Debug)]\npub struct EncodingStage;\n\nimpl EncodingStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for EncodingStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало кодирования видео\");\n\n    // Проверка отмены\n    if context.is_cancelled() {\n      return Err(VideoCompilerError::CancelledError(\n        \"Кодирование отменено\".to_string(),\n      ));\n    }\n\n    // Кодирование финального видео\n    self.encode_final_video(context).await?;\n\n    context.statistics.encoding_time = SystemTime::now();\n    log::info!(\"Кодирование видео завершено\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Encoding\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(300)\n  }\n}\n\nimpl EncodingStage {\n  /// Кодирование финального видео\n  async fn encode_final_video(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::io::{AsyncBufReadExt, BufReader};\n    use tokio::process::Command;\n\n    log::info!(\"Начало кодирования в файл: {:?}\", context.output_path);\n\n    // Создаем родительскую директорию если не существует\n    if let Some(parent) = context.output_path.parent() {\n      tokio::fs::create_dir_all(parent)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(e.to_string()))?;\n    }\n\n    // Получаем промежуточные файлы\n    let video_composite = context\n      .get_intermediate_file(\"video_composite\")\n      .ok_or_else(|| {\n        VideoCompilerError::render(\n          \"encoding\",\n          \"missing_video\",\n          \"Промежуточный видео файл не найден\",\n        )\n      })?;\n\n    let audio_composite = context.get_intermediate_file(\"audio_composite\");\n\n    // Строим финальную команду FFmpeg\n    let mut command = vec![\"ffmpeg\".to_string(), \"-y\".to_string()]; // -y для перезаписи\n\n    // Добавляем видео вход\n    command.extend([\n      \"-i\".to_string(),\n      video_composite.to_string_lossy().to_string(),\n    ]);\n\n    // Добавляем аудио вход если есть\n    if let Some(audio_path) = audio_composite {\n      command.extend([\"-i\".to_string(), audio_path.to_string_lossy().to_string()]);\n      // Маппинг видео и аудио\n      command.extend([\n        \"-map\".to_string(),\n        \"0:v\".to_string(),\n        \"-map\".to_string(),\n        \"1:a\".to_string(),\n      ]);\n    } else {\n      // Только видео\n      command.extend([\"-map\".to_string(), \"0:v\".to_string()]);\n    }\n\n    // Кодеки и настройки качества\n    command.extend([\n      \"-c:v\".to_string(),\n      \"libx264\".to_string(),\n      \"-preset\".to_string(),\n      \"medium\".to_string(),\n      \"-crf\".to_string(),\n      \"23\".to_string(),\n      \"-c:a\".to_string(),\n      \"aac\".to_string(),\n      \"-b:a\".to_string(),\n      \"192k\".to_string(),\n      \"-movflags\".to_string(),\n      \"+faststart\".to_string(), // Для веб-воспроизведения\n    ]);\n\n    // Разрешение и FPS из timeline\n    let resolution = context.project.timeline.resolution;\n    command.extend([\n      \"-vf\".to_string(),\n      format!(\"scale={}:{}\", resolution.0, resolution.1),\n      \"-r\".to_string(),\n      context.project.timeline.fps.to_string(),\n    ]);\n\n    // Выходной файл\n    command.push(context.output_path.to_string_lossy().to_string());\n\n    log::debug!(\"Финальная FFmpeg команда: {:?}\", command);\n\n    // Запускаем FFmpeg процесс\n    let mut child = Command::new(\u0026command[0])\n      .args(\u0026command[1..])\n      .stderr(std::process::Stdio::piped())\n      .spawn()\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось запустить FFmpeg: {}\", e),\n          \"ffmpeg spawn\".to_string(),\n        )\n      })?;\n\n    // Читаем stderr для прогресса\n    if let Some(stderr) = child.stderr.take() {\n      let reader = BufReader::new(stderr);\n      let mut lines = reader.lines();\n\n      while let Some(line) = lines.next_line().await.ok().flatten() {\n        // Парсим прогресс из вывода FFmpeg\n        if line.contains(\"frame=\") {\n          self.parse_ffmpeg_progress(\u0026line, context);\n        }\n        log::trace!(\"FFmpeg: {}\", line);\n\n        // Проверяем отмену\n        if context.is_cancelled() {\n          child.kill().await.ok();\n          return Err(VideoCompilerError::CancelledError(\n            \"Кодирование отменено пользователем\".to_string(),\n          ));\n        }\n      }\n    }\n\n    // Ждем завершения процесса\n    let status = child.wait().await.map_err(|e| {\n      VideoCompilerError::ffmpeg(\n        None,\n        format!(\"Ошибка ожидания FFmpeg: {}\", e),\n        \"ffmpeg wait\".to_string(),\n      )\n    })?;\n\n    if !status.success() {\n      return Err(VideoCompilerError::ffmpeg(\n        status.code(),\n        \"FFmpeg завершился с ошибкой\".to_string(),\n        \"ffmpeg encoding\".to_string(),\n      ));\n    }\n\n    // Проверяем что файл создан\n    if !context.output_path.exists() {\n      return Err(VideoCompilerError::render(\n        \"encoding\",\n        \"output_missing\",\n        \"Выходной файл не был создан\",\n      ));\n    }\n\n    log::info!(\"Кодирование завершено успешно\");\n    Ok(())\n  }\n\n  /// Парсинг прогресса из вывода FFmpeg\n  fn parse_ffmpeg_progress(\u0026self, line: \u0026str, context: \u0026mut PipelineContext) {\n    // Пример строки: frame= 2490 fps=100 q=29.0 size=    5376kB time=00:00:41.50 bitrate=1061.2kbits/s\n    if let Some(frame_match) = line.split(\"frame=\").nth(1) {\n      if let Some(frame_str) = frame_match.split_whitespace().next() {\n        if let Ok(frame) = frame_str.trim().parse::\u003cu64\u003e() {\n          context.statistics.frames_processed = frame;\n          log::trace!(\"Обработано кадров: {}\", frame);\n        }\n      }\n    }\n  }\n}\n\n/// Этап финализации\n#[derive(Debug)]\npub struct FinalizationStage;\n\nimpl FinalizationStage {\n  pub fn new() -\u003e Self {\n    Self\n  }\n}\n\n#[async_trait]\nimpl PipelineStage for FinalizationStage {\n  async fn process(\u0026self, context: \u0026mut PipelineContext) -\u003e Result\u003c()\u003e {\n    log::info!(\"Начало финализации\");\n\n    // Проверка выходного файла\n    if !context.output_path.exists() {\n      return Err(VideoCompilerError::render(\n        \"finalization\",\n        \"file_check\",\n        \"Выходной файл не был создан\",\n      ));\n    }\n\n    // Получаем размер файла\n    let file_size = tokio::fs::metadata(\u0026context.output_path)\n      .await\n      .map(|m| m.len())\n      .unwrap_or(0);\n\n    log::info!(\n      \"Выходной файл создан: {:?}, размер: {} МБ\",\n      context.output_path,\n      file_size / 1_048_576\n    );\n\n    // Добавляем метаданные к файлу\n    self.add_metadata(context).await?;\n\n    // Сохраняем статистику\n    self.save_statistics(context).await?;\n\n    // Очистка временных файлов\n    if !context.is_cancelled() {\n      log::info!(\"Очистка временных файлов\");\n      context.cleanup().await?;\n    } else {\n      log::warn!(\"Пропуск очистки временных файлов из-за отмены\");\n    }\n\n    context.statistics.finalization_time = SystemTime::now();\n    log::info!(\"Финализация завершена успешно\");\n    Ok(())\n  }\n\n  fn name(\u0026self) -\u003e \u0026str {\n    \"Finalization\"\n  }\n\n  fn estimated_duration(\u0026self) -\u003e Duration {\n    Duration::from_secs(5)\n  }\n}\n\nimpl FinalizationStage {\n  /// Добавление метаданных к выходному файлу\n  async fn add_metadata(\u0026self, context: \u0026PipelineContext) -\u003e Result\u003c()\u003e {\n    use tokio::process::Command;\n\n    // Создаем временные строки для метаданных\n    let title_meta = format!(\"title={}\", context.project.metadata.name);\n    let artist_meta = \"artist=Timeline Studio\".to_string();\n    let date_meta = format!(\"date={}\", chrono::Utc::now().format(\"%Y-%m-%d\"));\n    let comment_meta = format!(\n      \"comment=Created with Timeline Studio v{}\",\n      context.project.version\n    );\n    let tmp_file = format!(\"{}.tmp\", context.output_path.to_string_lossy());\n\n    let metadata_args = vec![\n      \"-i\",\n      context.output_path.to_str().unwrap(),\n      \"-c\",\n      \"copy\",\n      \"-metadata\",\n      \u0026title_meta,\n      \"-metadata\",\n      \u0026artist_meta,\n      \"-metadata\",\n      \u0026date_meta,\n      \"-metadata\",\n      \u0026comment_meta,\n      \"-y\", // Перезаписать\n      \u0026tmp_file,\n    ];\n\n    let output = Command::new(\"ffmpeg\")\n      .args(\u0026metadata_args)\n      .output()\n      .await\n      .map_err(|e| {\n        VideoCompilerError::ffmpeg(\n          None,\n          format!(\"Не удалось добавить метаданные: {}\", e),\n          \"add metadata\".to_string(),\n        )\n      })?;\n\n    if output.status.success() {\n      // Заменяем оригинальный файл\n      tokio::fs::rename(\u0026tmp_file, \u0026context.output_path)\n        .await\n        .map_err(|e| VideoCompilerError::IoError(format!(\"Не удалось заменить файл: {}\", e)))?;\n\n      log::info!(\"Метаданные добавлены к выходному файлу\");\n    } else {\n      log::warn!(\"Не удалось добавить метаданные, но файл создан\");\n    }\n\n    Ok(())\n  }\n\n  /// Сохранение статистики рендеринга\n  async fn save_statistics(\u0026self, context: \u0026PipelineContext) -\u003e Result\u003c()\u003e {\n    let stats_path = context.output_path.with_extension(\"stats.json\");\n\n    let stats_json = serde_json::json!({\n      \"project_name\": context.project.metadata.name,\n      \"output_file\": context.output_path.to_string_lossy(),\n      \"total_duration\": context.statistics.total_duration().as_secs(),\n      \"frames_processed\": context.statistics.frames_processed,\n      \"memory_used\": context.statistics.memory_used,\n      \"error_count\": context.statistics.error_count,\n      \"warning_count\": context.statistics.warning_count,\n      \"render_date\": chrono::Utc::now().to_rfc3339(),\n      \"timeline_studio_version\": context.project.version,\n    });\n\n    let stats_string = serde_json::to_string_pretty(\u0026stats_json).map_err(|e| {\n      VideoCompilerError::IoError(format!(\"Не удалось сериализовать статистику: {}\", e))\n    })?;\n\n    tokio::fs::write(\u0026stats_path, stats_string)\n      .await\n      .map_err(|e| {\n        VideoCompilerError::IoError(format!(\"Не удалось сохранить статистику: {}\", e))\n      })?;\n\n    log::info!(\"Статистика рендеринга сохранена в {:?}\", stats_path);\n    Ok(())\n  }\n}\n\n/// Статистика выполнения конвейера\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineStatistics {\n  /// Время начала валидации\n  pub validation_time: SystemTime,\n  /// Время начала предобработки\n  pub preprocessing_time: SystemTime,\n  /// Время начала композиции\n  pub composition_time: SystemTime,\n  /// Время начала кодирования\n  pub encoding_time: SystemTime,\n  /// Время финализации\n  pub finalization_time: SystemTime,\n  /// Количество обработанных кадров\n  pub frames_processed: u64,\n  /// Использованная память (байты)\n  pub memory_used: u64,\n  /// Количество ошибок\n  pub error_count: u32,\n  /// Количество предупреждений\n  pub warning_count: u32,\n}\n\nimpl Default for PipelineStatistics {\n  fn default() -\u003e Self {\n    let now = SystemTime::now();\n    Self {\n      validation_time: now,\n      preprocessing_time: now,\n      composition_time: now,\n      encoding_time: now,\n      finalization_time: now,\n      frames_processed: 0,\n      memory_used: 0,\n      error_count: 0,\n      warning_count: 0,\n    }\n  }\n}\n\nimpl PipelineStatistics {\n  /// Получить общее время выполнения\n  pub fn total_duration(\u0026self) -\u003e Duration {\n    if let Ok(duration) = self.finalization_time.duration_since(self.validation_time) {\n      duration\n    } else {\n      Duration::ZERO\n    }\n  }\n\n  /// Добавить ошибку\n  pub fn add_error(\u0026mut self) {\n    self.error_count += 1;\n  }\n\n  /// Добавить предупреждение\n  pub fn add_warning(\u0026mut self) {\n    self.warning_count += 1;\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::progress::ProgressUpdate;\n  use crate::video_compiler::schema::ProjectSchema;\n  use tokio::sync::mpsc;\n\n  async fn create_test_pipeline() -\u003e RenderPipeline {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    let (tx, _rx) = mpsc::unbounded_channel::\u003cProgressUpdate\u003e();\n    let progress_tracker = Arc::new(ProgressTracker::new(tx));\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let output_path = PathBuf::from(\"/tmp/test_output.mp4\");\n\n    RenderPipeline::new(project, progress_tracker, settings, output_path)\n      .await\n      .unwrap()\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_creation() {\n    let pipeline = create_test_pipeline().await;\n    assert_eq!(pipeline.stages.len(), 5); // 5 стандартных этапов\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_context() {\n    let project = ProjectSchema::new(\"Test\".to_string());\n    let output_path = PathBuf::from(\"/tmp/test.mp4\");\n    let mut context = PipelineContext::new(project, output_path);\n\n    // Тест добавления промежуточного файла\n    let temp_file = PathBuf::from(\"/tmp/temp.mp4\");\n    context.add_intermediate_file(\"temp\".to_string(), temp_file.clone());\n\n    assert_eq!(context.get_intermediate_file(\"temp\"), Some(\u0026temp_file));\n    assert_eq!(context.get_intermediate_file(\"nonexistent\"), None);\n  }\n\n  #[tokio::test]\n  async fn test_validation_stage() {\n    let stage = ValidationStage::new();\n    assert_eq!(stage.name(), \"Validation\");\n    assert!(!stage.can_skip(\u0026PipelineContext::new(\n      ProjectSchema::new(\"Test\".to_string()),\n      PathBuf::from(\"/tmp/test.mp4\")\n    )));\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_statistics() {\n    let mut stats = PipelineStatistics::default();\n\n    assert_eq!(stats.error_count, 0);\n    assert_eq!(stats.warning_count, 0);\n\n    stats.add_error();\n    stats.add_warning();\n\n    assert_eq!(stats.error_count, 1);\n    assert_eq!(stats.warning_count, 1);\n  }\n\n  #[tokio::test]\n  async fn test_stage_estimated_duration() {\n    let validation_stage = ValidationStage::new();\n    let preprocessing_stage = PreprocessingStage::new();\n    let composition_stage = CompositionStage::new();\n    let encoding_stage = EncodingStage::new();\n    let finalization_stage = FinalizationStage::new();\n\n    assert_eq!(\n      validation_stage.estimated_duration(),\n      Duration::from_secs(5)\n    );\n    assert_eq!(\n      preprocessing_stage.estimated_duration(),\n      Duration::from_secs(30)\n    );\n    assert_eq!(\n      composition_stage.estimated_duration(),\n      Duration::from_secs(120)\n    );\n    assert_eq!(\n      encoding_stage.estimated_duration(),\n      Duration::from_secs(300)\n    );\n    assert_eq!(\n      finalization_stage.estimated_duration(),\n      Duration::from_secs(5)\n    );\n  }\n\n  #[tokio::test]\n  async fn test_pipeline_cancel() {\n    let mut pipeline = create_test_pipeline().await;\n\n    let result = pipeline.cancel().await;\n    assert!(result.is_ok());\n    assert!(pipeline.context.is_cancelled());\n  }\n\n  #[tokio::test]\n  async fn test_context_temp_dir_creation() {\n    let project = ProjectSchema::new(\"Test\".to_string());\n    let output_path = PathBuf::from(\"/tmp/test.mp4\");\n    let context = PipelineContext::new(project, output_path);\n\n    // Проверяем, что временная директория содержит нужные компоненты\n    let temp_dir_str = context.temp_dir.to_string_lossy();\n    assert!(temp_dir_str.contains(\"timeline-studio\"));\n    assert!(temp_dir_str.contains(\"pipeline\"));\n  }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":3}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":238,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":244,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":294,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":5}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":4}},{"line":400,"address":[],"length":0,"stats":{"Line":4}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":424,"address":[],"length":0,"stats":{"Line":1}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":1}},{"line":510,"address":[],"length":0,"stats":{"Line":1}},{"line":512,"address":[],"length":0,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":1}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":1}},{"line":539,"address":[],"length":0,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":1}},{"line":542,"address":[],"length":0,"stats":{"Line":1}},{"line":544,"address":[],"length":0,"stats":{"Line":1}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":4}},{"line":566,"address":[],"length":0,"stats":{"Line":4}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":2}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":1}},{"line":594,"address":[],"length":0,"stats":{"Line":1}},{"line":597,"address":[],"length":0,"stats":{"Line":1}},{"line":598,"address":[],"length":0,"stats":{"Line":1}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":1}},{"line":608,"address":[],"length":0,"stats":{"Line":1}},{"line":609,"address":[],"length":0,"stats":{"Line":1}},{"line":611,"address":[],"length":0,"stats":{"Line":2}},{"line":614,"address":[],"length":0,"stats":{"Line":1}},{"line":615,"address":[],"length":0,"stats":{"Line":1}},{"line":616,"address":[],"length":0,"stats":{"Line":1}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":4}},{"line":818,"address":[],"length":0,"stats":{"Line":4}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":1}},{"line":847,"address":[],"length":0,"stats":{"Line":1}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":4}},{"line":1018,"address":[],"length":0,"stats":{"Line":4}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":1}},{"line":1072,"address":[],"length":0,"stats":{"Line":1}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":7}},{"line":1190,"address":[],"length":0,"stats":{"Line":7}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":1}},{"line":1217,"address":[],"length":0,"stats":{"Line":1}},{"line":1221,"address":[],"length":0,"stats":{"Line":1}},{"line":1222,"address":[],"length":0,"stats":{"Line":1}}],"covered":147,"coverable":458},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","preview","tests.rs"],"content":"//! Тесты для модуля генерации превью\n\nuse super::*;\nuse crate::video_compiler::cache::RenderCache;\nuse std::sync::Arc;\nuse std::time::SystemTime;\nuse tempfile::TempDir;\nuse tokio::sync::RwLock;\n\n// Создаем mock FFmpeg команду для тестов\nfn create_test_preview_generator() -\u003e PreviewGenerator {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    PreviewGenerator::new(cache)\n}\n\n#[test]\nfn test_preview_settings_default() {\n    let settings = PreviewSettings::default();\n    assert_eq!(settings.default_resolution, (640, 360));\n    assert_eq!(settings.default_quality, 75);\n    assert_eq!(settings.timeline_resolution, (160, 90));\n    assert_eq!(settings.timeline_quality, 60);\n    assert!(matches!(settings.format, PreviewFormat::Jpeg));\n    assert!(!settings.hardware_acceleration);\n    assert_eq!(settings.timeout_seconds, 30);\n    assert!(settings.supported_formats.contains(\u0026\"mp4\".to_string()));\n    assert!(settings.supported_formats.contains(\u0026\"mkv\".to_string()));\n}\n\n#[test]\nfn test_preview_settings_clone() {\n    let settings = PreviewSettings {\n        default_resolution: (1920, 1080),\n        default_quality: 90,\n        timeline_resolution: (320, 180),\n        timeline_quality: 70,\n        format: PreviewFormat::Png,\n        hardware_acceleration: true,\n        timeout_seconds: 60,\n        supported_formats: vec![\"mp4\".to_string(), \"avi\".to_string()],\n    };\n    \n    let cloned = settings.clone();\n    assert_eq!(cloned.default_resolution, settings.default_resolution);\n    assert_eq!(cloned.default_quality, settings.default_quality);\n    assert_eq!(cloned.hardware_acceleration, settings.hardware_acceleration);\n}\n\n#[test]\nfn test_preview_format_serialization() {\n    let formats = vec![\n        PreviewFormat::Jpeg,\n        PreviewFormat::Png,\n        PreviewFormat::WebP,\n    ];\n    \n    for format in formats {\n        let json = serde_json::to_string(\u0026format).unwrap();\n        let deserialized: PreviewFormat = serde_json::from_str(\u0026json).unwrap();\n        assert!(matches!(\n            (\u0026format, \u0026deserialized),\n            (PreviewFormat::Jpeg, PreviewFormat::Jpeg) |\n            (PreviewFormat::Png, PreviewFormat::Png) |\n            (PreviewFormat::WebP, PreviewFormat::WebP)\n        ));\n    }\n}\n\n#[test]\nfn test_video_info_serialization() {\n    let info = VideoInfo {\n        duration: 120.5,\n        resolution: Some((1920, 1080)),\n        fps: Some(30.0),\n        bitrate: Some(8000000),\n        video_codec: Some(\"h264\".to_string()),\n        audio_codec: Some(\"aac\".to_string()),\n    };\n    \n    let json = serde_json::to_string(\u0026info).unwrap();\n    assert!(json.contains(\"120.5\"));\n    assert!(json.contains(\"1920\"));\n    assert!(json.contains(\"h264\"));\n    \n    let deserialized: VideoInfo = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.duration, info.duration);\n    assert_eq!(deserialized.resolution, info.resolution);\n}\n\n#[test]\nfn test_preview_request_serialization() {\n    let request = PreviewRequest {\n        video_path: \"/test/video.mp4\".to_string(),\n        timestamp: 10.5,\n        resolution: Some((640, 360)),\n        quality: Some(80),\n    };\n    \n    let json = serde_json::to_string(\u0026request).unwrap();\n    assert!(json.contains(\"/test/video.mp4\"));\n    assert!(json.contains(\"10.5\"));\n    \n    let deserialized: PreviewRequest = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.video_path, request.video_path);\n    assert_eq!(deserialized.timestamp, request.timestamp);\n}\n\n#[test]\nfn test_preview_result_creation() {\n    let result = PreviewResult {\n        timestamp: 5.0,\n        result: Ok(vec![1, 2, 3, 4, 5]),\n    };\n    \n    assert_eq!(result.timestamp, 5.0);\n    assert!(result.result.is_ok());\n    assert_eq!(result.result.unwrap().len(), 5);\n}\n\n#[test]\nfn test_serializable_preview_result_serialization() {\n    let result = SerializablePreviewResult {\n        timestamp: 15.5,\n        image_data: Some(\"base64encodeddata\".to_string()),\n        error: None,\n    };\n    \n    let json = serde_json::to_string(\u0026result).unwrap();\n    assert!(json.contains(\"15.5\"));\n    assert!(json.contains(\"base64encodeddata\"));\n    \n    let deserialized: SerializablePreviewResult = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.timestamp, result.timestamp);\n    assert_eq!(deserialized.image_data, result.image_data);\n}\n\n#[test]\nfn test_timeline_preview_creation() {\n    let preview = TimelinePreview {\n        timestamp: 20.0,\n        image_data: Some(vec![10, 20, 30]),\n    };\n    \n    assert_eq!(preview.timestamp, 20.0);\n    assert!(preview.image_data.is_some());\n    assert_eq!(preview.image_data.unwrap().len(), 3);\n}\n\n#[tokio::test]\nasync fn test_preview_generator_creation() {\n    let generator = create_test_preview_generator();\n    assert_eq!(generator.ffmpeg_path, \"ffmpeg\");\n}\n\n#[tokio::test]\nasync fn test_preview_generator_with_settings() {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let settings = PreviewSettings {\n        default_resolution: (1280, 720),\n        default_quality: 85,\n        ..Default::default()\n    };\n    \n    let generator = PreviewGenerator::with_settings(cache, settings.clone());\n    assert_eq!(generator.settings.default_resolution, (1280, 720));\n    assert_eq!(generator.settings.default_quality, 85);\n}\n\n#[tokio::test]\nasync fn test_set_ffmpeg_path() {\n    let mut generator = create_test_preview_generator();\n    generator.set_ffmpeg_path(\"/usr/local/bin/ffmpeg\");\n    assert_eq!(generator.ffmpeg_path, \"/usr/local/bin/ffmpeg\");\n}\n\n#[tokio::test]\nasync fn test_quality_to_qscale() {\n    let generator = create_test_preview_generator();\n    assert_eq!(generator.quality_to_qscale(100), 2);\n    assert_eq!(generator.quality_to_qscale(0), 31);\n    assert_eq!(generator.quality_to_qscale(50), 16); // (100-50)*29/100 + 2 = 16.45 ≈ 16\n    \n    // Edge cases\n    assert_eq!(generator.quality_to_qscale(150), 2); // Above 100, clamped to 100\n}\n\n#[tokio::test]\nasync fn test_get_extension() {\n    let generator = create_test_preview_generator();\n    \n    match generator.settings.format {\n        PreviewFormat::Jpeg =\u003e assert_eq!(generator.get_file_extension(), \"jpg\"),\n        PreviewFormat::Png =\u003e assert_eq!(generator.get_file_extension(), \"png\"),\n        PreviewFormat::WebP =\u003e assert_eq!(generator.get_file_extension(), \"webp\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_create_temp_output_path() {\n    let generator = create_test_preview_generator();\n    let path = generator.create_temp_output_path().await.unwrap();\n    \n    // Проверяем что путь оканчивается на правильное расширение\n    assert!(path.ends_with(\".jpg\"));\n    \n    // Проверяем что файл пока не существует\n    assert!(!Path::new(\u0026path).exists());\n}\n\n#[tokio::test]\nasync fn test_validate_input_success() {\n    let generator = create_test_preview_generator();\n    let temp_dir = TempDir::new().unwrap();\n    let video_path = temp_dir.path().join(\"test_video.mp4\");\n    \n    // Создаем тестовый файл\n    std::fs::write(\u0026video_path, b\"dummy video data\").unwrap();\n    \n    // Должно пройти валидацию\n    let result = generator.validate_input(\u0026video_path, 10.0);\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_validate_input_file_not_found() {\n    let generator = create_test_preview_generator();\n    let video_path = Path::new(\"/nonexistent/video.mp4\");\n    \n    let result = generator.validate_input(video_path, 10.0);\n    assert!(result.is_err());\n    \n    if let Err(e) = result {\n        assert!(matches!(e, VideoCompilerError::MediaFileError { .. }));\n    }\n}\n\n#[tokio::test]\nasync fn test_validate_input_negative_timestamp() {\n    let generator = create_test_preview_generator();\n    let temp_dir = TempDir::new().unwrap();\n    let video_path = temp_dir.path().join(\"test_video.mp4\");\n    std::fs::write(\u0026video_path, b\"dummy video data\").unwrap();\n    \n    let result = generator.validate_input(\u0026video_path, -5.0);\n    assert!(result.is_err());\n    \n    if let Err(e) = result {\n        assert!(matches!(e, VideoCompilerError::ValidationError(_)));\n    }\n}\n\n#[tokio::test]\nasync fn test_validate_input_unsupported_format() {\n    let generator = create_test_preview_generator();\n    let temp_dir = TempDir::new().unwrap();\n    let video_path = temp_dir.path().join(\"test_file.xyz\");\n    std::fs::write(\u0026video_path, b\"dummy data\").unwrap();\n    \n    let result = generator.validate_input(\u0026video_path, 10.0);\n    assert!(result.is_err());\n    \n    if let Err(e) = result {\n        assert!(matches!(e, VideoCompilerError::UnsupportedFormat { .. }));\n    }\n}\n\n#[tokio::test]\nasync fn test_parse_video_info_valid() {\n    let generator = create_test_preview_generator();\n    let ffmpeg_output = r#\"\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'test.mp4':\n  Duration: 00:02:30.50, start: 0.000000, bitrate: 8000 kb/s\n    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1920x1080 [SAR 1:1 DAR 16:9], 7500 kb/s, 30 fps, 30 tbr, 15360 tbn, 60 tbc (default)\n    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 192 kb/s (default)\n    \"#;\n    \n    let info = generator.parse_video_info(ffmpeg_output).unwrap();\n    assert_eq!(info.duration, 150.5);\n    assert_eq!(info.resolution, Some((1920, 1080)));\n    assert_eq!(info.fps, Some(30.0));\n    assert_eq!(info.bitrate, Some(8000));\n    assert_eq!(info.video_codec, Some(\"h264\".to_string()));\n    assert_eq!(info.audio_codec, Some(\"aac\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_parse_video_info_minimal() {\n    let generator = create_test_preview_generator();\n    let ffmpeg_output = r#\"\nInput #0, matroska,webm, from 'test.mkv':\n  Duration: 00:01:00.00, start: 0.000000\n    \"#;\n    \n    let info = generator.parse_video_info(ffmpeg_output).unwrap();\n    assert_eq!(info.duration, 60.0);\n    assert_eq!(info.resolution, None);\n    assert_eq!(info.fps, None);\n    assert_eq!(info.bitrate, None);\n    assert_eq!(info.video_codec, None);\n    assert_eq!(info.audio_codec, None);\n}\n\n#[tokio::test]\nasync fn test_parse_video_info_no_duration() {\n    let generator = create_test_preview_generator();\n    let ffmpeg_output = \"Some invalid output without duration\";\n    \n    let result = generator.parse_video_info(ffmpeg_output);\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_clear_cache_for_file() {\n    let generator = create_test_preview_generator();\n    \n    // Добавляем что-то в кэш\n    {\n        let mut cache = generator.cache.write().await;\n        let key = PreviewKey::new(\"/test.mp4\".to_string(), 5.0, (640, 360), 75);\n        cache.store_preview(key.clone(), vec![1, 2, 3]).await.unwrap();\n        \n        // Проверяем что есть в кэше\n        assert!(cache.get_preview(\u0026key).await.is_some());\n    }\n    \n    // Очищаем кэш\n    generator.clear_cache_for_file().await.unwrap();\n    \n    // Проверяем что кэш пуст\n    {\n        let mut cache = generator.cache.write().await;\n        let key = PreviewKey::new(\"/test.mp4\".to_string(), 5.0, (640, 360), 75);\n        assert!(cache.get_preview(\u0026key).await.is_none());\n    }\n}\n\n#[test]\nfn test_preview_generator_debug() {\n    let generator = create_test_preview_generator();\n    let debug_str = format!(\"{:?}\", generator);\n    assert!(debug_str.contains(\"PreviewGenerator\"));\n}\n\n#[test]\nfn test_timeline_preview_serialization() {\n    let preview = TimelinePreview {\n        timestamp: 25.5,\n        image_data: Some(vec![5, 10, 15]),\n    };\n    \n    let json = serde_json::to_string(\u0026preview).unwrap();\n    assert!(json.contains(\"25.5\"));\n    \n    let deserialized: TimelinePreview = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.timestamp, preview.timestamp);\n    assert_eq!(deserialized.image_data, preview.image_data);\n}\n\n#[tokio::test]\nasync fn test_preview_batch_result_empty() {\n    let generator = create_test_preview_generator();\n    let results = generator.generate_preview_batch(vec![]).await.unwrap();\n    assert!(results.is_empty());\n}\n\n#[test]\nfn test_all_supported_formats() {\n    let settings = PreviewSettings::default();\n    let expected_formats = vec![\n        \"mp4\", \"mkv\", \"avi\", \"mov\", \"webm\", \"flv\", \"wmv\", \"mpg\", \"mpeg\", \n        \"m4v\", \"3gp\", \"ogv\", \"mxf\", \"ts\", \"vob\"\n    ];\n    \n    for format in expected_formats {\n        assert!(settings.supported_formats.contains(\u0026format.to_string()));\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","preview.rs"],"content":"//! Preview - Модуль генерации превью кадров\n//!\n//! Этот модуль реализует генерацию превью кадров из видео файлов с использованием FFmpeg,\n//! включая кэширование, оптимизацию производительности и поддержку различных форматов.\n\nuse crate::video_compiler::cache::{PreviewKey, RenderCache};\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::schema::PreviewFormat;\nuse base64::engine::general_purpose::STANDARD as BASE64;\nuse base64::Engine as _;\nuse serde::{Deserialize, Serialize};\nuse std::path::{Path, PathBuf};\nuse std::process::Stdio;\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::process::Command;\nuse tokio::sync::RwLock;\n\n/// Генератор превью кадров\n#[derive(Debug)]\npub struct PreviewGenerator {\n  /// Кэш превью\n  cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n  /// Настройки генератора\n  settings: PreviewSettings,\n  /// Путь к FFmpeg\n  ffmpeg_path: String,\n}\n\nimpl PreviewGenerator {\n  /// Создать новый генератор превью\n  pub fn new(cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e) -\u003e Self {\n    Self {\n      cache,\n      settings: PreviewSettings::default(),\n      ffmpeg_path: \"ffmpeg\".to_string(),\n    }\n  }\n\n  /// Создать генератор с настройками\n  pub fn with_settings(cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e, settings: PreviewSettings) -\u003e Self {\n    Self {\n      cache,\n      settings,\n      ffmpeg_path: \"ffmpeg\".to_string(),\n    }\n  }\n\n  /// Установить путь к FFmpeg\n  pub fn set_ffmpeg_path\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, path: P) {\n    self.ffmpeg_path = path.as_ref().to_string_lossy().to_string();\n  }\n\n  /// Сгенерировать превью кадр\n  pub async fn generate_preview(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamp: f64,\n    resolution: Option\u003c(u32, u32)\u003e,\n    quality: Option\u003cu8\u003e,\n  ) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let resolution = resolution.unwrap_or(self.settings.default_resolution);\n    let quality = quality.unwrap_or(self.settings.default_quality);\n\n    // Создаем ключ кэша\n    let cache_key = PreviewKey::new(\n      video_path.to_string_lossy().to_string(),\n      timestamp,\n      resolution,\n      quality,\n    );\n\n    // Проверяем кэш\n    {\n      let mut cache = self.cache.write().await;\n      if let Some(cached_data) = cache.get_preview(\u0026cache_key).await {\n        log::debug!(\"Превью найдено в кэше: {:?} at {}s\", video_path, timestamp);\n        return Ok(cached_data.image_data);\n      }\n    }\n\n    log::debug!(\"Генерация превью: {:?} at {}s\", video_path, timestamp);\n\n    // Валидация входных данных\n    self.validate_input(video_path, timestamp)?;\n\n    // Генерируем превью\n    let image_data = self\n      .generate_preview_internal(video_path, timestamp, resolution, quality)\n      .await?;\n\n    // Сохраняем в кэш\n    {\n      let mut cache = self.cache.write().await;\n      cache.store_preview(cache_key, image_data.clone()).await?;\n    }\n\n    Ok(image_data)\n  }\n\n  /// Генерировать несколько превью одновременно для одного файла\n  pub async fn generate_preview_batch_for_file(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamps: Vec\u003cf64\u003e,\n    resolution: Option\u003c(u32, u32)\u003e,\n    quality: Option\u003cu8\u003e,\n  ) -\u003e Result\u003cVec\u003cPreviewResult\u003e\u003e {\n    let resolution = resolution.unwrap_or(self.settings.default_resolution);\n    let quality = quality.unwrap_or(self.settings.default_quality);\n\n    let mut results = Vec::new();\n    let mut tasks = Vec::new();\n\n    // Создаем задачи для параллельной генерации\n    for timestamp in timestamps {\n      let video_path = video_path.to_owned();\n      let cache = self.cache.clone();\n      let settings = self.settings.clone();\n      let ffmpeg_path = self.ffmpeg_path.clone();\n\n      let task = tokio::spawn(async move {\n        let generator = PreviewGenerator {\n          cache,\n          settings,\n          ffmpeg_path,\n        };\n\n        let result = generator\n          .generate_preview(\u0026video_path, timestamp, Some(resolution), Some(quality))\n          .await;\n        PreviewResult { timestamp, result }\n      });\n\n      tasks.push(task);\n    }\n\n    // Ждем завершения всех задач\n    for task in tasks {\n      match task.await {\n        Ok(result) =\u003e results.push(result),\n        Err(e) =\u003e {\n          log::error!(\"Ошибка в задаче генерации превью: {:?}\", e);\n        }\n      }\n    }\n\n    Ok(results)\n  }\n\n  /// Генерировать несколько превью для разных файлов\n  pub async fn generate_preview_batch(\n    \u0026self,\n    requests: Vec\u003cPreviewRequest\u003e,\n  ) -\u003e Result\u003cVec\u003cSerializablePreviewResult\u003e\u003e {\n    let mut results = Vec::new();\n    let mut tasks = Vec::new();\n\n    // Создаем задачи для параллельной генерации\n    for request in requests {\n      let cache = self.cache.clone();\n      let settings = self.settings.clone();\n      let ffmpeg_path = self.ffmpeg_path.clone();\n\n      let task = tokio::spawn(async move {\n        let generator = PreviewGenerator {\n          cache,\n          settings,\n          ffmpeg_path,\n        };\n\n        let path = Path::new(\u0026request.video_path);\n        let result = generator\n          .generate_preview(path, request.timestamp, request.resolution, request.quality)\n          .await;\n\n        match result {\n          Ok(image_data) =\u003e SerializablePreviewResult {\n            timestamp: request.timestamp,\n            image_data: Some(BASE64.encode(\u0026image_data)),\n            error: None,\n          },\n          Err(e) =\u003e SerializablePreviewResult {\n            timestamp: request.timestamp,\n            image_data: None,\n            error: Some(e.to_string()),\n          },\n        }\n      });\n\n      tasks.push(task);\n    }\n\n    // Ждем завершения всех задач\n    for task in tasks {\n      match task.await {\n        Ok(result) =\u003e results.push(result),\n        Err(e) =\u003e {\n          log::error!(\"Ошибка в задаче генерации превью: {:?}\", e);\n        }\n      }\n    }\n\n    Ok(results)\n  }\n\n  /// Генерировать превью для timeline (полоса превью)\n  pub async fn generate_timeline_previews(\n    \u0026self,\n    video_path: \u0026Path,\n    duration: f64,\n    interval: f64,\n  ) -\u003e Result\u003cVec\u003cTimelinePreview\u003e\u003e {\n    let mut previews = Vec::new();\n    let mut current_time = 0.0;\n\n    while current_time \u003c duration {\n      let result = self\n        .generate_preview(\n          video_path,\n          current_time,\n          Some(self.settings.timeline_resolution),\n          Some(self.settings.timeline_quality),\n        )\n        .await;\n\n      let preview = TimelinePreview {\n        timestamp: current_time,\n        image_data: result.ok(),\n      };\n\n      previews.push(preview);\n      current_time += interval;\n    }\n\n    Ok(previews)\n  }\n\n  /// Очистить кэш превью для конкретного файла\n  pub async fn clear_cache_for_file(\u0026self) -\u003e Result\u003c()\u003e {\n    let mut cache = self.cache.write().await;\n    cache.clear_previews().await;\n    Ok(())\n  }\n\n  /// Получить информацию о видео файле\n  pub async fn get_video_info(\u0026self, video_path: \u0026Path) -\u003e Result\u003cVideoInfo\u003e {\n    let mut cmd = Command::new(\u0026self.ffmpeg_path);\n    cmd.args([\n      \"-i\",\n      \u0026video_path.to_string_lossy(),\n      \"-hide_banner\",\n      \"-f\",\n      \"null\",\n      \"-\",\n    ]);\n    cmd.stdout(Stdio::null());\n    cmd.stderr(Stdio::piped());\n\n    let output = cmd.output().await.map_err(|e| {\n      VideoCompilerError::ffmpeg(\n        None,\n        format!(\"Не удалось запустить FFmpeg: {}\", e),\n        \"ffprobe\".to_string(),\n      )\n    })?;\n\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n    self.parse_video_info(\u0026stderr)\n  }\n\n  /// Внутренняя генерация превью\n  async fn generate_preview_internal(\n    \u0026self,\n    video_path: \u0026Path,\n    timestamp: f64,\n    resolution: (u32, u32),\n    quality: u8,\n  ) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let temp_output = self.create_temp_output_path().await?;\n\n    let mut cmd = Command::new(\u0026self.ffmpeg_path);\n\n    // Настройка команды FFmpeg\n    cmd.args([\n      \"-ss\",\n      \u0026timestamp.to_string(),\n      \"-i\",\n      \u0026video_path.to_string_lossy(),\n      \"-vframes\",\n      \"1\",\n      \"-vf\",\n      \u0026format!(\"scale={}:{}\", resolution.0, resolution.1),\n      \"-q:v\",\n      \u0026self.quality_to_qscale(quality).to_string(),\n      \"-y\",\n    ]);\n\n    // Выбираем формат вывода\n    match self.settings.format {\n      PreviewFormat::Jpeg =\u003e {\n        cmd.args([\"-f\", \"image2\", \"-c:v\", \"mjpeg\"]);\n      }\n      PreviewFormat::Png =\u003e {\n        cmd.args([\"-f\", \"image2\", \"-c:v\", \"png\"]);\n      }\n      PreviewFormat::WebP =\u003e {\n        cmd.args([\"-f\", \"image2\", \"-c:v\", \"libwebp\"]);\n      }\n    }\n\n    cmd.arg(\u0026temp_output);\n    cmd.stdout(Stdio::null());\n    cmd.stderr(Stdio::piped());\n\n    log::debug!(\"Выполнение команды FFmpeg: {:?}\", cmd);\n\n    let output = cmd.output().await.map_err(|e| {\n      let error = VideoCompilerError::ffmpeg(\n        None,\n        format!(\"Не удалось запустить FFmpeg: {}\", e),\n        \"generate_preview\".to_string(),\n      );\n      log::error!(\"Ошибка FFmpeg: {}\", error);\n      log::error!(\"  Код ошибки: {}\", error.error_code());\n      log::error!(\n        \"  Критическая: {}\",\n        if error.is_critical() {\n          \"да\"\n        } else {\n          \"нет\"\n        }\n      );\n      error\n    })?;\n\n    if !output.status.success() {\n      let stderr = String::from_utf8_lossy(\u0026output.stderr);\n      let error = VideoCompilerError::ffmpeg(\n        output.status.code(),\n        stderr.to_string(),\n        format!(\"ffmpeg generate preview at {}s\", timestamp),\n      );\n      log::error!(\"Ошибка выполнения FFmpeg: {}\", error);\n      log::error!(\"  Код ошибки: {}\", error.error_code());\n      log::error!(\n        \"  Можно повторить: {}\",\n        if error.is_retryable() {\n          \"да\"\n        } else {\n          \"нет\"\n        }\n      );\n      return Err(error);\n    }\n\n    // Читаем сгенерированный файл\n    let image_data = tokio::fs::read(\u0026temp_output).await.map_err(|e| {\n      VideoCompilerError::preview(\n        timestamp,\n        format!(\"Не удалось прочитать превью файл: {}\", e),\n      )\n    })?;\n\n    // Удаляем временный файл\n    if let Err(e) = tokio::fs::remove_file(\u0026temp_output).await {\n      log::warn!(\"Не удалось удалить временный файл превью: {}\", e);\n    }\n    log::debug!(\n      \"Превью успешно сгенерировано: {:?} at {}s\",\n      video_path,\n      timestamp\n    );\n    Ok(image_data)\n  }\n\n  /// Валидация входных данных\n  fn validate_input(\u0026self, video_path: \u0026Path, timestamp: f64) -\u003e Result\u003c()\u003e {\n    if !video_path.exists() {\n      return Err(VideoCompilerError::media_file(\n        video_path.to_string_lossy(),\n        \"Файл не найден\",\n      ));\n    }\n\n    if timestamp \u003c 0.0 {\n      return Err(VideoCompilerError::validation(\n        \"Временная метка не может быть отрицательной\",\n      ));\n    }\n\n    // Проверка расширения файла\n    if let Some(extension) = video_path.extension() {\n      let ext = extension.to_string_lossy().to_lowercase();\n      if !self.settings.supported_formats.contains(\u0026ext) {\n        return Err(VideoCompilerError::unsupported_format(\n          ext,\n          video_path.to_string_lossy(),\n        ));\n      }\n    }\n\n    Ok(())\n  }\n\n  /// Создать путь для временного файла\n  async fn create_temp_output_path(\u0026self) -\u003e Result\u003cPathBuf\u003e {\n    let temp_dir = std::env::temp_dir();\n    let filename = format!(\n      \"timeline_preview_{}_{}.{}\",\n      SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap_or(Duration::ZERO)\n        .as_millis(),\n      uuid::Uuid::new_v4(),\n      self.get_file_extension()\n    );\n\n    Ok(temp_dir.join(filename))\n  }\n\n  /// Получить расширение файла для текущего формата\n  fn get_file_extension(\u0026self) -\u003e \u0026'static str {\n    match self.settings.format {\n      PreviewFormat::Jpeg =\u003e \"jpg\",\n      PreviewFormat::Png =\u003e \"png\",\n      PreviewFormat::WebP =\u003e \"webp\",\n    }\n  }\n\n  /// Конвертировать качество (0-100) в qscale для FFmpeg (2-31)\n  fn quality_to_qscale(\u0026self, quality: u8) -\u003e u8 {\n    // Инвертируем шкалу: высокое качество = низкий qscale\n    let quality = quality.min(100) as u32;\n    let qscale = 2 + ((100 - quality) * 29 / 100);\n    qscale.min(31) as u8\n  }\n\n  /// Парсинг информации о видео из вывода FFmpeg\n  fn parse_video_info(\u0026self, ffmpeg_output: \u0026str) -\u003e Result\u003cVideoInfo\u003e {\n    let mut info = VideoInfo::default();\n\n    for line in ffmpeg_output.lines() {\n      // Парсим длительность: Duration: 00:02:30.45\n      if line.contains(\"Duration:\") {\n        if let Some(duration_str) = line.split(\"Duration: \").nth(1) {\n          if let Some(duration_part) = duration_str.split(',').next() {\n            info.duration = parse_duration(duration_part);\n          }\n        }\n      }\n\n      // Парсим видео стрим: Stream #0:0: Video: h264 (avc1), yuv420p, 1920x1080, 30 fps\n      if line.contains(\"Video:\") \u0026\u0026 line.contains(\"Stream\") {\n        // Парсим разрешение\n        if let Some(resolution) = extract_resolution(line) {\n          info.resolution = Some(resolution);\n        }\n\n        // Парсим FPS\n        if let Some(fps) = extract_fps(line) {\n          info.fps = Some(fps);\n        }\n\n        // Парсим кодек\n        if let Some(codec) = extract_video_codec(line) {\n          info.video_codec = Some(codec);\n        }\n      }\n\n      // Парсим аудио стрим\n      if line.contains(\"Audio:\") \u0026\u0026 line.contains(\"Stream\") {\n        if let Some(codec) = extract_audio_codec(line) {\n          info.audio_codec = Some(codec);\n        }\n      }\n\n      // Парсим битрейт\n      if line.contains(\"bitrate:\") {\n        if let Some(bitrate) = extract_bitrate(line) {\n          info.bitrate = Some(bitrate);\n        }\n      }\n    }\n\n    Ok(info)\n  }\n}\n\n/// Настройки генератора превью\n#[derive(Debug, Clone)]\npub struct PreviewSettings {\n  /// Разрешение по умолчанию\n  pub default_resolution: (u32, u32),\n  /// Качество по умолчанию (0-100)\n  pub default_quality: u8,\n  /// Формат превью\n  pub format: PreviewFormat,\n  /// Разрешение для timeline превью\n  pub timeline_resolution: (u32, u32),\n  /// Качество для timeline превью\n  pub timeline_quality: u8,\n  /// Поддерживаемые форматы видео\n  pub supported_formats: Vec\u003cString\u003e,\n  /// Максимальное время ожидания (секунды)\n  pub timeout_seconds: u64,\n  /// Использовать аппаратное ускорение\n  pub hardware_acceleration: bool,\n}\n\nimpl Default for PreviewSettings {\n  fn default() -\u003e Self {\n    Self {\n      default_resolution: (640, 360),\n      default_quality: 75,\n      format: PreviewFormat::Jpeg,\n      timeline_resolution: (160, 90),\n      timeline_quality: 60,\n      supported_formats: vec![\n        \"mp4\".to_string(),\n        \"avi\".to_string(),\n        \"mov\".to_string(),\n        \"mkv\".to_string(),\n        \"webm\".to_string(),\n        \"flv\".to_string(),\n        \"wmv\".to_string(),\n        \"m4v\".to_string(),\n      ],\n      timeout_seconds: 30,\n      hardware_acceleration: false,\n    }\n  }\n}\n\n/// Запрос на генерацию превью\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PreviewRequest {\n  /// Путь к видео файлу\n  pub video_path: String,\n  /// Временная метка\n  pub timestamp: f64,\n  /// Разрешение (опционально)\n  pub resolution: Option\u003c(u32, u32)\u003e,\n  /// Качество (опционально)\n  pub quality: Option\u003cu8\u003e,\n}\n\n/// Результат генерации превью\n#[derive(Debug, Clone)]\npub struct PreviewResult {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Результат генерации\n  pub result: Result\u003cVec\u003cu8\u003e\u003e,\n}\n\n/// Результат генерации превью для сериализации\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SerializablePreviewResult {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные изображения (base64)\n  pub image_data: Option\u003cString\u003e,\n  /// Ошибка если была\n  pub error: Option\u003cString\u003e,\n}\n\n/// Превью для timeline\n#[derive(Debug, Clone)]\npub struct TimelinePreview {\n  /// Временная метка\n  pub timestamp: f64,\n  /// Данные изображения (None если ошибка)\n  pub image_data: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\n/// Информация о видео файле\n#[derive(Debug, Default, Clone, Serialize, Deserialize)]\npub struct VideoInfo {\n  /// Длительность в секундах\n  pub duration: f64,\n  /// Разрешение видео\n  pub resolution: Option\u003c(u32, u32)\u003e,\n  /// FPS\n  pub fps: Option\u003cf32\u003e,\n  /// Битрейт (bps)\n  pub bitrate: Option\u003cu32\u003e,\n  /// Видео кодек\n  pub video_codec: Option\u003cString\u003e,\n  /// Аудио кодек\n  pub audio_codec: Option\u003cString\u003e,\n}\n\n/// Парсинг длительности из строки формата HH:MM:SS.ss\nfn parse_duration(duration_str: \u0026str) -\u003e f64 {\n  let parts: Vec\u003c\u0026str\u003e = duration_str.trim().split(':').collect();\n  if parts.len() == 3 {\n    let hours: f64 = parts[0].parse().unwrap_or(0.0);\n    let minutes: f64 = parts[1].parse().unwrap_or(0.0);\n    let seconds: f64 = parts[2].parse().unwrap_or(0.0);\n    hours * 3600.0 + minutes * 60.0 + seconds\n  } else {\n    0.0\n  }\n}\n\n/// Извлечение разрешения из строки FFmpeg\nfn extract_resolution(line: \u0026str) -\u003e Option\u003c(u32, u32)\u003e {\n  // Ищем паттерн вида \"1920x1080\"\n  let re = regex::Regex::new(r\"(\\d+)x(\\d+)\").ok()?;\n  let caps = re.captures(line)?;\n  let width: u32 = caps.get(1)?.as_str().parse().ok()?;\n  let height: u32 = caps.get(2)?.as_str().parse().ok()?;\n  Some((width, height))\n}\n\n/// Извлечение FPS из строки FFmpeg\nfn extract_fps(line: \u0026str) -\u003e Option\u003cf32\u003e {\n  // Ищем паттерн вида \"30 fps\" или \"29.97 fps\"\n  let re = regex::Regex::new(r\"(\\d+(?:\\.\\d+)?)\\s*fps\").ok()?;\n  let caps = re.captures(line)?;\n  caps.get(1)?.as_str().parse().ok()\n}\n\n/// Извлечение видео кодека\nfn extract_video_codec(line: \u0026str) -\u003e Option\u003cString\u003e {\n  // Ищем кодек после \"Video:\"\n  if let Some(start) = line.find(\"Video: \") {\n    let codec_part = \u0026line[start + 7..];\n    // Находим конец кодека - либо пробел, либо запятая\n    let end = codec_part.find([' ', ',']).unwrap_or(codec_part.len());\n    Some(codec_part[..end].to_string())\n  } else {\n    None\n  }\n}\n\n/// Извлечение аудио кодека\nfn extract_audio_codec(line: \u0026str) -\u003e Option\u003cString\u003e {\n  // Ищем кодек после \"Audio:\"\n  if let Some(start) = line.find(\"Audio: \") {\n    let codec_part = \u0026line[start + 7..];\n    // Находим конец кодека - либо пробел, либо запятая\n    let end = codec_part.find([' ', ',']).unwrap_or(codec_part.len());\n    Some(codec_part[..end].to_string())\n  } else {\n    None\n  }\n}\n\n/// Извлечение битрейта\nfn extract_bitrate(line: \u0026str) -\u003e Option\u003cu32\u003e {\n  // Ищем паттерн вида \"bitrate: 1234 kb/s\"\n  let re = regex::Regex::new(r\"bitrate:\\s*(\\d+)\\s*kb/s\").ok()?;\n  let caps = re.captures(line)?;\n  let bitrate_kbps: u32 = caps.get(1)?.as_str().parse().ok()?;\n  Some(bitrate_kbps * 1000) // Конвертируем в bps\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::cache::RenderCache;\n  use std::path::PathBuf;\n  use tokio::sync::RwLock;\n\n  fn create_test_generator() -\u003e PreviewGenerator {\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    PreviewGenerator::new(cache)\n  }\n\n  #[test]\n  fn test_preview_settings_default() {\n    let settings = PreviewSettings::default();\n    assert_eq!(settings.default_resolution, (640, 360));\n    assert_eq!(settings.default_quality, 75);\n    assert!(settings.supported_formats.contains(\u0026\"mp4\".to_string()));\n  }\n\n  #[test]\n  fn test_quality_to_qscale() {\n    let generator = create_test_generator();\n\n    // Высокое качество = низкий qscale\n    assert_eq!(generator.quality_to_qscale(100), 2);\n    assert_eq!(generator.quality_to_qscale(0), 31);\n    assert_eq!(generator.quality_to_qscale(50), 16); // Примерно средний\n  }\n\n  #[test]\n  fn test_file_extension() {\n    let mut settings = PreviewSettings::default();\n\n    settings.format = PreviewFormat::Jpeg;\n    let generator =\n      PreviewGenerator::with_settings(Arc::new(RwLock::new(RenderCache::new())), settings.clone());\n    assert_eq!(generator.get_file_extension(), \"jpg\");\n\n    settings.format = PreviewFormat::Png;\n    let generator =\n      PreviewGenerator::with_settings(Arc::new(RwLock::new(RenderCache::new())), settings.clone());\n    assert_eq!(generator.get_file_extension(), \"png\");\n\n    settings.format = PreviewFormat::WebP;\n    let generator =\n      PreviewGenerator::with_settings(Arc::new(RwLock::new(RenderCache::new())), settings);\n    assert_eq!(generator.get_file_extension(), \"webp\");\n  }\n\n  #[test]\n  fn test_parse_duration() {\n    assert_eq!(parse_duration(\"01:23:45.67\"), 3600.0 + 23.0 * 60.0 + 45.67);\n    assert_eq!(parse_duration(\"00:00:30.50\"), 30.5);\n    assert_eq!(parse_duration(\"02:00:00.00\"), 7200.0);\n    assert_eq!(parse_duration(\"invalid\"), 0.0);\n  }\n\n  #[test]\n  fn test_extract_resolution() {\n    let line = \"Stream #0:0: Video: h264, yuv420p, 1920x1080, 30 fps\";\n    assert_eq!(extract_resolution(line), Some((1920, 1080)));\n\n    let line = \"Stream #0:0: Video: h264, yuv420p, 640x480, 25 fps\";\n    assert_eq!(extract_resolution(line), Some((640, 480)));\n\n    let line = \"No resolution here\";\n    assert_eq!(extract_resolution(line), None);\n  }\n\n  #[test]\n  fn test_extract_fps() {\n    let line = \"Stream #0:0: Video: h264, yuv420p, 1920x1080, 30 fps\";\n    assert_eq!(extract_fps(line), Some(30.0));\n\n    let line = \"Stream #0:0: Video: h264, yuv420p, 1920x1080, 29.97 fps\";\n    assert_eq!(extract_fps(line), Some(29.97));\n\n    let line = \"No fps here\";\n    assert_eq!(extract_fps(line), None);\n  }\n\n  #[test]\n  fn test_extract_video_codec() {\n    let line = \"Stream #0:0: Video: h264 (avc1), yuv420p, 1920x1080\";\n    assert_eq!(extract_video_codec(line), Some(\"h264\".to_string()));\n\n    let line = \"Stream #0:0: Video: vp9, yuv420p, 1920x1080\";\n    assert_eq!(extract_video_codec(line), Some(\"vp9\".to_string()));\n\n    let line = \"No video codec here\";\n    assert_eq!(extract_video_codec(line), None);\n  }\n\n  #[test]\n  fn test_extract_audio_codec() {\n    let line = \"Stream #0:1: Audio: aac (mp4a), 48000 Hz, stereo\";\n    assert_eq!(extract_audio_codec(line), Some(\"aac\".to_string()));\n\n    let line = \"Stream #0:1: Audio: mp3, 44100 Hz, stereo\";\n    assert_eq!(extract_audio_codec(line), Some(\"mp3\".to_string()));\n\n    let line = \"No audio codec here\";\n    assert_eq!(extract_audio_codec(line), None);\n  }\n\n  #[test]\n  fn test_extract_bitrate() {\n    let line = \"Duration: 00:02:30.45, start: 0.000000, bitrate: 8000 kb/s\";\n    assert_eq!(extract_bitrate(line), Some(8000000)); // 8000 kbps = 8000000 bps\n\n    let line = \"bitrate: 1500 kb/s\";\n    assert_eq!(extract_bitrate(line), Some(1500000));\n\n    let line = \"No bitrate here\";\n    assert_eq!(extract_bitrate(line), None);\n  }\n\n  #[tokio::test]\n  async fn test_video_info_parsing() {\n    let generator = create_test_generator();\n    let ffmpeg_output = r#\"\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'test.mp4':\n  Duration: 00:02:30.45, start: 0.000000, bitrate: 8000 kb/s\n    Stream #0:0(und): Video: h264 (avc1), yuv420p, 1920x1080, 7500 kb/s, 30 fps\n    Stream #0:1(und): Audio: aac (mp4a), 48000 Hz, stereo, fltp, 128 kb/s\n\"#;\n\n    let info = generator.parse_video_info(ffmpeg_output).unwrap();\n    assert_eq!(info.duration, 150.45); // 2:30.45 = 150.45 seconds\n    assert_eq!(info.resolution, Some((1920, 1080)));\n    assert_eq!(info.fps, Some(30.0));\n    assert_eq!(info.video_codec, Some(\"h264\".to_string()));\n    assert_eq!(info.audio_codec, Some(\"aac\".to_string()));\n    assert_eq!(info.bitrate, Some(8000000));\n  }\n\n  #[tokio::test]\n  async fn test_preview_key_creation() {\n    let key = PreviewKey::new(\"/test/video.mp4\".to_string(), 10.5, (640, 360), 75);\n\n    assert_eq!(key.file_path, \"/test/video.mp4\");\n    assert_eq!(key.timestamp, 10500); // 10.5 * 1000\n    assert_eq!(key.resolution, (640, 360));\n    assert_eq!(key.quality, 75);\n  }\n\n  #[tokio::test]\n  async fn test_temp_output_path() {\n    let generator = create_test_generator();\n    let path = generator.create_temp_output_path().await.unwrap();\n\n    assert!(path.to_string_lossy().contains(\"timeline_preview_\"));\n    assert!(path.to_string_lossy().ends_with(\".jpg\")); // default format\n  }\n\n  #[test]\n  fn test_input_validation() {\n    let generator = create_test_generator();\n\n    // Негативная временная метка\n    let result = generator.validate_input(\u0026PathBuf::from(\"/nonexistent\"), -1.0);\n    assert!(result.is_err());\n\n    // Несуществующий файл\n    let result = generator.validate_input(\u0026PathBuf::from(\"/nonexistent/file.mp4\"), 10.0);\n    assert!(result.is_err());\n  }\n\n  #[tokio::test]\n  async fn test_timeline_preview_generation() {\n    let generator = create_test_generator();\n\n    // Создаем мок видео файл (в реальности нужен настоящий файл)\n    let video_path = PathBuf::from(\"/nonexistent/test.mp4\");\n\n    // Этот тест не пройдет без реального видео файла, но структура правильная\n    let _result = generator\n      .generate_timeline_previews(\u0026video_path, 60.0, 10.0)\n      .await;\n\n    // В реальном тесте здесь были бы проверки на количество превью\n    // assert_eq!(result.unwrap().len(), 6); // 60 секунд / 10 секунд интервал\n  }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":7}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":6}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":6}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":8}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":8}},{"line":381,"address":[],"length":0,"stats":{"Line":8}},{"line":382,"address":[],"length":0,"stats":{"Line":8}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":424,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":3}},{"line":434,"address":[],"length":0,"stats":{"Line":3}},{"line":435,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[],"length":0,"stats":{"Line":3}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":466,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":1}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":480,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":1}},{"line":512,"address":[],"length":0,"stats":{"Line":12}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":517,"address":[],"length":0,"stats":{"Line":12}},{"line":519,"address":[],"length":0,"stats":{"Line":12}},{"line":595,"address":[],"length":0,"stats":{"Line":5}},{"line":596,"address":[],"length":0,"stats":{"Line":5}},{"line":597,"address":[],"length":0,"stats":{"Line":5}},{"line":598,"address":[],"length":0,"stats":{"Line":4}},{"line":599,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":4}},{"line":601,"address":[],"length":0,"stats":{"Line":4}},{"line":603,"address":[],"length":0,"stats":{"Line":1}},{"line":608,"address":[],"length":0,"stats":{"Line":4}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":611,"address":[],"length":0,"stats":{"Line":4}},{"line":612,"address":[],"length":0,"stats":{"Line":6}},{"line":613,"address":[],"length":0,"stats":{"Line":6}},{"line":618,"address":[],"length":0,"stats":{"Line":4}},{"line":620,"address":[],"length":0,"stats":{"Line":8}},{"line":621,"address":[],"length":0,"stats":{"Line":4}},{"line":622,"address":[],"length":0,"stats":{"Line":3}},{"line":626,"address":[],"length":0,"stats":{"Line":4}},{"line":628,"address":[],"length":0,"stats":{"Line":7}},{"line":634,"address":[],"length":0,"stats":{"Line":1}},{"line":639,"address":[],"length":0,"stats":{"Line":4}},{"line":641,"address":[],"length":0,"stats":{"Line":7}},{"line":647,"address":[],"length":0,"stats":{"Line":1}},{"line":652,"address":[],"length":0,"stats":{"Line":4}},{"line":654,"address":[],"length":0,"stats":{"Line":8}},{"line":655,"address":[],"length":0,"stats":{"Line":4}},{"line":656,"address":[],"length":0,"stats":{"Line":6}}],"covered":95,"coverable":233},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","progress.rs"],"content":"//! Progress - Модуль отслеживания прогресса рендеринга\n//!\n//! Этот модуль реализует систему отслеживания прогресса рендеринга видео,\n//! включая парсинг вывода FFmpeg, расчет прогресса и уведомления через WebSocket.\n\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::sync::{mpsc, RwLock};\nuse uuid::Uuid;\n\n/// Основной трекер прогресса рендеринга\n#[derive(Debug)]\npub struct ProgressTracker {\n  /// Активные задачи рендеринга\n  active_jobs: Arc\u003cRwLock\u003cHashMap\u003cString, RenderJob\u003e\u003e\u003e,\n  /// Канал для отправки обновлений прогресса\n  progress_sender: mpsc::UnboundedSender\u003cProgressUpdate\u003e,\n  /// Настройки трекера\n  settings: ProgressSettings,\n}\n\nimpl ProgressTracker {\n  /// Создать новый трекер прогресса\n  pub fn new(progress_sender: mpsc::UnboundedSender\u003cProgressUpdate\u003e) -\u003e Self {\n    Self {\n      active_jobs: Arc::new(RwLock::new(HashMap::new())),\n      progress_sender,\n      settings: ProgressSettings::default(),\n    }\n  }\n\n  /// Создать новую задачу рендеринга\n  pub async fn create_job(\n    \u0026self,\n    project_name: String,\n    output_path: String,\n    total_frames: u64,\n  ) -\u003e Result\u003cString\u003e {\n    let job_id = Uuid::new_v4().to_string();\n    let job = RenderJob::new(job_id.clone(), project_name, output_path, total_frames);\n\n    let mut jobs = self.active_jobs.write().await;\n    jobs.insert(job_id.clone(), job);\n\n    // Отправляем уведомление о начале\n    let update = ProgressUpdate::JobStarted {\n      job_id: job_id.clone(),\n    };\n    let _ = self.progress_sender.send(update);\n\n    log::info!(\"Создана новая задача рендеринга: {}\", job_id);\n    Ok(job_id)\n  }\n\n  /// Обновить прогресс задачи\n  pub async fn update_progress(\n    \u0026self,\n    job_id: \u0026str,\n    current_frame: u64,\n    stage: String,\n    message: Option\u003cString\u003e,\n  ) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(job) = jobs.get_mut(job_id) {\n      job.update_progress(current_frame, stage, message)?;\n\n      // Отправляем обновление прогресса\n      let update = ProgressUpdate::ProgressChanged {\n        job_id: job_id.to_string(),\n        progress: job.get_progress(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::debug!(\n        \"Обновлен прогресс задачи {}: {:.1}%\",\n        job_id,\n        job.get_progress().percentage\n      );\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"update_progress\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Завершить задачу успешно\n  pub async fn complete_job(\u0026self, job_id: \u0026str, output_path: String) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(mut job) = jobs.remove(job_id) {\n      job.complete(output_path.clone())?;\n\n      // Отправляем уведомление о завершении\n      let update = ProgressUpdate::JobCompleted {\n        job_id: job_id.to_string(),\n        output_path,\n        duration: job.get_elapsed_time(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::info!(\n        \"Задача {} завершена успешно за {:?}\",\n        job_id,\n        job.get_elapsed_time()\n      );\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"complete_job\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Завершить задачу с ошибкой\n  pub async fn fail_job(\u0026self, job_id: \u0026str, error: String) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(mut job) = jobs.remove(job_id) {\n      job.fail(error.clone())?;\n\n      // Отправляем уведомление об ошибке\n      let update = ProgressUpdate::JobFailed {\n        job_id: job_id.to_string(),\n        error: error.clone(),\n        duration: job.get_elapsed_time(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::error!(\"Задача {} завершена с ошибкой: {}\", job_id, error);\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"fail_job\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Отменить задачу\n  pub async fn cancel_job(\u0026self, job_id: \u0026str) -\u003e Result\u003c()\u003e {\n    let mut jobs = self.active_jobs.write().await;\n\n    if let Some(mut job) = jobs.remove(job_id) {\n      job.cancel()?;\n\n      // Отправляем уведомление об отмене\n      let update = ProgressUpdate::JobCancelled {\n        job_id: job_id.to_string(),\n      };\n      let _ = self.progress_sender.send(update);\n\n      log::info!(\"Задача {} отменена\", job_id);\n    } else {\n      return Err(VideoCompilerError::render(\n        job_id,\n        \"cancel_job\",\n        \"Задача не найдена\",\n      ));\n    }\n\n    Ok(())\n  }\n\n  /// Получить информацию о задаче\n  pub async fn get_job(\u0026self, job_id: \u0026str) -\u003e Option\u003cRenderJob\u003e {\n    let jobs = self.active_jobs.read().await;\n    jobs.get(job_id).cloned()\n  }\n\n  /// Получить все активные задачи\n  pub async fn get_active_jobs(\u0026self) -\u003e Vec\u003cRenderJob\u003e {\n    let jobs = self.active_jobs.read().await;\n    jobs.values().cloned().collect()\n  }\n\n  /// Парсинг вывода FFmpeg для получения прогресса\n  pub fn parse_ffmpeg_progress(\u0026self, output: \u0026str) -\u003e Option\u003cFFmpegProgress\u003e {\n    // Ищем строки с прогрессом FFmpeg\n    for line in output.lines() {\n      if line.starts_with(\"frame=\") {\n        return self.parse_progress_line(line);\n      }\n    }\n    None\n  }\n\n  /// Парсинг строки прогресса FFmpeg\n  fn parse_progress_line(\u0026self, line: \u0026str) -\u003e Option\u003cFFmpegProgress\u003e {\n    let mut progress = FFmpegProgress::default();\n\n    // Парсим различные поля из строки прогресса\n    // Пример: frame= 1234 fps=30 q=28.0 size= 1024kB time=00:00:41.40 bitrate=8000.0kbits/s\n    // Используем более гибкий парсинг для обработки пробелов после знака равенства\n\n    // Парсим frame\n    if let Some(pos) = line.find(\"frame=\") {\n      let start = pos + 6;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.frame = remaining[..end].parse().unwrap_or(0);\n      }\n    }\n\n    // Парсим fps\n    if let Some(pos) = line.find(\"fps=\") {\n      let start = pos + 4;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.fps = remaining[..end].parse().unwrap_or(0.0);\n      }\n    }\n\n    // Парсим q\n    if let Some(pos) = line.find(\"q=\") {\n      let start = pos + 2;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.quality = remaining[..end].parse().unwrap_or(0.0);\n      }\n    }\n\n    // Парсим size\n    if let Some(pos) = line.find(\"size=\") {\n      let start = pos + 5;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.size = parse_size(\u0026remaining[..end]);\n      }\n    }\n\n    // Парсим time\n    if let Some(pos) = line.find(\"time=\") {\n      let start = pos + 5;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.time = parse_time(\u0026remaining[..end]);\n      }\n    }\n\n    // Парсим bitrate\n    if let Some(pos) = line.find(\"bitrate=\") {\n      let start = pos + 8;\n      let remaining = \u0026line[start..].trim_start();\n      if let Some(end) = remaining.find(char::is_whitespace) {\n        progress.bitrate = parse_bitrate(\u0026remaining[..end]);\n      } else {\n        // Если это последнее поле\n        progress.bitrate = parse_bitrate(remaining);\n      }\n    }\n\n    // Парсим speed\n    if let Some(pos) = line.find(\"speed=\") {\n      let start = pos + 6;\n      let remaining = \u0026line[start..].trim_start();\n      let speed_str = if let Some(end) = remaining.find(char::is_whitespace) {\n        \u0026remaining[..end]\n      } else {\n        remaining\n      };\n      progress.speed = speed_str.trim_end_matches('x').parse().unwrap_or(0.0);\n    }\n\n    Some(progress)\n  }\n}\n\n/// Задача рендеринга\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RenderJob {\n  /// Уникальный идентификатор задачи\n  pub id: String,\n  /// Название проекта\n  pub project_name: String,\n  /// Путь к выходному файлу\n  pub output_path: String,\n  /// Статус задачи\n  pub status: RenderStatus,\n  /// Общее количество кадров\n  pub total_frames: u64,\n  /// Текущий кадр\n  pub current_frame: u64,\n  /// Текущий этап рендеринга\n  pub current_stage: String,\n  /// Время создания задачи\n  pub created_at: SystemTime,\n  /// Время начала рендеринга\n  pub started_at: Option\u003cSystemTime\u003e,\n  /// Время завершения рендеринга\n  pub completed_at: Option\u003cSystemTime\u003e,\n  /// Сообщение о состоянии\n  pub message: Option\u003cString\u003e,\n  /// Ошибка (если есть)\n  pub error: Option\u003cString\u003e,\n}\n\nimpl RenderJob {\n  /// Создать новую задачу рендеринга\n  pub fn new(id: String, project_name: String, output_path: String, total_frames: u64) -\u003e Self {\n    Self {\n      id,\n      project_name,\n      output_path,\n      status: RenderStatus::Queued,\n      total_frames,\n      current_frame: 0,\n      current_stage: \"Queued\".to_string(),\n      created_at: SystemTime::now(),\n      started_at: None,\n      completed_at: None,\n      message: None,\n      error: None,\n    }\n  }\n\n  /// Начать выполнение задачи\n  pub fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if self.status != RenderStatus::Queued {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"start\",\n        \"Задача не в состоянии ожидания\",\n      ));\n    }\n\n    self.status = RenderStatus::Processing;\n    self.started_at = Some(SystemTime::now());\n    self.current_stage = \"Starting\".to_string();\n    Ok(())\n  }\n\n  /// Обновить прогресс задачи\n  pub fn update_progress(\n    \u0026mut self,\n    current_frame: u64,\n    stage: String,\n    message: Option\u003cString\u003e,\n  ) -\u003e Result\u003c()\u003e {\n    if self.status != RenderStatus::Processing {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"update_progress\",\n        \"Задача не выполняется\",\n      ));\n    }\n\n    self.current_frame = current_frame.min(self.total_frames);\n    self.current_stage = stage;\n    self.message = message;\n    Ok(())\n  }\n\n  /// Завершить задачу успешно\n  pub fn complete(\u0026mut self, final_output_path: String) -\u003e Result\u003c()\u003e {\n    if self.status != RenderStatus::Processing {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"complete\",\n        \"Задача не выполняется\",\n      ));\n    }\n\n    self.status = RenderStatus::Completed;\n    self.completed_at = Some(SystemTime::now());\n    self.output_path = final_output_path;\n    self.current_frame = self.total_frames;\n    self.current_stage = \"Completed\".to_string();\n    Ok(())\n  }\n\n  /// Завершить задачу с ошибкой\n  pub fn fail(\u0026mut self, error: String) -\u003e Result\u003c()\u003e {\n    if self.status == RenderStatus::Completed {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"fail\",\n        \"Задача уже завершена\",\n      ));\n    }\n\n    self.status = RenderStatus::Failed;\n    self.completed_at = Some(SystemTime::now());\n    self.error = Some(error);\n    self.current_stage = \"Failed\".to_string();\n    Ok(())\n  }\n\n  /// Отменить задачу\n  pub fn cancel(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if matches!(self.status, RenderStatus::Completed | RenderStatus::Failed) {\n      return Err(VideoCompilerError::render(\n        \u0026self.id,\n        \"cancel\",\n        \"Задача уже завершена\",\n      ));\n    }\n\n    self.status = RenderStatus::Cancelled;\n    self.completed_at = Some(SystemTime::now());\n    self.current_stage = \"Cancelled\".to_string();\n    Ok(())\n  }\n\n  /// Получить прогресс рендеринга\n  pub fn get_progress(\u0026self) -\u003e RenderProgress {\n    let percentage = if self.total_frames \u003e 0 {\n      (self.current_frame as f32 / self.total_frames as f32) * 100.0\n    } else {\n      0.0\n    };\n\n    let elapsed_time = self.get_elapsed_time();\n    let estimated_remaining = if percentage \u003e 0.0 \u0026\u0026 percentage \u003c 100.0 {\n      let total_estimated = elapsed_time.as_secs_f32() * (100.0 / percentage);\n      Some(Duration::from_secs_f32(\n        total_estimated - elapsed_time.as_secs_f32(),\n      ))\n    } else {\n      None\n    };\n\n    RenderProgress {\n      job_id: self.id.clone(),\n      stage: self.current_stage.clone(),\n      percentage,\n      current_frame: self.current_frame,\n      total_frames: self.total_frames,\n      elapsed_time,\n      estimated_remaining,\n      status: self.status.clone(),\n      message: self.message.clone(),\n    }\n  }\n\n  /// Получить время выполнения\n  pub fn get_elapsed_time(\u0026self) -\u003e Duration {\n    let start_time = self.started_at.unwrap_or(self.created_at);\n    let end_time = self.completed_at.unwrap_or_else(SystemTime::now);\n    end_time\n      .duration_since(start_time)\n      .unwrap_or(Duration::ZERO)\n  }\n}\n\n/// Статус рендеринга\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum RenderStatus {\n  /// В очереди\n  Queued,\n  /// Выполняется\n  Processing,\n  /// Завершено успешно\n  Completed,\n  /// Завершено с ошибкой\n  Failed,\n  /// Отменено\n  Cancelled,\n}\n\n/// Прогресс рендеринга\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct RenderProgress {\n  /// ID задачи\n  pub job_id: String,\n  /// Текущий этап\n  pub stage: String,\n  /// Процент выполнения (0.0 - 100.0)\n  pub percentage: f32,\n  /// Текущий кадр\n  pub current_frame: u64,\n  /// Общее количество кадров\n  pub total_frames: u64,\n  /// Прошедшее время\n  pub elapsed_time: Duration,\n  /// Оценочное оставшееся время\n  pub estimated_remaining: Option\u003cDuration\u003e,\n  /// Статус задачи\n  pub status: RenderStatus,\n  /// Дополнительное сообщение\n  pub message: Option\u003cString\u003e,\n}\n\n/// Обновления прогресса для WebSocket\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"type\")]\npub enum ProgressUpdate {\n  /// Задача начата\n  JobStarted { job_id: String },\n  /// Прогресс изменился\n  ProgressChanged {\n    job_id: String,\n    progress: RenderProgress,\n  },\n  /// Задача завершена\n  JobCompleted {\n    job_id: String,\n    output_path: String,\n    duration: Duration,\n  },\n  /// Задача завершилась с ошибкой\n  JobFailed {\n    job_id: String,\n    error: String,\n    duration: Duration,\n  },\n  /// Задача отменена\n  JobCancelled { job_id: String },\n}\n\n/// Настройки трекера прогресса\n#[derive(Debug, Clone)]\npub struct ProgressSettings {\n  /// Интервал обновления прогресса\n  pub update_interval: Duration,\n  /// Максимальное количество активных задач\n  pub max_concurrent_jobs: usize,\n  /// Таймаут для задач\n  pub job_timeout: Duration,\n}\n\nimpl Default for ProgressSettings {\n  fn default() -\u003e Self {\n    Self {\n      update_interval: Duration::from_millis(500),\n      max_concurrent_jobs: 3,\n      job_timeout: Duration::from_secs(3600), // 1 час\n    }\n  }\n}\n\n/// Прогресс FFmpeg\n#[derive(Debug, Default, Clone)]\npub struct FFmpegProgress {\n  /// Номер кадра\n  pub frame: u64,\n  /// FPS\n  pub fps: f32,\n  /// Качество\n  pub quality: f32,\n  /// Размер выходного файла\n  pub size: u64,\n  /// Время обработки\n  pub time: Duration,\n  /// Битрейт\n  pub bitrate: f32,\n  /// Скорость обработки\n  pub speed: f32,\n}\n\n/// Парсинг размера файла из строки FFmpeg\nfn parse_size(size_str: \u0026str) -\u003e u64 {\n  let size_str = size_str.trim();\n  if let Some(value_str) = size_str.strip_suffix(\"kB\") {\n    value_str.parse::\u003cf64\u003e().unwrap_or(0.0) as u64 * 1024\n  } else if let Some(value_str) = size_str.strip_suffix(\"MB\") {\n    value_str.parse::\u003cf64\u003e().unwrap_or(0.0) as u64 * 1024 * 1024\n  } else if let Some(value_str) = size_str.strip_suffix(\"GB\") {\n    value_str.parse::\u003cf64\u003e().unwrap_or(0.0) as u64 * 1024 * 1024 * 1024\n  } else {\n    size_str.parse().unwrap_or(0)\n  }\n}\n\n/// Парсинг времени из строки FFmpeg (формат HH:MM:SS.ss)\nfn parse_time(time_str: \u0026str) -\u003e Duration {\n  let parts: Vec\u003c\u0026str\u003e = time_str.split(':').collect();\n  if parts.len() == 3 {\n    let hours: f64 = parts[0].parse().unwrap_or(0.0);\n    let minutes: f64 = parts[1].parse().unwrap_or(0.0);\n    let seconds: f64 = parts[2].parse().unwrap_or(0.0);\n\n    let total_seconds = hours * 3600.0 + minutes * 60.0 + seconds;\n    Duration::from_secs_f64(total_seconds)\n  } else {\n    Duration::ZERO\n  }\n}\n\n/// Парсинг битрейта из строки FFmpeg\nfn parse_bitrate(bitrate_str: \u0026str) -\u003e f32 {\n  let bitrate_str = bitrate_str.trim();\n  if let Some(value_str) = bitrate_str.strip_suffix(\"kbits/s\") {\n    value_str.parse().unwrap_or(0.0)\n  } else if let Some(value_str) = bitrate_str.strip_suffix(\"Mbits/s\") {\n    value_str.parse::\u003cf32\u003e().unwrap_or(0.0) * 1000.0\n  } else {\n    bitrate_str.parse().unwrap_or(0.0)\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use tokio::sync::mpsc;\n\n  #[tokio::test]\n  async fn test_progress_tracker_creation() {\n    let (tx, _rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let jobs = tracker.get_active_jobs().await;\n    assert_eq!(jobs.len(), 0);\n  }\n\n  #[tokio::test]\n  async fn test_job_lifecycle() {\n    let (tx, mut rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    // Создаем задачу\n    let job_id = tracker\n      .create_job(\n        \"Test Project\".to_string(),\n        \"/test/output.mp4\".to_string(),\n        1000,\n      )\n      .await\n      .unwrap();\n\n    // Проверяем уведомление о создании\n    let update = rx.recv().await.unwrap();\n    assert!(matches!(update, ProgressUpdate::JobStarted { .. }));\n\n    // Запускаем задачу чтобы изменить статус на Processing\n    {\n      let mut jobs = tracker.active_jobs.write().await;\n      if let Some(job) = jobs.get_mut(\u0026job_id) {\n        job.start().unwrap();\n      }\n    }\n\n    // Обновляем прогресс\n    tracker\n      .update_progress(\u0026job_id, 500, \"Encoding\".to_string(), None)\n      .await\n      .unwrap();\n\n    // Проверяем уведомление о прогрессе\n    let update = rx.recv().await.unwrap();\n    if let ProgressUpdate::ProgressChanged { progress, .. } = update {\n      assert_eq!(progress.current_frame, 500);\n      assert_eq!(progress.percentage, 50.0);\n    } else {\n      panic!(\"Ожидалось ProgressChanged\");\n    }\n\n    // Завершаем задачу\n    tracker\n      .complete_job(\u0026job_id, \"/test/final.mp4\".to_string())\n      .await\n      .unwrap();\n\n    // Проверяем уведомление о завершении\n    let update = rx.recv().await.unwrap();\n    assert!(matches!(update, ProgressUpdate::JobCompleted { .. }));\n\n    // Задача должна быть удалена из активных\n    let jobs = tracker.get_active_jobs().await;\n    assert_eq!(jobs.len(), 0);\n  }\n\n  #[tokio::test]\n  async fn test_render_job() {\n    let mut job = RenderJob::new(\n      \"test-123\".to_string(),\n      \"Test Project\".to_string(),\n      \"/test/output.mp4\".to_string(),\n      1000,\n    );\n\n    assert_eq!(job.status, RenderStatus::Queued);\n\n    // Начинаем задачу\n    job.start().unwrap();\n    assert_eq!(job.status, RenderStatus::Processing);\n    assert!(job.started_at.is_some());\n\n    // Обновляем прогресс\n    job\n      .update_progress(250, \"Encoding\".to_string(), Some(\"Frame 250\".to_string()))\n      .unwrap();\n    assert_eq!(job.current_frame, 250);\n\n    let progress = job.get_progress();\n    assert_eq!(progress.percentage, 25.0);\n\n    // Завершаем задачу\n    job.complete(\"/test/final.mp4\".to_string()).unwrap();\n    assert_eq!(job.status, RenderStatus::Completed);\n    assert!(job.completed_at.is_some());\n  }\n\n  #[test]\n  fn test_ffmpeg_progress_parsing() {\n    let (tx, _rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let ffmpeg_output =\n      \"frame= 1234 fps=30.5 q=28.0 size= 2048kB time=00:01:23.45 bitrate=1500.0kbits/s speed=1.2x\";\n    let progress = tracker.parse_ffmpeg_progress(ffmpeg_output).unwrap();\n\n    assert_eq!(progress.frame, 1234);\n    assert_eq!(progress.fps, 30.5);\n    assert_eq!(progress.quality, 28.0);\n    assert_eq!(progress.size, 2048 * 1024);\n    assert_eq!(progress.bitrate, 1500.0);\n    assert_eq!(progress.speed, 1.2);\n  }\n\n  #[test]\n  fn test_size_parsing() {\n    assert_eq!(parse_size(\"1024kB\"), 1024 * 1024);\n    assert_eq!(parse_size(\"2MB\"), 2 * 1024 * 1024);\n    assert_eq!(parse_size(\"1GB\"), 1024 * 1024 * 1024);\n    assert_eq!(parse_size(\"512\"), 512);\n  }\n\n  #[test]\n  fn test_time_parsing() {\n    let duration = parse_time(\"01:23:45.67\");\n    assert_eq!(duration.as_secs(), 3600 + 23 * 60 + 45);\n\n    let duration = parse_time(\"00:00:30.50\");\n    assert_eq!(duration.as_secs_f64(), 30.5);\n  }\n\n  #[test]\n  fn test_bitrate_parsing() {\n    assert_eq!(parse_bitrate(\"1500.0kbits/s\"), 1500.0);\n    assert_eq!(parse_bitrate(\"1.5Mbits/s\"), 1500.0);\n    assert_eq!(parse_bitrate(\"8000\"), 8000.0);\n  }\n\n  #[tokio::test]\n  async fn test_job_error_handling() {\n    let (tx, mut rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let job_id = tracker\n      .create_job(\n        \"Error Test\".to_string(),\n        \"/test/output.mp4\".to_string(),\n        100,\n      )\n      .await\n      .unwrap();\n\n    // Пропускаем уведомление о создании\n    rx.recv().await;\n\n    // Завершаем с ошибкой\n    tracker\n      .fail_job(\u0026job_id, \"FFmpeg error\".to_string())\n      .await\n      .unwrap();\n\n    // Проверяем уведомление об ошибке\n    let update = rx.recv().await.unwrap();\n    if let ProgressUpdate::JobFailed { error, .. } = update {\n      assert_eq!(error, \"FFmpeg error\");\n    } else {\n      panic!(\"Ожидалось JobFailed\");\n    }\n  }\n\n  #[tokio::test]\n  async fn test_job_cancellation() {\n    let (tx, mut rx) = mpsc::unbounded_channel();\n    let tracker = ProgressTracker::new(tx);\n\n    let job_id = tracker\n      .create_job(\n        \"Cancel Test\".to_string(),\n        \"/test/output.mp4\".to_string(),\n        100,\n      )\n      .await\n      .unwrap();\n\n    // Пропускаем уведомление о создании\n    rx.recv().await;\n\n    // Отменяем задачу\n    tracker.cancel_job(\u0026job_id).await.unwrap();\n\n    // Проверяем уведомление об отмене\n    let update = rx.recv().await.unwrap();\n    assert!(matches!(update, ProgressUpdate::JobCancelled { .. }));\n  }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":12}},{"line":185,"address":[],"length":0,"stats":{"Line":12}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":5}},{"line":320,"address":[],"length":0,"stats":{"Line":5}},{"line":321,"address":[],"length":0,"stats":{"Line":5}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":2}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":5}},{"line":352,"address":[],"length":0,"stats":{"Line":5}},{"line":353,"address":[],"length":0,"stats":{"Line":3}},{"line":354,"address":[],"length":0,"stats":{"Line":3}},{"line":355,"address":[],"length":0,"stats":{"Line":3}},{"line":356,"address":[],"length":0,"stats":{"Line":3}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":381,"address":[],"length":0,"stats":{"Line":2}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":2}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":397,"address":[],"length":0,"stats":{"Line":2}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":419,"address":[],"length":0,"stats":{"Line":4}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":6}},{"line":427,"address":[],"length":0,"stats":{"Line":2}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":440,"address":[],"length":0,"stats":{"Line":2}},{"line":443,"address":[],"length":0,"stats":{"Line":2}},{"line":444,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":5}},{"line":450,"address":[],"length":0,"stats":{"Line":5}},{"line":451,"address":[],"length":0,"stats":{"Line":5}},{"line":452,"address":[],"length":0,"stats":{"Line":5}},{"line":453,"address":[],"length":0,"stats":{"Line":5}},{"line":454,"address":[],"length":0,"stats":{"Line":5}},{"line":535,"address":[],"length":0,"stats":{"Line":12}},{"line":537,"address":[],"length":0,"stats":{"Line":12}},{"line":539,"address":[],"length":0,"stats":{"Line":12}},{"line":564,"address":[],"length":0,"stats":{"Line":5}},{"line":565,"address":[],"length":0,"stats":{"Line":5}},{"line":566,"address":[],"length":0,"stats":{"Line":7}},{"line":568,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":3}},{"line":579,"address":[],"length":0,"stats":{"Line":3}},{"line":580,"address":[],"length":0,"stats":{"Line":3}},{"line":581,"address":[],"length":0,"stats":{"Line":3}},{"line":582,"address":[],"length":0,"stats":{"Line":3}},{"line":583,"address":[],"length":0,"stats":{"Line":3}},{"line":585,"address":[],"length":0,"stats":{"Line":3}},{"line":586,"address":[],"length":0,"stats":{"Line":3}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":4}},{"line":594,"address":[],"length":0,"stats":{"Line":4}},{"line":595,"address":[],"length":0,"stats":{"Line":6}},{"line":597,"address":[],"length":0,"stats":{"Line":3}},{"line":600,"address":[],"length":0,"stats":{"Line":1}}],"covered":146,"coverable":196},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","renderer.rs"],"content":"//! Renderer - Основной модуль рендеринга видео\n//!\n//! Этот модуль реализует основную логику рендеринга видео проектов,\n//! включая управление задачами, интеграцию с FFmpeg и обработку ошибок.\n\nuse serde::{Deserialize, Serialize};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse tokio::sync::{mpsc, RwLock};\n\nuse crate::video_compiler::cache::RenderCache;\nuse crate::video_compiler::error::{Result, VideoCompilerError};\nuse crate::video_compiler::ffmpeg_builder::FFmpegBuilder;\nuse crate::video_compiler::pipeline::RenderPipeline;\nuse crate::video_compiler::progress::ProgressTracker;\nuse crate::video_compiler::schema::ProjectSchema;\nuse crate::video_compiler::CompilerSettings;\n\n/// Основной рендерер видео\n#[derive(Debug)]\npub struct VideoRenderer {\n  /// Схема проекта для рендеринга\n  project: ProjectSchema,\n  /// Настройки компилятора\n  settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n  /// Кэш рендеринга\n  cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n  /// Трекер прогресса\n  progress_tracker: Arc\u003cProgressTracker\u003e,\n  /// Построитель команд FFmpeg\n  ffmpeg_builder: FFmpegBuilder,\n}\n\nimpl VideoRenderer {\n  /// Создать новый рендерер\n  pub async fn new(\n    project: ProjectSchema,\n    settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n    cache: Arc\u003cRwLock\u003cRenderCache\u003e\u003e,\n    progress_sender: mpsc::UnboundedSender\u003ccrate::video_compiler::progress::ProgressUpdate\u003e,\n  ) -\u003e Result\u003cSelf\u003e {\n    // Валидация проекта\n    project.validate().map_err(VideoCompilerError::validation)?;\n\n    let progress_tracker = Arc::new(ProgressTracker::new(progress_sender));\n    let ffmpeg_builder = FFmpegBuilder::new(project.clone());\n\n    Ok(Self {\n      project,\n      settings,\n      cache,\n      progress_tracker,\n      ffmpeg_builder,\n    })\n  }\n\n  /// Запустить рендеринг видео\n  pub async fn render(\u0026mut self, output_path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let job_id = self.create_render_job(output_path).await?;\n\n    // Запускаем рендеринг в отдельной задаче\n    let job_id_clone = job_id.clone();\n    let project = self.project.clone();\n    let output_path = output_path.to_owned();\n    let progress_tracker = self.progress_tracker.clone();\n    let ffmpeg_builder = self.ffmpeg_builder.clone();\n    let settings = self.settings.clone();\n\n    let progress_tracker_clone = progress_tracker.clone();\n    tokio::spawn(async move {\n      let result = Self::render_internal(\n        project,\n        output_path,\n        progress_tracker,\n        ffmpeg_builder,\n        settings,\n        job_id_clone.clone(), // Передаем job_id\n      )\n      .await;\n\n      match result {\n        Ok(final_path) =\u003e {\n          let _ = progress_tracker_clone\n            .complete_job(\u0026job_id_clone, final_path)\n            .await;\n        }\n        Err(e) =\u003e {\n          log::error!(\"Ошибка рендеринга: {}\", e);\n          log::error!(\"  Код ошибки: {}\", e.error_code());\n          log::error!(\n            \"  Критическая: {}\",\n            if e.is_critical() { \"да\" } else { \"нет\" }\n          );\n          log::error!(\n            \"  Можно повторить: {}\",\n            if e.is_retryable() { \"да\" } else { \"нет\" }\n          );\n\n          let _ = progress_tracker_clone\n            .fail_job(\u0026job_id_clone, e.to_string())\n            .await;\n        }\n      }\n    });\n\n    Ok(job_id)\n  }\n\n  /// Создать задачу рендеринга\n  async fn create_render_job(\u0026self, output_path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let total_frames = self.estimate_total_frames();\n\n    self\n      .progress_tracker\n      .create_job(\n        self.project.metadata.name.clone(),\n        output_path.to_string_lossy().to_string(),\n        total_frames,\n      )\n      .await\n  }\n\n  /// Оценить общее количество кадров\n  fn estimate_total_frames(\u0026self) -\u003e u64 {\n    let duration = self.project.get_duration();\n    let fps = self.project.timeline.fps as f64;\n    (duration * fps) as u64\n  }\n\n  /// Внутренняя логика рендеринга\n  async fn render_internal(\n    project: ProjectSchema,\n    output_path: PathBuf,\n    progress_tracker: Arc\u003cProgressTracker\u003e,\n    _ffmpeg_builder: FFmpegBuilder,\n    settings: Arc\u003cRwLock\u003cCompilerSettings\u003e\u003e,\n    job_id: String, // Добавляем job_id как параметр\n  ) -\u003e Result\u003cString\u003e {\n    log::info!(\n      \"Начало рендеринга проекта: {} (job_id: {})\",\n      project.metadata.name,\n      job_id\n    );\n\n    // Создаем RenderPipeline\n    let mut pipeline = RenderPipeline::new(\n      project.clone(),\n      progress_tracker.clone(),\n      settings,\n      output_path.clone(),\n    )\n    .await?;\n\n    // Используем переданный job_id вместо поиска\n    // Это исправляет проблему с двойной системой отслеживания задач\n\n    // Запускаем pipeline\n    let final_output = pipeline.execute(\u0026job_id).await?;\n\n    log::info!(\"Рендеринг завершен: {:?}\", final_output);\n\n    Ok(final_output.to_string_lossy().to_string())\n  }\n\n  /// Отменить рендеринг\n  pub async fn cancel(\u0026mut self) -\u003e Result\u003c()\u003e {\n    // Получаем активные задачи и отменяем их\n    let jobs = self.progress_tracker.get_active_jobs().await;\n    for job in jobs {\n      self.progress_tracker.cancel_job(\u0026job.id).await?;\n    }\n    Ok(())\n  }\n\n  /// Получить текущий прогресс\n  pub async fn get_progress(\u0026self) -\u003e Option\u003ccrate::video_compiler::progress::RenderProgress\u003e {\n    let jobs = self.progress_tracker.get_active_jobs().await;\n    jobs.first().map(|job| job.get_progress())\n  }\n}\n\n/// Настройки рендеринга\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RenderSettings {\n  /// Использовать аппаратное ускорение\n  pub hardware_acceleration: bool,\n  /// Количество потоков FFmpeg\n  pub threads: Option\u003cu32\u003e,\n  /// Дополнительные параметры FFmpeg\n  pub extra_args: Vec\u003cString\u003e,\n  /// Таймаут рендеринга (секунды)\n  pub timeout_seconds: u64,\n}\n\nimpl Default for RenderSettings {\n  fn default() -\u003e Self {\n    Self {\n      hardware_acceleration: true,\n      threads: None, // Автоматическое определение\n      extra_args: Vec::new(),\n      timeout_seconds: 3600, // 1 час\n    }\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use crate::video_compiler::cache::RenderCache;\n  use crate::video_compiler::progress::ProgressUpdate;\n  use std::sync::Arc;\n  use tokio::sync::{mpsc, RwLock};\n\n  async fn create_test_renderer() -\u003e VideoRenderer {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n    let (tx, _rx) = mpsc::unbounded_channel::\u003cProgressUpdate\u003e();\n\n    VideoRenderer::new(project, settings, cache, tx)\n      .await\n      .unwrap()\n  }\n\n  #[tokio::test]\n  async fn test_renderer_creation() {\n    let renderer = create_test_renderer().await;\n    assert_eq!(renderer.project.metadata.name, \"Test Project\");\n  }\n\n  #[tokio::test]\n  async fn test_estimate_total_frames() {\n    let renderer = create_test_renderer().await;\n    let frames = renderer.estimate_total_frames();\n    // Пустой проект должен иметь 0 кадров\n    assert_eq!(frames, 0);\n  }\n\n  #[tokio::test]\n  async fn test_render_settings_default() {\n    let settings = RenderSettings::default();\n    assert!(settings.hardware_acceleration);\n    assert_eq!(settings.timeout_seconds, 3600);\n    assert!(settings.extra_args.is_empty());\n  }\n\n  #[tokio::test]\n  async fn test_cancel_render() {\n    let mut renderer = create_test_renderer().await;\n\n    // Отмена рендеринга не должна вызывать ошибку, даже если нет активных задач\n    let result = renderer.cancel().await;\n    assert!(result.is_ok());\n  }\n\n  #[tokio::test]\n  async fn test_get_progress_empty() {\n    let renderer = create_test_renderer().await;\n\n    // Без активных задач прогресс должен быть None\n    let progress = renderer.get_progress().await;\n    assert!(progress.is_none());\n  }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":48,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":5}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}}],"covered":58,"coverable":70},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","schema.rs"],"content":"//! Schema - Схема данных проекта Timeline Studio\n//!\n//! Этот модуль определяет структуры данных для описания проектов видеомонтажа,\n//! включая timeline, треки, клипы, эффекты и настройки.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n/// Основная схема проекта Timeline Studio\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectSchema {\n  /// Версия схемы проекта для совместимости\n  pub version: String,\n  /// Метаданные проекта\n  pub metadata: ProjectMetadata,\n  /// Настройки timeline (fps, разрешение, длительность)\n  pub timeline: Timeline,\n  /// Список треков (видео, аудио, субтитры)\n  pub tracks: Vec\u003cTrack\u003e,\n  /// Глобальные эффекты проекта\n  pub effects: Vec\u003cEffect\u003e,\n  /// Переходы между клипами\n  pub transitions: Vec\u003cTransition\u003e,\n  /// Фильтры для визуальных эффектов\n  pub filters: Vec\u003cFilter\u003e,\n  /// Шаблоны многокамерных раскладок\n  pub templates: Vec\u003cTemplate\u003e,\n  /// Стильные шаблоны (интро, аутро, титры)\n  pub style_templates: Vec\u003cStyleTemplate\u003e,\n  /// Субтитры проекта\n  pub subtitles: Vec\u003cSubtitle\u003e,\n  /// Настройки проекта и экспорта\n  pub settings: ProjectSettings,\n}\n\nimpl ProjectSchema {\n  /// Создать новый пустой проект\n  pub fn new(name: String) -\u003e Self {\n    Self {\n      version: \"1.0.0\".to_string(),\n      metadata: ProjectMetadata {\n        name,\n        description: None,\n        created_at: Utc::now(),\n        modified_at: Utc::now(),\n        author: None,\n      },\n      timeline: Timeline::default(),\n      tracks: Vec::new(),\n      effects: Vec::new(),\n      transitions: Vec::new(),\n      filters: Vec::new(),\n      templates: Vec::new(),\n      style_templates: Vec::new(),\n      subtitles: Vec::new(),\n      settings: ProjectSettings::default(),\n    }\n  }\n\n  /// Валидация схемы проекта\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    // Проверка версии\n    if self.version.is_empty() {\n      return Err(\"Версия проекта не может быть пустой\".to_string());\n    }\n\n    // Проверка timeline\n    if self.timeline.fps == 0 {\n      return Err(\"FPS должен быть больше 0\".to_string());\n    }\n\n    if self.timeline.resolution.0 == 0 || self.timeline.resolution.1 == 0 {\n      return Err(\"Разрешение должно быть больше 0x0\".to_string());\n    }\n\n    // Проверка треков\n    for track in \u0026self.tracks {\n      track.validate()?;\n    }\n\n    // Проверка клипов на пересечения по времени в одном треке\n    for track in \u0026self.tracks {\n      let mut clips = track.clips.clone();\n      clips.sort_by(|a, b| a.start_time.partial_cmp(\u0026b.start_time).unwrap());\n\n      for i in 0..clips.len().saturating_sub(1) {\n        if clips[i].end_time \u003e clips[i + 1].start_time {\n          return Err(format!(\n            \"Клипы пересекаются по времени в треке '{}': {} и {}\",\n            track.name,\n            clips[i].id,\n            clips[i + 1].id\n          ));\n        }\n      }\n    }\n\n    Ok(())\n  }\n\n  /// Получить общую длительность проекта\n  pub fn get_duration(\u0026self) -\u003e f64 {\n    self\n      .tracks\n      .iter()\n      .flat_map(|track| \u0026track.clips)\n      .map(|clip| clip.end_time)\n      .fold(0.0, f64::max)\n  }\n\n  /// Обновить время модификации\n  pub fn touch(\u0026mut self) {\n    self.metadata.modified_at = Utc::now();\n  }\n}\n\n/// Метаданные проекта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectMetadata {\n  /// Название проекта\n  pub name: String,\n  /// Описание проекта\n  pub description: Option\u003cString\u003e,\n  /// Время создания\n  pub created_at: DateTime\u003cUtc\u003e,\n  /// Время последней модификации\n  pub modified_at: DateTime\u003cUtc\u003e,\n  /// Автор проекта\n  pub author: Option\u003cString\u003e,\n}\n\n/// Настройки timeline\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Timeline {\n  /// Общая продолжительность в секундах\n  pub duration: f64,\n  /// Кадры в секунду\n  pub fps: u32,\n  /// Разрешение видео (ширина, высота)\n  pub resolution: (u32, u32),\n  /// Частота дискретизации аудио\n  pub sample_rate: u32,\n  /// Соотношение сторон\n  pub aspect_ratio: AspectRatio,\n}\n\nimpl Default for Timeline {\n  fn default() -\u003e Self {\n    Self {\n      duration: 0.0,\n      fps: 30,\n      resolution: (1920, 1080),\n      sample_rate: 48000,\n      aspect_ratio: AspectRatio::Ratio16x9,\n    }\n  }\n}\n\n/// Соотношение сторон видео\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum AspectRatio {\n  Ratio16x9,   // 16:9 (широкоформатное)\n  Ratio4x3,    // 4:3 (стандартное)\n  Ratio21x9,   // 21:9 (ультраширокое)\n  Ratio1x1,    // 1:1 (квадратное)\n  Ratio9x16,   // 9:16 (вертикальное для мобильных)\n  Custom(f32), // Произвольное соотношение\n}\n\n/// Дорожка timeline (видео, аудио, субтитры)\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Track {\n  /// Уникальный идентификатор трека\n  pub id: String,\n  /// Тип трека\n  pub track_type: TrackType,\n  /// Название трека\n  pub name: String,\n  /// Включен ли трек\n  pub enabled: bool,\n  /// Громкость трека (0.0 - 1.0)\n  pub volume: f32,\n  /// Заблокирован ли трек для редактирования\n  pub locked: bool,\n  /// Список клипов в треке\n  pub clips: Vec\u003cClip\u003e,\n  /// ID эффектов, применяемых ко всему треку\n  pub effects: Vec\u003cString\u003e,\n  /// ID фильтров, применяемых ко всему треку\n  pub filters: Vec\u003cString\u003e,\n}\n\nimpl Track {\n  /// Создать новый трек\n  pub fn new(track_type: TrackType, name: String) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      track_type,\n      name,\n      enabled: true,\n      volume: 1.0,\n      locked: false,\n      clips: Vec::new(),\n      effects: Vec::new(),\n      filters: Vec::new(),\n    }\n  }\n\n  /// Валидация трека\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    if self.name.is_empty() {\n      return Err(\"Название трека не может быть пустым\".to_string());\n    }\n\n    if !(0.0..=1.0).contains(\u0026self.volume) {\n      return Err(\"Громкость должна быть в диапазоне 0.0-1.0\".to_string());\n    }\n\n    for clip in \u0026self.clips {\n      clip.validate()?;\n    }\n\n    Ok(())\n  }\n\n  /// Добавить клип в трек\n  pub fn add_clip(\u0026mut self, clip: Clip) -\u003e Result\u003c(), String\u003e {\n    // Проверяем, что клип не пересекается с существующими\n    for existing_clip in \u0026self.clips {\n      if !(clip.end_time \u003c= existing_clip.start_time || clip.start_time \u003e= existing_clip.end_time) {\n        return Err(format!(\n          \"Клип пересекается с существующим клипом {}\",\n          existing_clip.id\n        ));\n      }\n    }\n\n    self.clips.push(clip);\n    Ok(())\n  }\n}\n\n/// Тип дорожки\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TrackType {\n  /// Видео дорожка\n  Video,\n  /// Аудио дорожка\n  Audio,\n  /// Дорожка субтитров\n  Subtitle,\n}\n\n/// Клип медиа на дорожке\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Clip {\n  /// Уникальный идентификатор клипа\n  pub id: String,\n  /// Путь к исходному медиа файлу\n  pub source_path: PathBuf,\n  /// Время начала клипа на timeline (секунды)\n  pub start_time: f64,\n  /// Время окончания клипа на timeline (секунды)\n  pub end_time: f64,\n  /// Время начала в исходном файле (секунды)\n  pub source_start: f64,\n  /// Время окончания в исходном файле (секунды)\n  pub source_end: f64,\n  /// Скорость воспроизведения (1.0 = нормальная)\n  pub speed: f32,\n  /// Громкость клипа (0.0 - 1.0)\n  pub volume: f32,\n  /// Заблокирован ли клип\n  pub locked: bool,\n  /// ID эффектов, применяемых к клипу\n  pub effects: Vec\u003cString\u003e,\n  /// ID фильтров, применяемых к клипу\n  pub filters: Vec\u003cString\u003e,\n  /// ID шаблона для многокамерной раскладки\n  pub template_id: Option\u003cString\u003e,\n  /// Индекс ячейки в шаблоне (0-based)\n  pub template_cell: Option\u003cusize\u003e,\n  /// ID стильного шаблона (интро, аутро, титры)\n  pub style_template_id: Option\u003cString\u003e,\n  /// Дополнительные свойства клипа\n  pub properties: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Clip {\n  /// Создать новый клип\n  pub fn new(source_path: PathBuf, start_time: f64, duration: f64) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      source_path,\n      start_time,\n      end_time: start_time + duration,\n      source_start: 0.0,\n      source_end: duration,\n      speed: 1.0,\n      volume: 1.0,\n      locked: false,\n      effects: Vec::new(),\n      filters: Vec::new(),\n      template_id: None,\n      template_cell: None,\n      style_template_id: None,\n      properties: HashMap::new(),\n    }\n  }\n\n  /// Валидация клипа\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    if self.start_time \u003c 0.0 {\n      return Err(\"Время начала не может быть отрицательным\".to_string());\n    }\n\n    if self.end_time \u003c= self.start_time {\n      return Err(\"Время окончания должно быть больше времени начала\".to_string());\n    }\n\n    if self.source_start \u003c 0.0 {\n      return Err(\"Время начала в источнике не может быть отрицательным\".to_string());\n    }\n\n    if self.source_end \u003c= self.source_start {\n      return Err(\"Время окончания в источнике должно быть больше времени начала\".to_string());\n    }\n\n    if self.speed \u003c= 0.0 {\n      return Err(\"Скорость должна быть больше 0\".to_string());\n    }\n\n    if !(0.0..=1.0).contains(\u0026self.volume) {\n      return Err(\"Громкость должна быть в диапазоне 0.0-1.0\".to_string());\n    }\n\n    if !self.source_path.exists() {\n      return Err(format!(\"Исходный файл не найден: {:?}\", self.source_path));\n    }\n\n    Ok(())\n  }\n\n  /// Получить длительность клипа на timeline\n  pub fn get_timeline_duration(\u0026self) -\u003e f64 {\n    self.end_time - self.start_time\n  }\n\n  /// Получить длительность исходного материала\n  pub fn get_source_duration(\u0026self) -\u003e f64 {\n    self.source_end - self.source_start\n  }\n}\n\n/// Эффект, применяемый к клипу или треку\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Effect {\n  /// Уникальный идентификатор эффекта\n  pub id: String,\n  /// Тип эффекта (строка для расширяемости)\n  pub effect_type: EffectType,\n  /// Название эффекта\n  pub name: String,\n  /// Категория эффекта\n  pub category: Option\u003cEffectCategory\u003e,\n  /// Сложность эффекта\n  pub complexity: Option\u003cEffectComplexity\u003e,\n  /// Теги эффекта\n  pub tags: Vec\u003cEffectTag\u003e,\n  /// Описание эффекта (локализованное)\n  pub description: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Метки эффекта (локализованные)\n  pub labels: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Включен ли эффект\n  pub enabled: bool,\n  /// Параметры эффекта\n  pub parameters: HashMap\u003cString, EffectParameter\u003e,\n  /// Время начала эффекта (для анимации)\n  pub start_time: Option\u003cf64\u003e,\n  /// Время окончания эффекта (для анимации)\n  pub end_time: Option\u003cf64\u003e,\n  /// FFmpeg команда (в виде шаблона)\n  pub ffmpeg_command: Option\u003cString\u003e,\n  /// CSS фильтр (в виде шаблона)\n  pub css_filter: Option\u003cString\u003e,\n  /// Путь к превью\n  pub preview_path: Option\u003cString\u003e,\n  /// Пресеты эффекта\n  pub presets: Option\u003cHashMap\u003cString, EffectPreset\u003e\u003e,\n}\n\n/// Пресет эффекта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct EffectPreset {\n  /// Название пресета (локализованное)\n  pub name: HashMap\u003cString, String\u003e,\n  /// Параметры пресета\n  pub params: HashMap\u003cString, EffectParameter\u003e,\n  /// Описание пресета (локализованное)\n  pub description: HashMap\u003cString, String\u003e,\n}\n\nimpl Effect {\n  /// Создать новый эффект\n  pub fn new(effect_type: EffectType, name: String) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      effect_type,\n      name,\n      category: None,\n      complexity: None,\n      tags: Vec::new(),\n      description: None,\n      labels: None,\n      enabled: true,\n      parameters: HashMap::new(),\n      start_time: None,\n      end_time: None,\n      ffmpeg_command: None,\n      css_filter: None,\n      preview_path: None,\n      presets: None,\n    }\n  }\n}\n\n/// Тип эффекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectType {\n  /// Размытие\n  Blur,\n  /// Яркость\n  Brightness,\n  /// Контрастность\n  Contrast,\n  /// Скорость\n  Speed,\n  /// Реверс\n  Reverse,\n  /// Черно-белый\n  Grayscale,\n  /// Сепия\n  Sepia,\n  /// Насыщенность\n  Saturation,\n  /// Поворот оттенка\n  HueRotate,\n  /// Винтаж\n  Vintage,\n  /// Дуотон\n  Duotone,\n  /// Нуар\n  Noir,\n  /// Киберпанк\n  Cyberpunk,\n  /// Мечтательный\n  Dreamy,\n  /// Инфракрасный\n  Infrared,\n  /// Матрица\n  Matrix,\n  /// Арктический\n  Arctic,\n  /// Закат\n  Sunset,\n  /// Ломо\n  Lomo,\n  /// Сумерки\n  Twilight,\n  /// Неон\n  Neon,\n  /// Инверсия\n  Invert,\n  /// Виньетка\n  Vignette,\n  /// Зерно пленки\n  FilmGrain,\n  /// Хроматическая аберрация\n  ChromaticAberration,\n  /// Блик объектива\n  LensFlare,\n  /// Свечение\n  Glow,\n  /// Резкость\n  Sharpen,\n  /// Шумоподавление\n  NoiseReduction,\n  /// Стабилизация\n  Stabilization,\n  // Аудио эффекты\n  /// Плавное появление звука\n  AudioFadeIn,\n  /// Плавное затухание звука\n  AudioFadeOut,\n  /// Кроссфейд между аудио\n  AudioCrossfade,\n  /// Эквалайзер\n  AudioEqualizer,\n  /// Компрессор\n  AudioCompressor,\n  /// Реверберация\n  AudioReverb,\n  /// Задержка (эхо)\n  AudioDelay,\n  /// Хорус\n  AudioChorus,\n  /// Искажение\n  AudioDistortion,\n  /// Нормализация\n  AudioNormalize,\n  /// Шумоподавление\n  AudioDenoise,\n  /// Изменение высоты тона\n  AudioPitch,\n  /// Изменение темпа\n  AudioTempo,\n  /// Приглушение (дакинг)\n  AudioDucking,\n  /// Гейт\n  AudioGate,\n  /// Лимитер\n  AudioLimiter,\n  /// Экспандер\n  AudioExpander,\n  /// Панорамирование\n  AudioPan,\n  /// Ширина стерео\n  AudioStereoWidth,\n  /// Фильтр высоких частот\n  AudioHighpass,\n  /// Фильтр низких частот\n  AudioLowpass,\n  /// Полосовой фильтр\n  AudioBandpass,\n}\n\n/// Категория эффекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectCategory {\n  /// Цветокоррекция\n  ColorCorrection,\n  /// Художественные\n  Artistic,\n  /// Винтажные\n  Vintage,\n  /// Кинематографические\n  Cinematic,\n  /// Креативные\n  Creative,\n  /// Технические\n  Technical,\n  /// Движение и скорость\n  Motion,\n  /// Искажения\n  Distortion,\n}\n\n/// Сложность эффекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectComplexity {\n  /// Базовый\n  Basic,\n  /// Средний\n  Intermediate,\n  /// Продвинутый\n  Advanced,\n}\n\n/// Теги эффектов\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum EffectTag {\n  /// Популярный\n  Popular,\n  /// Профессиональный\n  Professional,\n  /// Для начинающих\n  BeginnerFriendly,\n  /// Экспериментальный\n  Experimental,\n  /// Ретро\n  Retro,\n  /// Современный\n  Modern,\n  /// Драматический\n  Dramatic,\n  /// Тонкий\n  Subtle,\n  /// Интенсивный\n  Intense,\n}\n\n/// Параметр эффекта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum EffectParameter {\n  /// Число с плавающей точкой\n  Float(f32),\n  /// Целое число\n  Int(i32),\n  /// Строка\n  String(String),\n  /// Булево значение\n  Bool(bool),\n  /// Цвет в формате RGBA\n  Color(u32),\n  /// Массив чисел\n  FloatArray(Vec\u003cf32\u003e),\n  /// Путь к файлу\n  FilePath(PathBuf),\n}\n\n/// Фильтр для визуальных эффектов\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Filter {\n  /// Уникальный идентификатор фильтра\n  pub id: String,\n  /// Тип фильтра\n  pub filter_type: FilterType,\n  /// Название фильтра\n  pub name: String,\n  /// Включен ли фильтр\n  pub enabled: bool,\n  /// Параметры фильтра (числовые значения)\n  pub parameters: HashMap\u003cString, f64\u003e,\n  /// FFmpeg команда для применения фильтра\n  pub ffmpeg_command: Option\u003cString\u003e,\n}\n\nimpl Filter {\n  /// Создать новый фильтр\n  pub fn new(filter_type: FilterType, name: String) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      filter_type,\n      name,\n      enabled: true,\n      parameters: HashMap::new(),\n      ffmpeg_command: None,\n    }\n  }\n}\n\n/// Тип фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterType {\n  /// Яркость\n  Brightness,\n  /// Контрастность\n  Contrast,\n  /// Насыщенность\n  Saturation,\n  /// Гамма\n  Gamma,\n  /// Температура цвета\n  Temperature,\n  /// Оттенок\n  Tint,\n  /// Поворот цвета\n  Hue,\n  /// Живость цветов\n  Vibrance,\n  /// Тени\n  Shadows,\n  /// Светлые тона\n  Highlights,\n  /// Черные тона\n  Blacks,\n  /// Белые тона\n  Whites,\n  /// Четкость\n  Clarity,\n  /// Удаление дымки\n  Dehaze,\n  /// Виньетка\n  Vignette,\n  /// Зернистость\n  Grain,\n  /// Размытие\n  Blur,\n  /// Резкость\n  Sharpen,\n  /// Пользовательский фильтр\n  Custom,\n}\n\n/// Шаблон многокамерной раскладки\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Template {\n  /// Уникальный идентификатор шаблона\n  pub id: String,\n  /// Тип шаблона\n  pub template_type: TemplateType,\n  /// Название шаблона\n  pub name: String,\n  /// Количество видео в шаблоне\n  pub screens: usize,\n  /// Ячейки шаблона с позициями\n  pub cells: Vec\u003cTemplateCell\u003e,\n}\n\nimpl Template {\n  /// Создать новый шаблон\n  pub fn new(template_type: TemplateType, name: String, screens: usize) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      template_type,\n      name,\n      screens,\n      cells: Vec::new(),\n    }\n  }\n}\n\n/// Тип шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TemplateType {\n  /// Вертикальное разделение\n  Vertical,\n  /// Горизонтальное разделение\n  Horizontal,\n  /// Диагональное разделение\n  Diagonal,\n  /// Сетка\n  Grid,\n  /// Пользовательский\n  Custom,\n}\n\n/// Ячейка шаблона\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TemplateCell {\n  /// Индекс ячейки (0-based)\n  pub index: usize,\n  /// Позиция X в процентах (0-100)\n  pub x: f32,\n  /// Позиция Y в процентах (0-100)\n  pub y: f32,\n  /// Ширина в процентах (0-100)\n  pub width: f32,\n  /// Высота в процентах (0-100)\n  pub height: f32,\n  /// Режим масштабирования видео\n  pub fit_mode: FitMode,\n  /// Горизонтальное выравнивание\n  pub align_x: AlignX,\n  /// Вертикальное выравнивание\n  pub align_y: AlignY,\n  /// Дополнительное масштабирование (1.0 = 100%)\n  pub scale: Option\u003cf32\u003e,\n}\n\n/// Режим масштабирования видео в ячейке\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FitMode {\n  /// Вписать полностью с черными полосами\n  Contain,\n  /// Заполнить с обрезкой\n  Cover,\n  /// Растянуть на всю ячейку\n  Fill,\n}\n\n/// Горизонтальное выравнивание\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AlignX {\n  /// По левому краю\n  Left,\n  /// По центру\n  Center,\n  /// По правому краю\n  Right,\n}\n\n/// Вертикальное выравнивание\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AlignY {\n  /// По верхнему краю\n  Top,\n  /// По центру\n  Center,\n  /// По нижнему краю\n  Bottom,\n}\n\n/// Стильный шаблон (интро, аутро, титры)\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct StyleTemplate {\n  /// Уникальный идентификатор шаблона\n  pub id: String,\n  /// Название шаблона\n  pub name: String,\n  /// Категория шаблона\n  pub category: StyleTemplateCategory,\n  /// Стиль шаблона\n  pub style: StyleTemplateStyle,\n  /// Длительность в секундах\n  pub duration: f64,\n  /// Элементы шаблона\n  pub elements: Vec\u003cStyleTemplateElement\u003e,\n}\n\nimpl StyleTemplate {\n  /// Создать новый стильный шаблон\n  pub fn new(\n    name: String,\n    category: StyleTemplateCategory,\n    style: StyleTemplateStyle,\n    duration: f64,\n  ) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      name,\n      category,\n      style,\n      duration,\n      elements: Vec::new(),\n    }\n  }\n}\n\n/// Категория стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum StyleTemplateCategory {\n  /// Интро\n  Intro,\n  /// Аутро\n  Outro,\n  /// Нижняя треть\n  LowerThird,\n  /// Титры\n  Title,\n  /// Переход\n  Transition,\n  /// Наложение\n  Overlay,\n}\n\n/// Стиль шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum StyleTemplateStyle {\n  /// Современный\n  Modern,\n  /// Винтажный\n  Vintage,\n  /// Минимальный\n  Minimal,\n  /// Корпоративный\n  Corporate,\n  /// Креативный\n  Creative,\n  /// Кинематографический\n  Cinematic,\n}\n\n/// Элемент стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct StyleTemplateElement {\n  /// Уникальный идентификатор элемента\n  pub id: String,\n  /// Тип элемента\n  pub element_type: StyleElementType,\n  /// Название элемента\n  pub name: String,\n  /// Позиция элемента\n  pub position: Position2D,\n  /// Размер элемента\n  pub size: Size2D,\n  /// Временные параметры\n  pub timing: ElementTiming,\n  /// Свойства элемента\n  pub properties: StyleElementProperties,\n  /// Анимации элемента\n  pub animations: Vec\u003cElementAnimation\u003e,\n}\n\n/// Тип элемента стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum StyleElementType {\n  /// Текст\n  Text,\n  /// Фигура\n  Shape,\n  /// Изображение\n  Image,\n  /// Видео\n  Video,\n  /// Анимация\n  Animation,\n  /// Частицы\n  Particle,\n}\n\n/// Позиция в 2D пространстве\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Position2D {\n  /// Позиция X в процентах (0-100)\n  pub x: f32,\n  /// Позиция Y в процентах (0-100)\n  pub y: f32,\n}\n\n/// Размер в 2D пространстве\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Size2D {\n  /// Ширина в процентах (0-100)\n  pub width: f32,\n  /// Высота в процентах (0-100)\n  pub height: f32,\n}\n\n/// Временные параметры элемента\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ElementTiming {\n  /// Время начала в секундах\n  pub start: f64,\n  /// Время окончания в секундах\n  pub end: f64,\n}\n\n/// Свойства элемента стильного шаблона\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct StyleElementProperties {\n  /// Прозрачность (0-1)\n  pub opacity: Option\u003cf32\u003e,\n  /// Поворот в градусах\n  pub rotation: Option\u003cf32\u003e,\n  /// Масштаб\n  pub scale: Option\u003cf32\u003e,\n\n  // Текстовые свойства\n  /// Текст\n  pub text: Option\u003cString\u003e,\n  /// Размер шрифта\n  pub font_size: Option\u003cf32\u003e,\n  /// Семейство шрифтов\n  pub font_family: Option\u003cString\u003e,\n  /// Цвет\n  pub color: Option\u003cString\u003e,\n  /// Выравнивание текста\n  pub text_align: Option\u003cTextAlign\u003e,\n  /// Толщина шрифта\n  pub font_weight: Option\u003cFontWeight\u003e,\n\n  // Свойства фигур\n  /// Цвет фона\n  pub background_color: Option\u003cString\u003e,\n  /// Цвет границы\n  pub border_color: Option\u003cString\u003e,\n  /// Толщина границы\n  pub border_width: Option\u003cf32\u003e,\n  /// Радиус скругления\n  pub border_radius: Option\u003cf32\u003e,\n\n  // Свойства изображений/видео\n  /// Источник\n  pub src: Option\u003cString\u003e,\n  /// Режим заполнения\n  pub object_fit: Option\u003cObjectFit\u003e,\n}\n\n/// Выравнивание текста\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TextAlign {\n  /// По левому краю\n  Left,\n  /// По центру\n  Center,\n  /// По правому краю\n  Right,\n}\n\n/// Толщина шрифта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FontWeight {\n  /// Обычный\n  Normal,\n  /// Жирный\n  Bold,\n  /// Тонкий\n  Light,\n}\n\n/// Режим заполнения объекта\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum ObjectFit {\n  /// Вписать с сохранением пропорций\n  Contain,\n  /// Заполнить с обрезкой\n  Cover,\n  /// Растянуть\n  Fill,\n}\n\n/// Анимация элемента\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ElementAnimation {\n  /// Уникальный идентификатор анимации\n  pub id: String,\n  /// Тип анимации\n  pub animation_type: AnimationType,\n  /// Длительность анимации в секундах\n  pub duration: f64,\n  /// Задержка перед началом\n  pub delay: Option\u003cf64\u003e,\n  /// Функция сглаживания\n  pub easing: Option\u003cAnimationEasing\u003e,\n  /// Направление анимации\n  pub direction: Option\u003cAnimationDirection\u003e,\n  /// Дополнительные свойства\n  pub properties: HashMap\u003cString, serde_json::Value\u003e,\n}\n\n/// Тип анимации\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AnimationType {\n  /// Появление\n  FadeIn,\n  /// Исчезновение\n  FadeOut,\n  /// Въезд\n  SlideIn,\n  /// Выезд\n  SlideOut,\n  /// Увеличение\n  ScaleIn,\n  /// Уменьшение\n  ScaleOut,\n  /// Прыжок\n  Bounce,\n  /// Тряска\n  Shake,\n}\n\n/// Функция сглаживания анимации\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AnimationEasing {\n  /// Линейная\n  Linear,\n  /// Плавная\n  Ease,\n  /// Плавный вход\n  EaseIn,\n  /// Плавный выход\n  EaseOut,\n  /// Плавный вход и выход\n  EaseInOut,\n}\n\n/// Направление анимации\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum AnimationDirection {\n  /// Влево\n  Left,\n  /// Вправо\n  Right,\n  /// Вверх\n  Up,\n  /// Вниз\n  Down,\n}\n\n/// Переход между клипами\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Transition {\n  /// Уникальный идентификатор перехода\n  pub id: String,\n  /// Тип перехода (строка для расширяемости)\n  pub transition_type: TransitionType,\n  /// Название перехода\n  pub name: String,\n  /// Метки перехода (локализованные)\n  pub labels: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Описание перехода (локализованное)\n  pub description: Option\u003cHashMap\u003cString, String\u003e\u003e,\n  /// Категория перехода\n  pub category: Option\u003cTransitionCategory\u003e,\n  /// Сложность перехода\n  pub complexity: Option\u003cTransitionComplexity\u003e,\n  /// Теги перехода\n  pub tags: Vec\u003cTransitionTag\u003e,\n  /// Настройки длительности\n  pub duration: TransitionDuration,\n  /// Время начала перехода на timeline\n  pub start_time: f64,\n  /// ID клипа \"от\"\n  pub from_clip_id: String,\n  /// ID клипа \"к\"\n  pub to_clip_id: String,\n  /// Параметры перехода\n  pub parameters: HashMap\u003cString, EffectParameter\u003e,\n  /// FFmpeg команда (в виде шаблона)\n  pub ffmpeg_command: Option\u003cString\u003e,\n  /// Путь к превью\n  pub preview_path: Option\u003cString\u003e,\n}\n\n/// Настройки длительности перехода\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TransitionDuration {\n  /// Минимальная длительность в секундах\n  pub min: f64,\n  /// Максимальная длительность в секундах\n  pub max: f64,\n  /// Длительность по умолчанию\n  pub default: f64,\n  /// Текущая длительность\n  pub current: f64,\n}\n\n/// Фильтр видео\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct VideoFilter {\n  /// Уникальный идентификатор фильтра\n  pub id: String,\n  /// Название фильтра\n  pub name: String,\n  /// Категория фильтра\n  pub category: FilterCategory,\n  /// Сложность фильтра\n  pub complexity: FilterComplexity,\n  /// Теги фильтра\n  pub tags: Vec\u003cFilterTag\u003e,\n  /// Описание фильтра (локализованное)\n  pub description: HashMap\u003cString, String\u003e,\n  /// Метки фильтра (локализованные)\n  pub labels: HashMap\u003cString, String\u003e,\n  /// Параметры фильтра\n  pub params: HashMap\u003cString, f32\u003e,\n}\n\n/// Категория фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterCategory {\n  /// Цветокоррекция\n  ColorCorrection,\n  /// Технические\n  Technical,\n  /// Кинематографические\n  Cinematic,\n  /// Художественные\n  Artistic,\n  /// Креативные\n  Creative,\n  /// Винтажные\n  Vintage,\n}\n\n/// Сложность фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterComplexity {\n  /// Базовый\n  Basic,\n  /// Средний\n  Intermediate,\n  /// Продвинутый\n  Advanced,\n}\n\n/// Тег фильтра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum FilterTag {\n  /// Логарифмический\n  Log,\n  /// Профессиональный\n  Professional,\n  /// Стандартный\n  Standard,\n  /// Нейтральный\n  Neutral,\n  /// Кинематографический\n  Cinematic,\n  /// Портрет\n  Portrait,\n  /// Пейзаж\n  Landscape,\n  /// Винтажный\n  Vintage,\n  /// Теплый\n  Warm,\n  /// Холодный\n  Cold,\n  /// Драматический\n  Dramatic,\n  /// Мягкий\n  Soft,\n  /// Яркий\n  Vibrant,\n  /// Резервный\n  Fallback,\n}\n\n/// Тип перехода (расширяемый через строки)\npub type TransitionType = String;\n\n/// Категория перехода\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TransitionCategory {\n  /// Базовые\n  Basic,\n  /// Продвинутые\n  Advanced,\n  /// Креативные\n  Creative,\n  /// 3D\n  ThreeD,\n  /// Художественные\n  Artistic,\n  /// Кинематографические\n  Cinematic,\n}\n\n/// Сложность перехода\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TransitionComplexity {\n  /// Базовый\n  Basic,\n  /// Средний\n  Intermediate,\n  /// Продвинутый\n  Advanced,\n}\n\n/// Тег перехода\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum TransitionTag {\n  /// Приближение\n  Zoom,\n  /// Масштаб\n  Scale,\n  /// Плавный\n  Smooth,\n  /// Затухание\n  Fade,\n  /// Прозрачность\n  Opacity,\n  /// Классический\n  Classic,\n  /// Слайд\n  Slide,\n  /// Движение\n  Movement,\n  /// Направление\n  Direction,\n  /// Размер\n  Size,\n  /// Трансформация\n  Transform,\n  /// Поворот\n  Rotate,\n  /// Вращение\n  Spin,\n  /// Переворот\n  Flip,\n  /// Зеркало\n  Mirror,\n  /// Выталкивание\n  Push,\n  /// Смещение\n  Displacement,\n  /// Сжатие\n  Squeeze,\n  /// Компрессия\n  Compress,\n  /// Эластичный\n  Elastic,\n  /// Диагональный\n  Diagonal,\n  /// Угол\n  Angle,\n  /// Спираль\n  Spiral,\n  /// Вращение\n  Rotation,\n  /// 3D\n  ThreeD,\n  /// Сложный\n  Complex,\n  /// Резервный\n  Fallback,\n  /// Шторка\n  Wipe,\n  /// Горизонтальный\n  Horizontal,\n  /// Вертикальный\n  Vertical,\n  /// Радиальный\n  Radial,\n  /// Круговой\n  Circular,\n  /// Центр\n  Center,\n  /// Куб\n  Cube,\n  /// Страница\n  Page,\n  /// Поворот\n  Turn,\n  /// Книга\n  Book,\n  /// Креативный\n  Creative,\n  /// Рябь\n  Ripple,\n  /// Вода\n  Water,\n  /// Волна\n  Wave,\n  /// Искажение\n  Distortion,\n  /// Пиксель\n  Pixel,\n  /// Цифровой\n  Digital,\n  /// Ретро\n  Retro,\n  /// 8-бит\n  EightBit,\n  /// Растворение\n  Dissolve,\n  /// Шум\n  Noise,\n  /// Морфинг\n  Morph,\n  /// Жидкий\n  Fluid,\n  /// Глитч\n  Glitch,\n  /// Современный\n  Modern,\n  /// Калейдоскоп\n  Kaleidoscope,\n  /// Геометрический\n  Geometric,\n  /// Артистический\n  Artistic,\n  /// Разбитие\n  Shatter,\n  /// Ломать\n  Break,\n  /// Стекло\n  Glass,\n  /// Драматический\n  Dramatic,\n  /// Горение\n  Burn,\n  /// Огонь\n  Fire,\n  /// Кинематографический\n  Cinematic,\n  /// Жалюзи\n  Blinds,\n  /// Полосы\n  Stripes,\n  /// Диафрагма\n  Iris,\n  /// Камера\n  Camera,\n  /// Водоворот\n  Swirl,\n  /// Закручивание\n  Twist,\n  /// Размытие\n  Blur,\n  /// Движение\n  Motion,\n  /// Скорость\n  Speed,\n  /// ТВ\n  Tv,\n  /// Помехи\n  Static,\n  /// Аналоговый\n  Analog,\n}\n\n/// Настройки проекта\n#[derive(Serialize, Deserialize, Debug, Clone, Default)]\npub struct ProjectSettings {\n  /// Настройки экспорта\n  pub export: ExportSettings,\n  /// Настройки превью\n  pub preview: PreviewSettings,\n  /// Пользовательские настройки\n  pub custom: HashMap\u003cString, serde_json::Value\u003e,\n}\n\n/// Настройки экспорта\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ExportSettings {\n  /// Формат вывода\n  pub format: OutputFormat,\n  /// Качество (от 1 до 100)\n  pub quality: u8,\n  /// Битрейт видео (kbps)\n  pub video_bitrate: u32,\n  /// Битрейт аудио (kbps)\n  pub audio_bitrate: u32,\n  /// Использовать аппаратное ускорение\n  pub hardware_acceleration: bool,\n  /// Предпочитаемый GPU кодировщик (опционально)\n  pub preferred_gpu_encoder: Option\u003cString\u003e,\n  /// Дополнительные параметры FFmpeg\n  pub ffmpeg_args: Vec\u003cString\u003e,\n}\n\nimpl Default for ExportSettings {\n  fn default() -\u003e Self {\n    Self {\n      format: OutputFormat::Mp4,\n      quality: 85,\n      video_bitrate: 8000,\n      audio_bitrate: 192,\n      hardware_acceleration: true,\n      preferred_gpu_encoder: None,\n      ffmpeg_args: Vec::new(),\n    }\n  }\n}\n\n/// Формат вывода видео\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum OutputFormat {\n  Mp4,\n  Avi,\n  Mov,\n  Mkv,\n  WebM,\n  Gif,\n  Custom(String),\n}\n\n/// Настройки превью\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PreviewSettings {\n  /// Разрешение превью\n  pub resolution: (u32, u32),\n  /// Качество превью (от 1 до 100)\n  pub quality: u8,\n  /// FPS превью\n  pub fps: u32,\n  /// Формат превью\n  pub format: PreviewFormat,\n}\n\nimpl Default for PreviewSettings {\n  fn default() -\u003e Self {\n    Self {\n      resolution: (640, 360),\n      quality: 75,\n      fps: 15,\n      format: PreviewFormat::Jpeg,\n    }\n  }\n}\n\n/// Формат превью\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum PreviewFormat {\n  Jpeg,\n  Png,\n  WebP,\n}\n\n/// Субтитр\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Subtitle {\n  /// Уникальный идентификатор субтитра\n  pub id: String,\n  /// Текст субтитра\n  pub text: String,\n  /// Время начала в секундах\n  pub start_time: f64,\n  /// Время окончания в секундах\n  pub end_time: f64,\n  /// Позиция субтитра на экране\n  pub position: SubtitlePosition,\n  /// Стиль субтитра\n  pub style: SubtitleStyle,\n  /// Включен ли субтитр\n  pub enabled: bool,\n  /// Анимации субтитра\n  pub animations: Vec\u003cSubtitleAnimation\u003e,\n}\n\nimpl Subtitle {\n  /// Создать новый субтитр\n  pub fn new(text: String, start_time: f64, end_time: f64) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      text,\n      start_time,\n      end_time,\n      position: SubtitlePosition::default(),\n      style: SubtitleStyle::default(),\n      enabled: true,\n      animations: Vec::new(),\n    }\n  }\n\n  /// Проверить валидность субтитра\n  pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n    if self.text.is_empty() {\n      return Err(\"Текст субтитра не может быть пустым\".to_string());\n    }\n\n    if self.start_time \u003c 0.0 {\n      return Err(\"Время начала не может быть отрицательным\".to_string());\n    }\n\n    if self.end_time \u003c= self.start_time {\n      return Err(\"Время окончания должно быть больше времени начала\".to_string());\n    }\n\n    Ok(())\n  }\n\n  /// Получить длительность субтитра\n  pub fn get_duration(\u0026self) -\u003e f64 {\n    self.end_time - self.start_time\n  }\n}\n\n/// Позиция субтитра на экране\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitlePosition {\n  /// Позиция X в процентах (0-100)\n  pub x: f32,\n  /// Позиция Y в процентах (0-100)  \n  pub y: f32,\n  /// Выравнивание по горизонтали\n  pub align_x: SubtitleAlignX,\n  /// Выравнивание по вертикали\n  pub align_y: SubtitleAlignY,\n  /// Отступы в пикселях\n  pub margin: SubtitleMargin,\n}\n\nimpl Default for SubtitlePosition {\n  fn default() -\u003e Self {\n    Self {\n      x: 50.0, // По центру\n      y: 85.0, // Внизу экрана\n      align_x: SubtitleAlignX::Center,\n      align_y: SubtitleAlignY::Bottom,\n      margin: SubtitleMargin::default(),\n    }\n  }\n}\n\n/// Горизонтальное выравнивание субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleAlignX {\n  /// По левому краю\n  Left,\n  /// По центру\n  Center,\n  /// По правому краю\n  Right,\n}\n\n/// Вертикальное выравнивание субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleAlignY {\n  /// По верхнему краю\n  Top,\n  /// По центру\n  Center,\n  /// По нижнему краю\n  Bottom,\n}\n\n/// Отступы субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitleMargin {\n  /// Отступ сверху в пикселях\n  pub top: f32,\n  /// Отступ справа в пикселях\n  pub right: f32,\n  /// Отступ снизу в пикселях\n  pub bottom: f32,\n  /// Отступ слева в пикселях\n  pub left: f32,\n}\n\nimpl Default for SubtitleMargin {\n  fn default() -\u003e Self {\n    Self {\n      top: 20.0,\n      right: 20.0,\n      bottom: 20.0,\n      left: 20.0,\n    }\n  }\n}\n\n/// Стиль субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitleStyle {\n  /// Название шрифта\n  pub font_family: String,\n  /// Размер шрифта в пикселях\n  pub font_size: f32,\n  /// Толщина шрифта\n  pub font_weight: SubtitleFontWeight,\n  /// Цвет текста (в формате #RRGGBB или #RRGGBBAA)\n  pub color: String,\n  /// Цвет обводки (опционально)\n  pub stroke_color: Option\u003cString\u003e,\n  /// Толщина обводки в пикселях\n  pub stroke_width: f32,\n  /// Цвет тени (опционально)\n  pub shadow_color: Option\u003cString\u003e,\n  /// Смещение тени по X\n  pub shadow_x: f32,\n  /// Смещение тени по Y\n  pub shadow_y: f32,\n  /// Размытие тени\n  pub shadow_blur: f32,\n  /// Цвет фона (опционально)\n  pub background_color: Option\u003cString\u003e,\n  /// Прозрачность фона (0-1)\n  pub background_opacity: f32,\n  /// Отступы текста внутри фона\n  pub padding: SubtitlePadding,\n  /// Радиус скругления фона\n  pub border_radius: f32,\n  /// Межстрочный интервал\n  pub line_height: f32,\n  /// Межбуквенный интервал\n  pub letter_spacing: f32,\n  /// Максимальная ширина в процентах\n  pub max_width: f32,\n}\n\nimpl Default for SubtitleStyle {\n  fn default() -\u003e Self {\n    Self {\n      font_family: \"Arial\".to_string(),\n      font_size: 24.0,\n      font_weight: SubtitleFontWeight::Normal,\n      color: \"#FFFFFF\".to_string(),\n      stroke_color: Some(\"#000000\".to_string()),\n      stroke_width: 2.0,\n      shadow_color: Some(\"#000000\".to_string()),\n      shadow_x: 2.0,\n      shadow_y: 2.0,\n      shadow_blur: 4.0,\n      background_color: None,\n      background_opacity: 0.8,\n      padding: SubtitlePadding::default(),\n      border_radius: 4.0,\n      line_height: 1.2,\n      letter_spacing: 0.0,\n      max_width: 80.0,\n    }\n  }\n}\n\n/// Толщина шрифта субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleFontWeight {\n  /// Тонкий\n  Thin,\n  /// Светлый\n  Light,\n  /// Обычный\n  Normal,\n  /// Средний\n  Medium,\n  /// Жирный\n  Bold,\n  /// Очень жирный\n  Black,\n}\n\n/// Отступы текста внутри фона субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitlePadding {\n  /// Отступ сверху\n  pub top: f32,\n  /// Отступ справа\n  pub right: f32,\n  /// Отступ снизу\n  pub bottom: f32,\n  /// Отступ слева\n  pub left: f32,\n}\n\nimpl Default for SubtitlePadding {\n  fn default() -\u003e Self {\n    Self {\n      top: 8.0,\n      right: 12.0,\n      bottom: 8.0,\n      left: 12.0,\n    }\n  }\n}\n\n/// Анимация субтитра\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SubtitleAnimation {\n  /// Уникальный идентификатор анимации\n  pub id: String,\n  /// Тип анимации\n  pub animation_type: SubtitleAnimationType,\n  /// Длительность анимации в секундах\n  pub duration: f64,\n  /// Задержка перед началом анимации\n  pub delay: f64,\n  /// Функция сглаживания\n  pub easing: SubtitleEasing,\n  /// Направление анимации (для движения)\n  pub direction: Option\u003cSubtitleDirection\u003e,\n  /// Дополнительные параметры\n  pub properties: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl SubtitleAnimation {\n  /// Создать новую анимацию субтитра\n  pub fn new(animation_type: SubtitleAnimationType, duration: f64) -\u003e Self {\n    Self {\n      id: uuid::Uuid::new_v4().to_string(),\n      animation_type,\n      duration,\n      delay: 0.0,\n      easing: SubtitleEasing::EaseInOut,\n      direction: None,\n      properties: HashMap::new(),\n    }\n  }\n}\n\n/// Тип анимации субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleAnimationType {\n  /// Появление с изменением прозрачности\n  FadeIn,\n  /// Исчезновение с изменением прозрачности\n  FadeOut,\n  /// Въезд с указанного направления\n  SlideIn,\n  /// Выезд в указанном направлении\n  SlideOut,\n  /// Увеличение от 0 до полного размера\n  ScaleIn,\n  /// Уменьшение до 0\n  ScaleOut,\n  /// Печатающаяся машинка (по буквам)\n  Typewriter,\n  /// Волна (буквы появляются по очереди)\n  Wave,\n  /// Подпрыгивание\n  Bounce,\n  /// Покачивание\n  Shake,\n  /// Мигание\n  Blink,\n  /// Растворение (буквы исчезают случайно)\n  Dissolve,\n}\n\n/// Функция сглаживания анимации субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleEasing {\n  /// Линейная\n  Linear,\n  /// Плавная\n  Ease,\n  /// Плавный вход\n  EaseIn,\n  /// Плавный выход\n  EaseOut,\n  /// Плавный вход и выход\n  EaseInOut,\n  /// Эластичная\n  Elastic,\n  /// Прыжок\n  Bounce,\n}\n\n/// Направление анимации субтитра\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum SubtitleDirection {\n  /// Сверху\n  Top,\n  /// Снизу\n  Bottom,\n  /// Слева\n  Left,\n  /// Справа\n  Right,\n  /// Из центра\n  Center,\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_project_schema_creation() {\n    let project = ProjectSchema::new(\"Test Project\".to_string());\n    assert_eq!(project.metadata.name, \"Test Project\");\n    assert_eq!(project.version, \"1.0.0\");\n    assert_eq!(project.timeline.fps, 30);\n    assert_eq!(project.timeline.resolution, (1920, 1080));\n  }\n\n  #[test]\n  fn test_track_creation() {\n    let track = Track::new(TrackType::Video, \"Video Track 1\".to_string());\n    assert_eq!(track.track_type, TrackType::Video);\n    assert_eq!(track.name, \"Video Track 1\");\n    assert!(track.enabled);\n    assert_eq!(track.volume, 1.0);\n    assert!(!track.id.is_empty());\n  }\n\n  #[test]\n  fn test_clip_creation() {\n    let clip = Clip::new(PathBuf::from(\"/test/video.mp4\"), 10.0, 5.0);\n    assert_eq!(clip.start_time, 10.0);\n    assert_eq!(clip.end_time, 15.0);\n    assert_eq!(clip.get_timeline_duration(), 5.0);\n    assert_eq!(clip.speed, 1.0);\n    assert!(!clip.id.is_empty());\n  }\n\n  #[test]\n  fn test_effect_creation() {\n    let effect = Effect::new(EffectType::Blur, \"Blur\".to_string());\n    assert_eq!(effect.effect_type, EffectType::Blur);\n    assert_eq!(effect.name, \"Blur\");\n    assert!(effect.enabled);\n    assert!(!effect.id.is_empty());\n  }\n\n  #[test]\n  fn test_project_validation() {\n    let mut project = ProjectSchema::new(\"Test\".to_string());\n\n    // Пустой проект должен быть валидным\n    assert!(project.validate().is_ok());\n\n    // Невалидный FPS\n    project.timeline.fps = 0;\n    assert!(project.validate().is_err());\n\n    // Восстанавливаем валидный FPS\n    project.timeline.fps = 30;\n    assert!(project.validate().is_ok());\n\n    // Невалидное разрешение\n    project.timeline.resolution = (0, 1080);\n    assert!(project.validate().is_err());\n  }\n\n  #[test]\n  fn test_timeline_duration_calculation() {\n    let mut project = ProjectSchema::new(\"Test\".to_string());\n\n    // Добавляем трек с клипом\n    let mut track = Track::new(TrackType::Video, \"Test Track\".to_string());\n    let clip = Clip::new(PathBuf::from(\"/test.mp4\"), 5.0, 10.0);\n    track.clips.push(clip);\n    project.tracks.push(track);\n\n    // Длительность должна быть 15.0 (start_time 5.0 + duration 10.0)\n    assert_eq!(project.get_duration(), 15.0);\n  }\n\n  #[test]\n  fn test_effect_parameter_types() {\n    let mut params = HashMap::new();\n    params.insert(\"intensity\".to_string(), EffectParameter::Float(0.5));\n    params.insert(\"enabled\".to_string(), EffectParameter::Bool(true));\n    params.insert(\n      \"name\".to_string(),\n      EffectParameter::String(\"test\".to_string()),\n    );\n    params.insert(\"color\".to_string(), EffectParameter::Color(0xFF0000FF));\n\n    assert_eq!(params.len(), 4);\n  }\n\n  #[test]\n  fn test_serialization() {\n    let project = ProjectSchema::new(\"Serialization Test\".to_string());\n\n    // Сериализация в JSON\n    let json = serde_json::to_string(\u0026project).unwrap();\n    assert!(json.contains(\"Serialization Test\"));\n\n    // Десериализация из JSON\n    let deserialized: ProjectSchema = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(deserialized.metadata.name, \"Serialization Test\");\n  }\n\n  #[test]\n  fn test_subtitle_creation() {\n    let subtitle = Subtitle::new(\"Привет мир!\".to_string(), 10.0, 15.0);\n    assert_eq!(subtitle.text, \"Привет мир!\");\n    assert_eq!(subtitle.start_time, 10.0);\n    assert_eq!(subtitle.end_time, 15.0);\n    assert_eq!(subtitle.get_duration(), 5.0);\n    assert!(subtitle.enabled);\n    assert!(!subtitle.id.is_empty());\n  }\n\n  #[test]\n  fn test_subtitle_validation() {\n    // Валидный субтитр\n    let subtitle = Subtitle::new(\"Текст\".to_string(), 0.0, 5.0);\n    assert!(subtitle.validate().is_ok());\n\n    // Пустой текст\n    let mut invalid_subtitle = subtitle.clone();\n    invalid_subtitle.text = \"\".to_string();\n    assert!(invalid_subtitle.validate().is_err());\n\n    // Отрицательное время начала\n    let mut invalid_subtitle = subtitle.clone();\n    invalid_subtitle.start_time = -1.0;\n    assert!(invalid_subtitle.validate().is_err());\n\n    // Время окончания меньше времени начала\n    let mut invalid_subtitle = subtitle.clone();\n    invalid_subtitle.end_time = invalid_subtitle.start_time - 1.0;\n    assert!(invalid_subtitle.validate().is_err());\n  }\n\n  #[test]\n  fn test_subtitle_style_default() {\n    let style = SubtitleStyle::default();\n    assert_eq!(style.font_family, \"Arial\");\n    assert_eq!(style.font_size, 24.0);\n    assert_eq!(style.color, \"#FFFFFF\");\n    assert_eq!(style.stroke_width, 2.0);\n    assert!(style.stroke_color.is_some());\n    assert!(style.shadow_color.is_some());\n  }\n\n  #[test]\n  fn test_subtitle_position_default() {\n    let position = SubtitlePosition::default();\n    assert_eq!(position.x, 50.0); // По центру\n    assert_eq!(position.y, 85.0); // Внизу экрана\n    assert_eq!(position.align_x, SubtitleAlignX::Center);\n    assert_eq!(position.align_y, SubtitleAlignY::Bottom);\n  }\n\n  #[test]\n  fn test_subtitle_animation_creation() {\n    let animation = SubtitleAnimation::new(SubtitleAnimationType::FadeIn, 1.0);\n    assert_eq!(animation.animation_type, SubtitleAnimationType::FadeIn);\n    assert_eq!(animation.duration, 1.0);\n    assert_eq!(animation.delay, 0.0);\n    assert_eq!(animation.easing, SubtitleEasing::EaseInOut);\n    assert!(!animation.id.is_empty());\n  }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":52}},{"line":42,"address":[],"length":0,"stats":{"Line":52}},{"line":43,"address":[],"length":0,"stats":{"Line":52}},{"line":50,"address":[],"length":0,"stats":{"Line":52}},{"line":51,"address":[],"length":0,"stats":{"Line":52}},{"line":52,"address":[],"length":0,"stats":{"Line":52}},{"line":53,"address":[],"length":0,"stats":{"Line":52}},{"line":54,"address":[],"length":0,"stats":{"Line":52}},{"line":55,"address":[],"length":0,"stats":{"Line":52}},{"line":56,"address":[],"length":0,"stats":{"Line":52}},{"line":57,"address":[],"length":0,"stats":{"Line":52}},{"line":58,"address":[],"length":0,"stats":{"Line":52}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":65,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":27}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":9}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":104,"address":[],"length":0,"stats":{"Line":7}},{"line":105,"address":[],"length":0,"stats":{"Line":7}},{"line":106,"address":[],"length":0,"stats":{"Line":7}},{"line":108,"address":[],"length":0,"stats":{"Line":15}},{"line":109,"address":[],"length":0,"stats":{"Line":15}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":52}},{"line":154,"address":[],"length":0,"stats":{"Line":52}},{"line":197,"address":[],"length":0,"stats":{"Line":28}},{"line":199,"address":[],"length":0,"stats":{"Line":28}},{"line":205,"address":[],"length":0,"stats":{"Line":28}},{"line":206,"address":[],"length":0,"stats":{"Line":28}},{"line":207,"address":[],"length":0,"stats":{"Line":28}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":27}},{"line":295,"address":[],"length":0,"stats":{"Line":27}},{"line":298,"address":[],"length":0,"stats":{"Line":27}},{"line":304,"address":[],"length":0,"stats":{"Line":27}},{"line":305,"address":[],"length":0,"stats":{"Line":27}},{"line":309,"address":[],"length":0,"stats":{"Line":27}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":4}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":13}},{"line":353,"address":[],"length":0,"stats":{"Line":13}},{"line":407,"address":[],"length":0,"stats":{"Line":18}},{"line":409,"address":[],"length":0,"stats":{"Line":18}},{"line":414,"address":[],"length":0,"stats":{"Line":18}},{"line":418,"address":[],"length":0,"stats":{"Line":18}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":52}},{"line":1416,"address":[],"length":0,"stats":{"Line":52}},{"line":1447,"address":[],"length":0,"stats":{"Line":52}},{"line":1449,"address":[],"length":0,"stats":{"Line":52}},{"line":1488,"address":[],"length":0,"stats":{"Line":2}},{"line":1490,"address":[],"length":0,"stats":{"Line":2}},{"line":1494,"address":[],"length":0,"stats":{"Line":2}},{"line":1495,"address":[],"length":0,"stats":{"Line":2}},{"line":1497,"address":[],"length":0,"stats":{"Line":2}},{"line":1502,"address":[],"length":0,"stats":{"Line":4}},{"line":1503,"address":[],"length":0,"stats":{"Line":4}},{"line":1504,"address":[],"length":0,"stats":{"Line":1}},{"line":1507,"address":[],"length":0,"stats":{"Line":3}},{"line":1508,"address":[],"length":0,"stats":{"Line":1}},{"line":1511,"address":[],"length":0,"stats":{"Line":2}},{"line":1512,"address":[],"length":0,"stats":{"Line":1}},{"line":1515,"address":[],"length":0,"stats":{"Line":1}},{"line":1519,"address":[],"length":0,"stats":{"Line":1}},{"line":1520,"address":[],"length":0,"stats":{"Line":1}},{"line":1540,"address":[],"length":0,"stats":{"Line":3}},{"line":1546,"address":[],"length":0,"stats":{"Line":3}},{"line":1587,"address":[],"length":0,"stats":{"Line":3}},{"line":1637,"address":[],"length":0,"stats":{"Line":3}},{"line":1639,"address":[],"length":0,"stats":{"Line":3}},{"line":1642,"address":[],"length":0,"stats":{"Line":3}},{"line":1643,"address":[],"length":0,"stats":{"Line":3}},{"line":1645,"address":[],"length":0,"stats":{"Line":3}},{"line":1651,"address":[],"length":0,"stats":{"Line":3}},{"line":1691,"address":[],"length":0,"stats":{"Line":3}},{"line":1722,"address":[],"length":0,"stats":{"Line":1}},{"line":1724,"address":[],"length":0,"stats":{"Line":1}},{"line":1730,"address":[],"length":0,"stats":{"Line":1}}],"covered":95,"coverable":133},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_compiler","test_integration.rs"],"content":"//! Интеграционные тесты для Video Compiler\n\n#[cfg(test)]\nmod tests {\n  use crate::video_compiler::{\n    cache::RenderCache,\n    initialize,\n    renderer::VideoRenderer,\n    schema::{Clip, ProjectSchema, Timeline, Track, TrackType},\n    CompilerSettings,\n  };\n  use std::path::PathBuf;\n  use std::sync::Arc;\n  use tokio::sync::{mpsc, RwLock};\n\n  /// Создать тестовый проект с видео клипами\n  fn create_test_project() -\u003e ProjectSchema {\n    let mut project = ProjectSchema::new(\"Test Video Project\".to_string());\n\n    // Настройки timeline\n    project.timeline = Timeline {\n      duration: 10.0,\n      fps: 30,\n      resolution: (1920, 1080),\n      sample_rate: 48000,\n      aspect_ratio: crate::video_compiler::schema::AspectRatio::Ratio16x9,\n    };\n\n    // Создаем видео трек\n    let mut video_track = Track::new(TrackType::Video, \"Main Video\".to_string());\n\n    // Добавляем тестовые клипы (используем существующие медиа файлы из public)\n    // Используем относительные пути от корня проекта\n    let project_root = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n\n    let clip1 = Clip::new(project_root.join(\"public\").join(\"t1.mp4\"), 0.0, 5.0);\n\n    let mut clip2 = Clip::new(project_root.join(\"public\").join(\"t2.mp4\"), 5.0, 5.0);\n    clip2.end_time = 10.0; // Устанавливаем правильное время окончания\n\n    video_track.clips.push(clip1);\n    video_track.clips.push(clip2);\n\n    project.tracks.push(video_track);\n\n    project\n  }\n\n  #[tokio::test]\n  async fn test_full_video_compilation() {\n    // Инициализируем Video Compiler\n    let state = match initialize().await {\n      Ok(state) =\u003e state,\n      Err(e) =\u003e {\n        eprintln!(\"Пропуск теста: Video Compiler не инициализирован: {}\", e);\n        return;\n      }\n    };\n\n    // Создаем тестовый проект\n    let project = create_test_project();\n\n    // Создаем канал для прогресса\n    let (progress_sender, mut progress_receiver) = mpsc::unbounded_channel();\n\n    // Создаем VideoRenderer\n    let mut renderer = match VideoRenderer::new(\n      project.clone(),\n      state.settings.clone(),\n      state.cache_manager.clone(),\n      progress_sender,\n    )\n    .await\n    {\n      Ok(renderer) =\u003e renderer,\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось создать VideoRenderer: {}\", e);\n        return;\n      }\n    };\n\n    // Определяем выходной путь\n    let output_path = std::env::temp_dir()\n      .join(\"timeline-studio-test\")\n      .join(\"test_output.mp4\");\n\n    // Создаем директорию если не существует\n    if let Some(parent) = output_path.parent() {\n      let _ = tokio::fs::create_dir_all(parent).await;\n    }\n\n    // Запускаем рендеринг\n    match renderer.render(\u0026output_path).await {\n      Ok(job_id) =\u003e {\n        println!(\"Рендеринг запущен с job_id: {}\", job_id);\n\n        // Отслеживаем прогресс\n        let mut last_progress = 0u64;\n        while let Some(update) = progress_receiver.recv().await {\n          use crate::video_compiler::progress::ProgressUpdate;\n\n          match update {\n            ProgressUpdate::ProgressChanged { progress, .. } =\u003e {\n              if progress.current_frame \u003e last_progress {\n                println!(\n                  \"Прогресс: {} кадров из {}, стадия: {}\",\n                  progress.current_frame, progress.total_frames, progress.stage\n                );\n                last_progress = progress.current_frame;\n              }\n            }\n            ProgressUpdate::JobCompleted { output_path, .. } =\u003e {\n              println!(\"Рендеринг завершен! Файл: {}\", output_path);\n\n              // Проверяем что файл создан\n              let path = PathBuf::from(\u0026output_path);\n              assert!(path.exists(), \"Выходной файл должен существовать\");\n\n              // Проверяем размер файла\n              let metadata = tokio::fs::metadata(\u0026path).await.unwrap();\n              assert!(metadata.len() \u003e 0, \"Файл не должен быть пустым\");\n\n              println!(\"Размер файла: {} байт\", metadata.len());\n\n              // Очищаем тестовый файл\n              let _ = tokio::fs::remove_file(\u0026path).await;\n              break;\n            }\n            ProgressUpdate::JobFailed { error, .. } =\u003e {\n              panic!(\"Рендеринг не удался: {}\", error);\n            }\n            _ =\u003e {}\n          }\n        }\n      }\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось запустить рендеринг: {}\", e);\n      }\n    }\n  }\n\n  #[tokio::test]\n  async fn test_invalid_project_validation() {\n    // Создаем проект с несуществующими файлами\n    let mut project = ProjectSchema::new(\"Invalid Project\".to_string());\n    let mut track = Track::new(TrackType::Video, \"Invalid Track\".to_string());\n\n    let invalid_clip = Clip::new(PathBuf::from(\"/non/existent/file.mp4\"), 0.0, 5.0);\n\n    track.clips.push(invalid_clip);\n    project.tracks.push(track);\n\n    // Сначала проверяем что проект не валиден\n    let validation_result = project.validate();\n    assert!(validation_result.is_err());\n    assert!(validation_result\n      .unwrap_err()\n      .contains(\"Исходный файл не найден\"));\n\n    // Создаем канал для прогресса\n    let (progress_sender, _) = mpsc::unbounded_channel();\n\n    // Пытаемся создать VideoRenderer\n    let settings = Arc::new(RwLock::new(CompilerSettings::default()));\n    let cache = Arc::new(RwLock::new(RenderCache::new()));\n\n    let result = VideoRenderer::new(project, settings, cache, progress_sender).await;\n\n    // VideoRenderer должен провалиться на валидации\n    assert!(result.is_err());\n    if let Err(e) = result {\n      println!(\"Ожидаемая ошибка валидации: {}\", e);\n    }\n  }\n\n  #[tokio::test]\n  async fn test_render_cancellation() {\n    // Инициализируем Video Compiler\n    let state = match initialize().await {\n      Ok(state) =\u003e state,\n      Err(e) =\u003e {\n        eprintln!(\"Пропуск теста: Video Compiler не инициализирован: {}\", e);\n        return;\n      }\n    };\n\n    // Создаем простой проект\n    let mut project = ProjectSchema::new(\"Cancellation Test\".to_string());\n    project.timeline.duration = 5.0;\n\n    // Создаем канал для прогресса\n    let (progress_sender, _progress_receiver) = mpsc::unbounded_channel();\n\n    // Создаем VideoRenderer\n    let mut renderer = match VideoRenderer::new(\n      project,\n      state.settings.clone(),\n      state.cache_manager.clone(),\n      progress_sender,\n    )\n    .await\n    {\n      Ok(renderer) =\u003e renderer,\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось создать VideoRenderer: {}\", e);\n        return;\n      }\n    };\n\n    // Запускаем рендеринг\n    let output_path = std::env::temp_dir()\n      .join(\"timeline-studio-test\")\n      .join(\"test_cancel.mp4\");\n\n    let _job_id = match renderer.render(\u0026output_path).await {\n      Ok(id) =\u003e id,\n      Err(e) =\u003e {\n        eprintln!(\"Не удалось запустить рендеринг: {}\", e);\n        return;\n      }\n    };\n\n    // Даем время на старт рендеринга\n    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n    // Отменяем рендеринг\n    assert!(renderer.cancel().await.is_ok());\n\n    // Проверяем, что задача отменена\n    let progress = renderer.get_progress().await;\n    assert!(\n      progress.is_none()\n        || matches!(\n          progress.unwrap().status,\n          crate::video_compiler::progress::RenderStatus::Cancelled\n        )\n    );\n  }\n\n  #[tokio::test]\n  async fn test_multiple_tracks_composition() {\n    // Создаем проект с несколькими треками\n    let mut project = ProjectSchema::new(\"Multi-track Project\".to_string());\n    project.timeline.duration = 10.0;\n\n    let project_root = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n\n    // Видео трек 1\n    let mut video_track1 = Track::new(TrackType::Video, \"Video Track 1\".to_string());\n    video_track1.clips.push(Clip::new(\n      project_root.join(\"public\").join(\"t1.mp4\"),\n      0.0,\n      5.0,\n    ));\n\n    // Видео трек 2 (наложение)\n    let mut video_track2 = Track::new(TrackType::Video, \"Video Track 2\".to_string());\n    let mut overlay_clip = Clip::new(project_root.join(\"public\").join(\"t2.mp4\"), 2.0, 3.0);\n    overlay_clip.end_time = 5.0;\n    video_track2.clips.push(overlay_clip);\n\n    project.tracks.push(video_track1);\n    project.tracks.push(video_track2);\n\n    // Валидация проекта\n    match project.validate() {\n      Ok(_) =\u003e println!(\"Проект с несколькими треками валиден\"),\n      Err(e) =\u003e {\n        eprintln!(\"Ошибка валидации: {}\", e);\n        return;\n      }\n    }\n  }\n\n  #[tokio::test]\n  async fn test_empty_project_handling() {\n    // Создаем пустой проект\n    let project = ProjectSchema::new(\"Empty Project\".to_string());\n\n    // Проверяем, что пустой проект проходит валидацию\n    assert!(project.validate().is_ok());\n\n    // Проверяем, что длительность = 0\n    assert_eq!(project.get_duration(), 0.0);\n  }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_server","mod.rs"],"content":"pub mod server;\npub mod tests;\n\npub use server::{VideoServerState, VideoRegistrationResponse, start_video_server};","traces":[],"covered":0,"coverable":0},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_server","server.rs"],"content":"use std::path::PathBuf;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse std::collections::HashMap;\nuse axum::{\n    Router,\n    routing::get,\n    extract::{Path, Query, State},\n    response::{IntoResponse, Response},\n    http::{StatusCode, header, HeaderMap},\n};\nuse tokio::fs::File;\nuse tokio::io::{AsyncSeekExt, AsyncReadExt};\nuse tokio_util::io::ReaderStream;\nuse serde::Serialize;\nuse tower_http::cors::{CorsLayer, Any};\n\n#[derive(Clone)]\npub struct VideoServerState {\n    // Map video ID to actual file path\n    pub(crate) video_registry: Arc\u003cMutex\u003cHashMap\u003cString, PathBuf\u003e\u003e\u003e,\n}\n\n#[derive(Serialize)]\npub struct VideoRegistrationResponse {\n    pub id: String,\n    pub url: String,\n}\n\nimpl VideoServerState {\n    pub fn new() -\u003e Self {\n        Self {\n            video_registry: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub async fn register_video(\u0026self, path: PathBuf) -\u003e String {\n        // Generate unique ID for video\n        let id = format!(\"{:x}\", md5::compute(path.to_string_lossy().as_bytes()));\n        \n        let mut registry = self.video_registry.lock().await;\n        registry.insert(id.clone(), path);\n        \n        id\n    }\n}\n\npub fn create_video_router(state: VideoServerState) -\u003e Router {\n    Router::new()\n        .route(\"/video/:id\", get(stream_video))\n        .route(\"/register\", get(register_video_endpoint))\n        .route(\"/health\", get(health_check))\n        .layer(\n            CorsLayer::new()\n                .allow_origin(Any)\n                .allow_methods(Any)\n                .allow_headers(Any)\n        )\n        .with_state(state)\n}\n\nasync fn health_check() -\u003e impl IntoResponse {\n    (StatusCode::OK, \"Video server is running\")\n}\n\nasync fn stream_video(\n    Path(id): Path\u003cString\u003e,\n    headers: HeaderMap,\n    State(state): State\u003cVideoServerState\u003e,\n) -\u003e Result\u003cResponse, StatusCode\u003e {\n    let registry = state.video_registry.lock().await;\n    let path = registry.get(\u0026id).ok_or(StatusCode::NOT_FOUND)?;\n    \n    let mut file = File::open(path).await.map_err(|_| StatusCode::NOT_FOUND)?;\n    let metadata = file.metadata().await.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n    let file_size = metadata.len();\n    \n    // Determine content type based on file extension\n    let content_type = match path.extension().and_then(|ext| ext.to_str()) {\n        Some(\"mp4\") =\u003e \"video/mp4\",\n        Some(\"webm\") =\u003e \"video/webm\",\n        Some(\"mov\") =\u003e \"video/quicktime\",\n        Some(\"avi\") =\u003e \"video/x-msvideo\",\n        Some(\"mkv\") =\u003e \"video/x-matroska\",\n        _ =\u003e \"video/mp4\", // default\n    };\n    \n    // Parse Range header\n    if let Some(range_header) = headers.get(header::RANGE) {\n        let range_str = range_header.to_str().map_err(|_| StatusCode::BAD_REQUEST)?;\n        if let Some(range) = parse_range_header(range_str, file_size) {\n            let (start, end) = range;\n            \n            // Seek to start position\n            file.seek(std::io::SeekFrom::Start(start)).await\n                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n            \n            // Create limited reader for the range\n            let limited = file.take(end - start + 1);\n            let stream = ReaderStream::new(limited);\n            \n            return Ok(Response::builder()\n                .status(StatusCode::PARTIAL_CONTENT)\n                .header(header::CONTENT_TYPE, content_type)\n                .header(header::ACCEPT_RANGES, \"bytes\")\n                .header(header::CONTENT_LENGTH, (end - start + 1).to_string())\n                .header(header::CONTENT_RANGE, format!(\"bytes {}-{}/{}\", start, end, file_size))\n                .body(axum::body::Body::from_stream(stream))\n                .unwrap());\n        }\n    }\n    \n    // No range header, return entire file\n    let stream = ReaderStream::new(file);\n    \n    Ok(Response::builder()\n        .status(StatusCode::OK)\n        .header(header::CONTENT_TYPE, content_type)\n        .header(header::ACCEPT_RANGES, \"bytes\")\n        .header(header::CONTENT_LENGTH, file_size.to_string())\n        .body(axum::body::Body::from_stream(stream))\n        .unwrap())\n}\n\npub(crate) fn parse_range_header(range: \u0026str, file_size: u64) -\u003e Option\u003c(u64, u64)\u003e {\n    if let Some(range) = range.strip_prefix(\"bytes=\") {\n        let parts: Vec\u003c\u0026str\u003e = range.split('-').collect();\n        if parts.len() == 2 {\n            let start = parts[0].parse::\u003cu64\u003e().ok()?;\n            let end = if parts[1].is_empty() {\n                file_size - 1\n            } else {\n                parts[1].parse::\u003cu64\u003e().ok()?.min(file_size - 1)\n            };\n            return Some((start, end));\n        }\n    }\n    None\n}\n\nasync fn register_video_endpoint(\n    Query(params): Query\u003cHashMap\u003cString, String\u003e\u003e,\n    State(state): State\u003cVideoServerState\u003e,\n) -\u003e Result\u003cimpl IntoResponse, StatusCode\u003e {\n    let path = params.get(\"path\").ok_or(StatusCode::BAD_REQUEST)?;\n    let path = PathBuf::from(path);\n    \n    if !path.exists() {\n        return Err(StatusCode::NOT_FOUND);\n    }\n    \n    let id = state.register_video(path).await;\n    \n    Ok(axum::Json(VideoRegistrationResponse {\n        id: id.clone(),\n        url: format!(\"http://localhost:4567/video/{}\", id),\n    }))\n}\n\n// Start server function to be called from main.rs\npub async fn start_video_server(state: VideoServerState) {\n    let app = create_video_router(state);\n    \n    match tokio::net::TcpListener::bind(\"127.0.0.1:4567\").await {\n        Ok(listener) =\u003e {\n            log::info!(\"Video server listening on http://localhost:4567\");\n            if let Err(e) = axum::serve(listener, app).await {\n                log::error!(\"Video server error: {}\", e);\n            }\n        }\n        Err(e) =\u003e {\n            log::error!(\"Failed to bind video server: {}\", e);\n        }\n    }\n}","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":8}},{"line":50,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":7}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}}],"covered":56,"coverable":74},{"path":["/","Users","aleksandrkireev","Apps","timeline-studio","src-tauri","src","video_server","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use super::super::*;\n    use axum::http::{Request, StatusCode};\n    use axum::body::Body;\n    use tower::ServiceExt;\n    use std::path::PathBuf;\n    use tempfile::NamedTempFile;\n    use std::io::Write;\n\n    #[tokio::test]\n    async fn test_video_server_state_new() {\n        let state = VideoServerState::new();\n        let registry = state.video_registry.lock().await;\n        assert!(registry.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_register_video() {\n        let state = VideoServerState::new();\n        let path = PathBuf::from(\"/test/video.mp4\");\n        \n        let id = state.register_video(path.clone()).await;\n        \n        assert!(!id.is_empty());\n        \n        let registry = state.video_registry.lock().await;\n        assert_eq!(registry.get(\u0026id), Some(\u0026path));\n    }\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/health\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[tokio::test]\n    async fn test_register_video_endpoint() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        // Create a temporary file\n        let temp_file = NamedTempFile::new().unwrap();\n        let path = temp_file.path().to_str().unwrap();\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\u0026format!(\"/register?path={}\", urlencoding::encode(path)))\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[tokio::test]\n    async fn test_register_video_endpoint_missing_path() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/register\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    }\n\n    #[tokio::test]\n    async fn test_register_video_endpoint_nonexistent_file() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/register?path=/nonexistent/file.mp4\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[tokio::test]\n    async fn test_stream_video_not_found() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/video/nonexistent\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[tokio::test]\n    async fn test_stream_video_with_range() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state.clone());\n        \n        // Create a temporary file with content\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(b\"test video content\").unwrap();\n        let path = temp_file.path().to_path_buf();\n        \n        // Register the video\n        let id = state.register_video(path).await;\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\u0026format!(\"/video/{}\", id))\n                    .header(\"Range\", \"bytes=0-9\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::PARTIAL_CONTENT);\n        assert_eq!(\n            response.headers().get(\"content-range\").unwrap(),\n            \"bytes 0-9/18\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_parse_range_header() {\n        assert_eq!(\n            server::parse_range_header(\"bytes=0-99\", 1000),\n            Some((0, 99))\n        );\n        \n        assert_eq!(\n            server::parse_range_header(\"bytes=50-\", 1000),\n            Some((50, 999))\n        );\n        \n        assert_eq!(\n            server::parse_range_header(\"invalid\", 1000),\n            None\n        );\n    }\n\n    #[tokio::test]\n    async fn test_video_registration_response_serialization() {\n        let response = VideoRegistrationResponse {\n            id: \"test123\".to_string(),\n            url: \"http://localhost:4567/video/test123\".to_string(),\n        };\n        \n        let json = serde_json::to_string(\u0026response).unwrap();\n        assert!(json.contains(\"test123\"));\n        assert!(json.contains(\"http://localhost:4567/video/test123\"));\n    }\n\n    #[tokio::test]\n    async fn test_cors_headers() {\n        let state = VideoServerState::new();\n        let app = server::create_video_router(state);\n        \n        let response = app\n            .oneshot(\n                Request::builder()\n                    .uri(\"/health\")\n                    .header(\"Origin\", \"http://localhost:3000\")\n                    .body(Body::empty())\n                    .unwrap()\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n        // CORS headers should be present due to CorsLayer::new().allow_origin(Any)\n        assert!(response.headers().contains_key(\"access-control-allow-origin\"));\n    }\n}","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>