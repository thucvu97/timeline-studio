# –ü–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö –≤ Timeline Studio

[‚Üê –ù–∞–∑–∞–¥ –∫ —Ä–∞–∑–¥–µ–ª—É](README.md) | [‚Üê –ö –æ–≥–ª–∞–≤–ª–µ–Ω–∏—é](../README.md)

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

- [–û–±–∑–æ—Ä –ø–æ—Ç–æ–∫–∞ –¥–∞–Ω–Ω—ã—Ö](#–æ–±–∑–æ—Ä-–ø–æ—Ç–æ–∫–∞-–¥–∞–Ω–Ω—ã—Ö)
- [–ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–µ–∫—Ç–∞](#–∂–∏–∑–Ω–µ–Ω–Ω—ã–π-—Ü–∏–∫–ª-–ø—Ä–æ–µ–∫—Ç–∞)
- [–û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤](#–æ–±—Ä–∞–±–æ—Ç–∫–∞-–º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤)
- [–°–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–∞–π–º–ª–∞–π–Ω–∞](#—Å–æ—Å—Ç–æ—è–Ω–∏–µ-—Ç–∞–π–º–ª–∞–π–Ω–∞)
- [–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∏ —ç–∫—Å–ø–æ—Ä—Ç](#—Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥-–∏-—ç–∫—Å–ø–æ—Ä—Ç)
- [–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è](#—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è-—Å–æ—Å—Ç–æ—è–Ω–∏—è)

## üåä –û–±–∑–æ—Ä –ø–æ—Ç–æ–∫–∞ –¥–∞–Ω–Ω—ã—Ö

Timeline Studio –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–¥–Ω–æ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö —Å —á–µ—Ç–∫–∏–º —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –º–µ–∂–¥—É —Å–ª–æ—è–º–∏:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   UI Layer  ‚îÇ ‚îÄ‚îÄ> ‚îÇ State Layer  ‚îÇ ‚îÄ‚îÄ> ‚îÇ Data Layer  ‚îÇ
‚îÇ   (React)   ‚îÇ <‚îÄ‚îÄ ‚îÇ   (XState)   ‚îÇ <‚îÄ‚îÄ ‚îÇ   (Rust)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ≤                                           ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Events/Updates ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üìÇ –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–µ–∫—Ç–∞

### 1. –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞

```typescript
// Frontend: –ò–Ω–∏—Ü–∏–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è
const createProject = async (settings: ProjectSettings) => {
  // 1. –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ frontend
  const validated = validateProjectSettings(settings)
  
  // 2. –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã –≤ backend
  const project = await invoke('create_project', { settings: validated })
  
  // 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
  projectMachine.send({ 
    type: 'PROJECT_CREATED', 
    project 
  })
  
  // 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥—Å–∏—Å—Ç–µ–º
  await initializeTimeline(project.id)
  await initializeResources(project.id)
}
```

```rust
// Backend: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è
#[tauri::command]
async fn create_project(settings: ProjectSettings) -> Result<Project> {
    // 1. –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø—Ä–æ–µ–∫—Ç–∞
    let project_id = Uuid::new_v4();
    let project_dir = get_projects_dir().join(&project_id.to_string());
    fs::create_dir_all(&project_dir)?;
    
    // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–∞
    let db_path = project_dir.join("project.db");
    let pool = create_project_database(&db_path).await?;
    
    // 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫
    let project = Project {
        id: project_id,
        name: settings.name,
        created_at: Utc::now(),
        settings,
        media_files: Vec::new(),
        timeline: Timeline::default(),
    };
    
    save_project_metadata(&pool, &project).await?;
    
    Ok(project)
}
```

### 2. –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞

```mermaid
sequenceDiagram
    participant UI
    participant State
    participant Backend
    participant FS
    
    UI->>State: LOAD_PROJECT
    State->>Backend: invoke('load_project')
    Backend->>FS: Read project files
    FS-->>Backend: Project data
    Backend->>Backend: Verify media paths
    Backend-->>State: Project + Media
    State->>State: Update machines
    State-->>UI: Render UI
```

## üé¨ –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤

### –ò–º–ø–æ—Ä—Ç –º–µ–¥–∏–∞

```typescript
// Frontend: –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∏–º–ø–æ—Ä—Ç–∞
export function MediaImporter() {
  const { importFiles } = useMediaImport()
  
  const handleDrop = async (files: File[]) => {
    // 1. –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—É—Ç–µ–π –∫ —Ñ–∞–π–ª–∞–º
    const paths = files.map(f => f.path)
    
    // 2. –ó–∞–ø—É—Å–∫ –∏–º–ø–æ—Ä—Ç–∞ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
    const imported = await importFiles(paths)
    
    // 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±—Ä–∞—É–∑–µ—Ä–∞ –º–µ–¥–∏–∞
    mediaBrowser.send({ 
      type: 'FILES_ADDED', 
      files: imported 
    })
  }
}

// Hook –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞
function useMediaImport() {
  const importFiles = async (paths: string[]) => {
    const results = []
    
    for (const path of paths) {
      // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
      results.push(
        invoke('import_media_file', { path })
      )
    }
    
    return Promise.all(results)
  }
  
  return { importFiles }
}
```

```rust
// Backend: –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞
#[tauri::command]
async fn import_media_file(
    path: String,
    state: State<'_, AppState>
) -> Result<MediaFile> {
    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–∞
    let metadata = extract_media_metadata(&path).await?;
    
    // 2. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–≤—å—é
    let thumbnail = generate_thumbnail(&path, &metadata).await?;
    
    // 3. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –º–µ–¥–∏–∞ –ø–∞–ø–∫—É –ø—Ä–æ–µ–∫—Ç–∞
    let media_path = copy_to_project_media(&path, &state.current_project).await?;
    
    // 4. –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
    let media_file = MediaFile {
        id: Uuid::new_v4(),
        original_path: path,
        project_path: media_path,
        metadata,
        thumbnail,
        imported_at: Utc::now(),
    };
    
    // 5. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
    save_media_file(&state.db, &media_file).await?;
    
    // 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞
    state.media_cache.insert(media_file.id, media_file.clone()).await;
    
    Ok(media_file)
}
```

### –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–≤—å—é

```rust
// –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–≤—å—é
pub async fn generate_previews(files: Vec<MediaFile>) -> Vec<Preview> {
    use rayon::prelude::*;
    
    files
        .par_iter()
        .map(|file| {
            match file.media_type {
                MediaType::Video => generate_video_preview(file),
                MediaType::Audio => generate_waveform(file),
                MediaType::Image => generate_image_thumbnail(file),
            }
        })
        .collect()
}

async fn generate_video_preview(file: &MediaFile) -> Preview {
    // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö –∫–∞–¥—Ä–æ–≤
    let keyframes = extract_keyframes(&file.path, 10).await?;
    
    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ø—Ä–∞–π—Ç–∞ –ø—Ä–µ–≤—å—é
    let sprite = create_preview_sprite(keyframes).await?;
    
    Preview {
        file_id: file.id,
        sprite_path: sprite,
        frame_count: keyframes.len(),
    }
}
```

## üìê –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–∞–π–º–ª–∞–π–Ω–∞

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–∞–π–º–ª–∞–π–Ω–∞

```typescript
// types/timeline.ts
interface Timeline {
  id: string
  tracks: Track[]
  duration: number
  playhead: number
  zoom: number
  selection: Selection | null
}

interface Track {
  id: string
  type: 'video' | 'audio' | 'text'
  clips: Clip[]
  height: number
  muted: boolean
  locked: boolean
}

interface Clip {
  id: string
  mediaId: string
  trackId: string
  startTime: number
  duration: number
  inPoint: number
  outPoint: number
  effects: Effect[]
  transitions: Transition[]
}
```

### XState –º–∞—à–∏–Ω–∞ —Ç–∞–π–º–ª–∞–π–Ω–∞

```typescript
// services/timeline-machine.ts
export const timelineMachine = setup({
  types: {} as {
    context: TimelineContext
    events: TimelineEvent
  },
  guards: {
    canAddClip: ({ context, event }) => {
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
      return !hasOverlap(context.clips, event.clip)
    },
    canSplitClip: ({ context }) => {
      return context.selectedClip !== null
    }
  },
  actions: {
    addClipToTimeline: assign({
      clips: ({ context, event }) => {
        const newClip = createClip(event.media, event.position)
        return [...context.clips, newClip]
      }
    }),
    updatePlayhead: assign({
      playhead: ({ event }) => event.position
    }),
    applyEffect: assign({
      clips: ({ context, event }) => {
        return context.clips.map(clip =>
          clip.id === event.clipId
            ? { ...clip, effects: [...clip.effects, event.effect] }
            : clip
        )
      }
    })
  }
}).createMachine({
  id: 'timeline',
  initial: 'idle',
  context: {
    clips: [],
    tracks: [],
    playhead: 0,
    zoom: 1,
    selection: null
  },
  states: {
    idle: {
      on: {
        DRAG_START: 'dragging',
        PLAY: 'playing',
        SELECT_CLIP: {
          actions: assign({
            selection: ({ event }) => ({
              type: 'clip',
              id: event.clipId
            })
          })
        }
      }
    },
    dragging: {
      on: {
        DRAG_MOVE: {
          actions: 'updateDragPosition'
        },
        DRAG_END: {
          target: 'idle',
          actions: 'finalizeDrag'
        }
      }
    },
    playing: {
      invoke: {
        src: 'playbackService',
        onSnapshot: {
          actions: 'updatePlayhead'
        }
      },
      on: {
        PAUSE: 'idle',
        STOP: {
          target: 'idle',
          actions: assign({ playhead: 0 })
        }
      }
    }
  }
})
```

### –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –≤–∏–¥–µ–æ –ø–ª–µ–µ—Ä–æ–º

```typescript
// hooks/useTimelineSync.ts
export function useTimelineSync() {
  const video = useVideoPlayer()
  const timeline = useTimeline()
  
  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ–∑–∏—Ü–∏–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
  useEffect(() => {
    const interval = setInterval(() => {
      if (video.isPlaying) {
        timeline.send({
          type: 'UPDATE_PLAYHEAD',
          position: video.currentTime
        })
      }
    }, 16) // ~60fps
    
    return () => clearInterval(interval)
  }, [video.isPlaying])
  
  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è seek –æ–ø–µ—Ä–∞—Ü–∏–π
  const handleTimelineSeek = (position: number) => {
    video.seek(position)
    timeline.send({
      type: 'UPDATE_PLAYHEAD',
      position
    })
  }
  
  return { handleTimelineSeek }
}
```

## üé® –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∏ —ç–∫—Å–ø–æ—Ä—Ç

### –ü—Ä–æ—Ü–µ—Å—Å —ç–∫—Å–ø–æ—Ä—Ç–∞

```typescript
// Frontend: –ò–Ω–∏—Ü–∏–∞—Ü–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∞
async function exportVideo(settings: ExportSettings) {
  // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–∞–π–º–ª–∞–π–Ω–∞
  const timelineData = serializeTimeline(timeline)
  
  // 2. –ó–∞–ø—É—Å–∫ —ç–∫—Å–ø–æ—Ä—Ç–∞
  const exportId = await invoke('start_export', {
    timeline: timelineData,
    settings
  })
  
  // 3. –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
  const unlisten = await listen(`export-progress-${exportId}`, (event) => {
    updateProgress(event.payload)
  })
  
  // 4. –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
  const result = await invoke('wait_export', { exportId })
  unlisten()
  
  return result
}
```

```rust
// Backend: –ü—Ä–æ—Ü–µ—Å—Å —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
pub async fn render_timeline(
    timeline: Timeline,
    settings: ExportSettings,
    progress_tx: Sender<RenderProgress>,
) -> Result<String> {
    // 1. –°–æ–∑–¥–∞–Ω–∏–µ render graph
    let graph = build_render_graph(&timeline)?;
    
    // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è FFmpeg
    let mut encoder = VideoEncoder::new(&settings);
    
    // 3. –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –ø–æ –∫–∞–¥—Ä–∞–º
    let total_frames = calculate_total_frames(&timeline, &settings);
    
    for frame_num in 0..total_frames {
        // –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∫–∞–¥—Ä–∞
        let frame = compose_frame(&graph, frame_num).await?;
        
        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        let processed = apply_frame_effects(frame, &timeline.global_effects);
        
        // –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
        encoder.encode_frame(processed)?;
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        progress_tx.send(RenderProgress {
            current: frame_num,
            total: total_frames,
            fps: encoder.current_fps(),
        }).await?;
    }
    
    // 4. –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è
    let output_path = encoder.finalize()?;
    Ok(output_path)
}
```

### –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∫–∞–¥—Ä–∞

```rust
async fn compose_frame(
    graph: &RenderGraph,
    frame_num: u32
) -> Result<Frame> {
    let mut compositor = FrameCompositor::new();
    
    // –û–±—Ö–æ–¥ –≥—Ä–∞—Ñ–∞ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö (–ø–æ —Ç—Ä–µ–∫–∞–º)
    for track in graph.tracks.iter().rev() {
        for node in track.nodes_at_frame(frame_num) {
            match node {
                RenderNode::Clip(clip) => {
                    let frame = extract_clip_frame(clip, frame_num)?;
                    compositor.add_layer(frame, clip.blend_mode);
                }
                RenderNode::Transition(transition) => {
                    let frames = extract_transition_frames(transition, frame_num)?;
                    compositor.add_transition(frames, transition.type);
                }
                RenderNode::Text(text) => {
                    let rendered = render_text(text, frame_num)?;
                    compositor.add_overlay(rendered);
                }
            }
        }
    }
    
    Ok(compositor.finalize())
}
```

## üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è

### –û–ø—Ç–∏–º–∏—Å—Ç–∏—á–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

```typescript
// –û–ø—Ç–∏–º–∏—Å—Ç–∏—á–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å –æ—Ç–∫–∞—Ç–æ–º
async function updateClipEffect(clipId: string, effect: Effect) {
  // 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  const previousState = timeline.getSnapshot()
  
  // 2. –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ
  timeline.send({
    type: 'APPLY_EFFECT',
    clipId,
    effect
  })
  
  try {
    // 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ backend
    await invoke('update_clip_effect', { clipId, effect })
  } catch (error) {
    // 4. –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –ø—Ä–∏ –æ—à–∏–±–∫–µ
    timeline.send({
      type: 'RESTORE_STATE',
      state: previousState
    })
    throw error
  }
}
```

### –î–µ–±–∞—É–Ω—Å –∏ –±–∞—Ç—á–∏–Ω–≥

```typescript
// –ë–∞—Ç—á–∏–Ω–≥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –ø–æ–∑–∏—Ü–∏–∏
const positionUpdates = useDebouncedBatch<PositionUpdate>(
  async (updates) => {
    await invoke('batch_update_positions', { updates })
  },
  100 // 100ms –¥–µ–±–∞—É–Ω—Å
)

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
function handleClipMove(clipId: string, newPosition: number) {
  // –õ–æ–∫–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
  updateClipPosition(clipId, newPosition)
  
  // –ë–∞—Ç—á–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ backend
  positionUpdates.add({ clipId, position: newPosition })
}
```

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

```typescript
// –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric> = new Map()
  
  async measure<T>(name: string, operation: () => Promise<T>): Promise<T> {
    const start = performance.now()
    
    try {
      const result = await operation()
      const duration = performance.now() - start
      
      this.recordMetric(name, duration, 'success')
      return result
    } catch (error) {
      const duration = performance.now() - start
      this.recordMetric(name, duration, 'error')
      throw error
    }
  }
  
  private recordMetric(name: string, duration: number, status: string) {
    const metric = this.metrics.get(name) || {
      count: 0,
      totalDuration: 0,
      averageDuration: 0,
      maxDuration: 0
    }
    
    metric.count++
    metric.totalDuration += duration
    metric.averageDuration = metric.totalDuration / metric.count
    metric.maxDuration = Math.max(metric.maxDuration, duration)
    
    this.metrics.set(name, metric)
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –º–µ—Ç—Ä–∏–∫ –≤ –∞–Ω–∞–ª–∏—Ç–∏–∫—É
    if (metric.count % 100 === 0) {
      this.sendAnalytics(name, metric)
    }
  }
}
```

---

[‚Üê –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤](communication.md) | [–î–∞–ª–µ–µ: –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å ‚Üí](../03-features/README.md)