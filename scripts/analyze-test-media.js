#!/usr/bin/env node

import { exec } from 'child_process'
import { promisify } from 'util'
import { readdir, writeFile } from 'fs/promises'
import { join } from 'path'

const execAsync = promisify(exec)

const TEST_DATA_PATH = 'test-data'
const OUTPUT_FILE = 'src-tauri/src/media/test_data.rs'

async function getMediaInfo(filePath) {
  try {
    const { stdout } = await execAsync(
      `ffprobe -v quiet -print_format json -show_format -show_streams "${filePath}"`
    )
    return JSON.parse(stdout)
  } catch (error) {
    console.error(`Error analyzing ${filePath}:`, error.message)
    return null
  }
}

async function analyzeTestMedia() {
  console.log('üîç Analyzing test media files...\n')
  
  const files = await readdir(TEST_DATA_PATH)
  const mediaFiles = files.filter(f => 
    /\.(mp4|MP4|png|jpg|jpeg|wav|WAV|mp3)$/i.test(f)
  )
  
  const results = []
  
  for (const file of mediaFiles) {
    const filePath = join(TEST_DATA_PATH, file)
    console.log(`üìä Analyzing: ${file}`)
    
    const info = await getMediaInfo(filePath)
    if (!info) continue
    
    const format = info.format
    const videoStream = info.streams?.find(s => s.codec_type === 'video')
    const audioStream = info.streams?.find(s => s.codec_type === 'audio')
    
    const metadata = {
      filename: file,
      format_name: format.format_name,
      duration: parseFloat(format.duration || '0'),
      size: parseInt(format.size || '0'),
      bit_rate: parseInt(format.bit_rate || '0'),
      
      // Video properties
      has_video: !!videoStream,
      video_codec: videoStream?.codec_name,
      width: videoStream?.width,
      height: videoStream?.height,
      fps: videoStream?.r_frame_rate,
      video_bit_rate: parseInt(videoStream?.bit_rate || '0'),
      
      // Audio properties
      has_audio: !!audioStream,
      audio_codec: audioStream?.codec_name,
      sample_rate: parseInt(audioStream?.sample_rate || '0'),
      channels: audioStream?.channels,
      audio_bit_rate: parseInt(audioStream?.bit_rate || '0'),
      
      // Special properties
      is_360: file.includes('INSV') || (format.tags?.['spherical'] === 'true'),
      has_cyrillic: /[–∞-—è–ê-–Ø]/.test(file),
    }
    
    results.push(metadata)
    
    // Print summary
    console.log(`  Format: ${metadata.format_name}`)
    console.log(`  Duration: ${metadata.duration.toFixed(2)}s`)
    console.log(`  Size: ${(metadata.size / 1024 / 1024).toFixed(2)} MB`)
    
    if (metadata.has_video) {
      console.log(`  Video: ${metadata.width}x${metadata.height} @ ${metadata.fps} fps (${metadata.video_codec})`)
    }
    
    if (metadata.has_audio) {
      console.log(`  Audio: ${metadata.sample_rate}Hz ${metadata.channels}ch (${metadata.audio_codec})`)
    }
    
    console.log('')
  }
  
  // Generate Rust test data module
  await generateRustTestData(results)
  
  // Save JSON for reference
  try {
    await writeFile(
      'test-data/media-metadata.json',
      JSON.stringify(results, null, 2)
    )
  } catch (error) {
    console.warn('Warning: Could not save JSON metadata:', error.message)
  }
  
  console.log('‚úÖ Analysis complete!')
  console.log(`üìÑ Rust test data generated: ${OUTPUT_FILE}`)
  console.log(`üìÑ JSON metadata saved: test-data/media-metadata.json`)
}

async function generateRustTestData(metadata) {
  const rustCode = `// Auto-generated test data from real media files
// Generated by scripts/analyze-test-media.js

#[cfg(test)]
pub mod test_data {
    use std::path::PathBuf;
    
    #[derive(Debug, Clone)]
    pub struct TestMediaFile {
        pub filename: &'static str,
        pub path: PathBuf,
        pub format_name: &'static str,
        pub duration: f64,
        pub size: u64,
        pub bit_rate: u64,
        
        // Video properties
        pub has_video: bool,
        pub video_codec: Option<&'static str>,
        pub width: Option<u32>,
        pub height: Option<u32>,
        pub fps: Option<&'static str>,
        pub video_bit_rate: u64,
        
        // Audio properties
        pub has_audio: bool,
        pub audio_codec: Option<&'static str>,
        pub sample_rate: u32,
        pub channels: Option<u32>,
        pub audio_bit_rate: u64,
        
        // Special properties
        pub is_360: bool,
        pub has_cyrillic: bool,
    }
    
    impl TestMediaFile {
        pub fn get_path(&self) -> PathBuf {
            PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .parent()
                .unwrap()
                .join("test-data")
                .join(self.filename)
        }
    }
    
    lazy_static::lazy_static! {
        pub static ref TEST_FILES: Vec<TestMediaFile> = vec![
${metadata.map(m => `            TestMediaFile {
                filename: "${m.filename}",
                path: PathBuf::new(),
                format_name: "${m.format_name}",
                duration: ${m.duration.toFixed(1)},
                size: ${m.size},
                bit_rate: ${m.bit_rate},
                
                has_video: ${m.has_video},
                video_codec: ${m.video_codec ? `Some("${m.video_codec}")` : 'None'},
                width: ${m.width ? `Some(${m.width})` : 'None'},
                height: ${m.height ? `Some(${m.height})` : 'None'},
                fps: ${m.fps ? `Some("${m.fps}")` : 'None'},
                video_bit_rate: ${m.video_bit_rate},
                
                has_audio: ${m.has_audio},
                audio_codec: ${m.audio_codec ? `Some("${m.audio_codec}")` : 'None'},
                sample_rate: ${m.sample_rate},
                channels: ${m.channels ? `Some(${m.channels})` : 'None'},
                audio_bit_rate: ${m.audio_bit_rate},
                
                is_360: ${m.is_360},
                has_cyrillic: ${m.has_cyrillic},
            },`).join('\n')}
        ];
        
        pub static ref VIDEO_FILES: Vec<&'static TestMediaFile> = TEST_FILES
            .iter()
            .filter(|f| f.has_video)
            .collect();
            
        pub static ref AUDIO_FILES: Vec<&'static TestMediaFile> = TEST_FILES
            .iter()
            .filter(|f| f.has_audio && !f.has_video)
            .collect();
            
        pub static ref IMAGE_FILES: Vec<&'static TestMediaFile> = TEST_FILES
            .iter()
            .filter(|f| f.has_video && f.duration == 0.0)
            .collect();
    }
    
    // Helper functions for tests
    pub fn get_test_video() -> &'static TestMediaFile {
        VIDEO_FILES.first().expect("No test video files available")
    }
    
    pub fn get_test_audio() -> &'static TestMediaFile {
        AUDIO_FILES.first().expect("No test audio files available")
    }
    
    pub fn get_test_image() -> &'static TestMediaFile {
        IMAGE_FILES.first().expect("No test image files available")
    }
    
    pub fn get_file_with_cyrillic() -> Option<&'static TestMediaFile> {
        TEST_FILES.iter().find(|f| f.has_cyrillic)
    }
    
    pub fn get_largest_file() -> &'static TestMediaFile {
        TEST_FILES.iter().max_by_key(|f| f.size).unwrap()
    }
    
    pub fn get_longest_video() -> &'static TestMediaFile {
        VIDEO_FILES.iter().max_by(|a, b| {
            a.duration.partial_cmp(&b.duration).unwrap()
        }).unwrap()
    }
}

#[cfg(test)]
mod tests {
    use super::test_data::*;
    
    #[test]
    fn test_files_exist() {
        for file in TEST_FILES.iter() {
            let path = file.get_path();
            assert!(path.exists(), "Test file not found: {:?}", path);
        }
    }
    
    #[test]
    fn test_video_properties() {
        let video = get_test_video();
        assert!(video.has_video);
        assert!(video.width.is_some());
        assert!(video.height.is_some());
        assert!(video.duration > 0.0);
    }
    
    #[test]
    fn test_audio_properties() {
        let audio = get_test_audio();
        assert!(audio.has_audio);
        assert!(!audio.has_video);
        assert!(audio.sample_rate > 0);
    }
    
    #[test]
    fn test_cyrillic_filename() {
        if let Some(file) = get_file_with_cyrillic() {
            assert!(file.has_cyrillic);
            // Test that we can handle cyrillic filenames
            let path = file.get_path();
            assert!(path.to_string_lossy().contains(file.filename));
        }
    }
}
`
  
  await writeFile(OUTPUT_FILE, rustCode)
}

analyzeTestMedia().catch(console.error)