# План рефакторинга модуля app-state

## Текущие проблемы

### 1. Смешение ответственностей
- В `app-settings-machine.ts` смешаны:
  - Настройки пользователя (тема, язык, API ключи)
  - Управление проектами (текущий проект, недавние проекты)
  - Управление медиафайлами
  - Управление избранным
  - Состояние загрузки

### 2. Дублирование данных
- Медиафайлы хранятся и в настройках приложения, и в файлах проектов
- Избранное существует на уровне приложения и проекта без четкого разделения
- Нет ясности, где должны храниться определенные данные

### 3. Плохая изоляция
- Хуки тесно связаны с монолитным контекстом
- Прямые зависимости между различными типами контекста
- Сложно тестировать отдельные части

## Предлагаемая архитектура

### Разделение на домены

```
app-state/
├── user-preferences/          # Настройки пользователя
│   ├── services/
│   │   ├── preferences-machine.ts
│   │   └── preferences-service.ts
│   ├── hooks/
│   │   └── use-preferences.ts
│   └── types/
│       └── preferences.ts
│
├── project-manager/          # Управление проектами
│   ├── services/
│   │   ├── project-manager-machine.ts
│   │   ├── project-file-service.ts
│   │   └── recent-projects-service.ts
│   ├── hooks/
│   │   ├── use-current-project.ts
│   │   └── use-recent-projects.ts
│   └── types/
│       └── project-manager.ts
│
├── media-library/           # Глобальная медиабиблиотека
│   ├── services/
│   │   ├── media-library-machine.ts
│   │   └── media-library-service.ts
│   ├── hooks/
│   │   ├── use-media-files.ts
│   │   └── use-music-files.ts
│   └── types/
│       └── media-library.ts
│
└── favorites/              # Избранное на уровне приложения
    ├── services/
    │   ├── favorites-machine.ts
    │   └── favorites-service.ts
    ├── hooks/
    │   └── use-favorites.ts
    └── types/
        └── favorites.ts
```

### Четкое разделение ответственности

#### 1. User Preferences (Настройки пользователя)
- Тема интерфейса
- Язык
- API ключи
- Настройки интерфейса
- Горячие клавиши

#### 2. Project Manager (Менеджер проектов)
- Текущий открытый проект (путь, имя, isDirty)
- Список недавних проектов
- Операции создания/открытия/сохранения проектов
- НЕ содержит данные проекта (они в project-settings)

#### 3. Media Library (Медиабиблиотека)
- Глобальная библиотека медиафайлов
- Кеширование превью
- Поиск и фильтрация
- НЕ содержит проектные медиафайлы

#### 4. Favorites (Избранное)
- Избранные эффекты, фильтры, шаблоны на уровне приложения
- НЕ содержит проектное избранное

## План миграции

### Фаза 1: Подготовка (не ломаем существующий код)
1. Создать новые типы для каждого домена
2. Создать новые машины состояний для каждого домена
3. Написать тесты для новых компонентов

### Фаза 2: Миграция
1. Создать адаптеры для совместимости со старым API
2. Постепенно переносить функциональность в новые модули
3. Обновить хуки для использования новых сервисов

### Фаза 3: Очистка
1. Удалить старые компоненты
2. Обновить импорты по всему приложению
3. Удалить адаптеры совместимости

## Преимущества рефакторинга

1. **Улучшенная тестируемость** - каждый домен можно тестировать изолированно
2. **Четкие границы** - понятно, где какие данные должны храниться
3. **Лучшая производительность** - можно загружать только нужные части
4. **Упрощенная разработка** - легче добавлять новые функции
5. **Меньше багов** - изоляция уменьшает побочные эффекты

## Альтернатива: Минимальный рефакторинг

Если полный рефакторинг слишком рискованный, можно:

1. **Разделить только машину состояний**
   - Создать отдельные машины для каждого домена
   - Объединить их в корневой машине через параллельные состояния

2. **Улучшить типизацию**
   - Создать отдельные типы для каждого домена
   - Использовать дискриминированные объединения

3. **Создать фасадные хуки**
   - Оставить существующий API
   - Внутри использовать новую архитектуру

## Текущее покрытие тестами

```
app-state/
├── components: 97% (хорошо покрыто)
├── hooks: 36.61% (требует улучшения)
└── services: 61.88% (требует улучшения)
```

## Рекомендация

Учитывая, что приложение работает, рекомендую:

1. **Начать с минимального рефакторинга** - разделить машину состояний
2. **Улучшить покрытие тестами** - довести до 80%+
3. **Документировать границы** - четко описать, что где хранится
4. **Постепенно мигрировать** - по мере добавления новых функций

Полный рефакторинг имеет смысл делать, если:
- Планируется значительное расширение функциональности
- Есть проблемы с производительностью
- Сложно добавлять новые функции