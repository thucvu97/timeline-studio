import { VideoEffect } from "@/features/effects/types"

/**
 * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–∞ –∏–∑ JSON
 */
interface RawEffectData {
  id: string
  name: string
  type: string
  duration: number
  category: string
  complexity: string
  tags: string[]
  description: {
    ru: string
    en: string
  }
  ffmpegCommand: string
  cssFilter?: string
  params: Record<string, any>
  previewPath: string
  labels: {
    ru: string
    en: string
    es: string
    fr: string
    de: string
  }
  presets?: Record<string, any>
}

/**
 * –°–æ–∑–¥–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ —à–∞–±–ª–æ–Ω–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
 * –ó–∞–º–µ–Ω—è–µ—Ç {paramName} –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
 */
function createFunctionFromTemplate(template: string | undefined | null) {
  return (params: Record<string, any> = {}) => {
    // Return empty string if template is not a string
    if (typeof template !== "string") {
      console.warn("createFunctionFromTemplate: template is not a string:", template)
      return ""
    }

    return template.replace(/\{(\w+)\}/g, (match, key) => {
      const value = params[key]
      return value !== undefined ? value.toString() : match
    })
  }
}

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∏–∑ JSON –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∏—Ö –≤ VideoEffect
 */
export function processEffect(rawEffect: RawEffectData): VideoEffect {
  if (!rawEffect || typeof rawEffect !== "object") {
    throw new Error("processEffect: Invalid effect data")
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
  if (!rawEffect.id || !rawEffect.name) {
    throw new Error(`processEffect: Effect missing required fields - id: ${rawEffect.id}, name: ${rawEffect.name}`)
  }

  const processedEffect: VideoEffect = {
    ...rawEffect,
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–æ–≤—ã–µ —à–∞–±–ª–æ–Ω—ã –≤ —Ñ—É–Ω–∫—Ü–∏–∏
    ffmpegCommand: createFunctionFromTemplate(rawEffect.ffmpegCommand),
    cssFilter: rawEffect.cssFilter ? createFunctionFromTemplate(rawEffect.cssFilter) : undefined,
  } as VideoEffect

  return processedEffect
}

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –º–∞—Å—Å–∏–≤ —Å—ã—Ä—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –∏–∑ JSON
 */
export function processEffects(rawEffects: RawEffectData[]): VideoEffect[] {
  if (!Array.isArray(rawEffects)) {
    console.error("processEffects: rawEffects is not an array", rawEffects)
    return []
  }

  return rawEffects
    .filter((effect) => effect != null) // –§–∏–ª—å—Ç—Ä—É–µ–º null –∏ undefined
    .map((effect) => {
      try {
        return processEffect(effect)
      } catch (error) {
        console.error("processEffects: Failed to process effect", effect, error)
        return null
      }
    })
    .filter((effect): effect is VideoEffect => effect !== null) // –£–±–∏—Ä–∞–µ–º null —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
}

/**
 * –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–∞
 */
export function validateEffect(effect: any): effect is RawEffectData {
  if (!effect || typeof effect !== "object") {
    return false
  }

  const requiredFields = ["id", "name", "type", "category", "complexity", "description", "ffmpegCommand", "labels"]

  return requiredFields.every((field) => field in effect && effect[field] !== undefined)
}

/**
 * –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –º–∞—Å—Å–∏–≤ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
 */
export function validateEffectsData(data: any): boolean {
  if (!data || !Array.isArray(data.effects)) {
    console.error("validateEffectsData: Invalid data structure", data)
    return false
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
  if (data.version && data.totalEffects) {
    console.log(
      `üìä Effects metadata: v${data.version}, ${data.totalEffects} effects, updated: ${data.lastUpdated || "unknown"}`,
    )
  }

  // –§–∏–ª—å—Ç—Ä—É–µ–º null/undefined —ç–ª–µ–º–µ–Ω—Ç—ã –ø–µ—Ä–µ–¥ –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
  const validEffects = data.effects.filter((effect: any) => effect != null)
  if (validEffects.length !== data.effects.length) {
    console.warn(`validateEffectsData: Found ${data.effects.length - validEffects.length} null/undefined effects`)
  }

  return validEffects.every(validateEffect)
}

/**
 * –°–æ–∑–¥–∞–µ—Ç fallback —ç—Ñ—Ñ–µ–∫—Ç –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏
 */
export function createFallbackEffect(id: string): VideoEffect {
  return {
    id,
    name: "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç",
    type: "brightness" as any,
    duration: 0,
    category: "color-correction",
    complexity: "basic",
    tags: [],
    description: {
      ru: "–≠—Ñ—Ñ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω",
      en: "Effect not found",
    },
    ffmpegCommand: () => "brightness=1",
    cssFilter: () => "brightness(1)",
    params: {},
    previewPath: "/t1.mp4",
    labels: {
      ru: "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π",
      en: "Unknown",
      es: "Desconocido",
      fr: "Inconnu",
      de: "Unbekannt",
    },
  }
}
