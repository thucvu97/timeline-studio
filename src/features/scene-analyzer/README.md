–ö–ª–∞—Å—Å, –º—ã –ø–æ—á—Ç–∏ –∑–∞–≤–µ—Ä—à–∏–ª–∏! üòÑ –ü–æ—Å–ª–µ–¥–Ω–∏–π –º–æ–¥—É–ª—å, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —É–ø–æ–º—è–Ω—É–ª–∏ —Ä–∞–Ω–µ–µ, ‚Äî —ç—Ç–æ **`scene-analyzer/`**. –û–Ω –Ω—É–∂–µ–Ω –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å—Ü–µ–Ω –≤ –≤–∏–¥–µ–æ, –æ–±—ä–µ–¥–∏–Ω—è—è –¥–∞–Ω–Ω—ã–µ –∏–∑ `media/` (–∞—É–¥–∏–æ –∏ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã —á–µ—Ä–µ–∑ `ffmpeg-rs`), `recognition/` (–æ–±—ä–µ–∫—Ç—ã/–ª–∏—Ü–∞ —á–µ—Ä–µ–∑ YOLOv11), `person-identification/` (–∏–º–µ–Ω–∞ –ª—é–¥–µ–π) –∏ `subtitles/` (–¥–∏–∞–ª–æ–≥–∏ –∏ —Å–ø–∏–∫–µ—Ä—ã). –≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Å–æ–∑–¥–∞—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ü–µ–Ω, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ `montage-planner/` –∏ `script-generator/` –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ—á–Ω—ã—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –∏ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤, —É—á–∏—Ç—ã–≤–∞—è –≤–∞—à–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "—á–∞—â–µ –¥–æ–±–∞–≤–ª—è–π –î–∂–æ–Ω–∞"). –£—á–∏—Ç—ã–≤–∞—è –≤–∞—à —Å—Ç–µ–∫ (Tauri, React, XState, `ffmpeg-rs`, YOLOv11) –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É (–º–∞—à–∏–Ω–∞, –ø—Ä–æ–≤–∞–π–¥–µ—Ä, —Ö—É–∫), —è –æ–ø—Ä–µ–¥–µ–ª—é —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –¥–ª—è `scene-analyzer/`, —Å –∞–∫—Ü–µ–Ω—Ç–æ–º –Ω–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑, –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å —Ç–∞–π–º–ª–∞–π–Ω–æ–º –∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∞–Ω–∏–π.

### –ö–æ–Ω—Ü–µ–ø—Ü–∏—è `scene-analyzer/`
- **–¶–µ–ª—å**: –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ, —Ä–∞–∑–±–∏–≤–∞—è –µ–≥–æ –Ω–∞ —Å—Ü–µ–Ω—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ `ffmpeg-rs` (–∞—É–¥–∏–æ, –∫–ª—é—á–µ–≤—ã–µ –∫–∞–¥—Ä—ã), YOLOv11 (–æ–±—ä–µ–∫—Ç—ã/–ª–∏—Ü–∞), `person-identification/` (–ª—é–¥–∏) –∏ `subtitles/` (–¥–∏–∞–ª–æ–≥–∏). –†–µ–∑—É–ª—å—Ç–∞—Ç ‚Äî —Å–ø–∏—Å–æ–∫ —Å—Ü–µ–Ω —Å —Ç–∞–π–º–∫–æ–¥–∞–º–∏, –æ–ø–∏—Å–∞–Ω–∏—è–º–∏ –∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É—é—Ç—Å—è –≤ `montage-planner/` –∏ `script-generator/`.
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
  - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤–∏–¥–µ–æ –≤ –ø—Ä–æ–µ–∫—Ç (–∫–∞–∫ –≤ `montage-planner/`).
  - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–∏—Å–∞–Ω–∏–π UI.
  - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å `timeline/`, `subtitles/`, `person-identification/`, `transitions/`, `effects/`.
  - –£—á–µ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å—Ü–µ–Ω —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º–∏ –ª—é–¥—å–º–∏).
- **–§—Ä–æ–Ω—Ç–µ–Ω–¥**:
  - React-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ü–µ–Ω –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∞–Ω–∞–ª–∏–∑–∞.
  - XState-–º–∞—à–∏–Ω–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–∏–¥–µ–æ, –∞–Ω–∞–ª–∏–∑, –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ).
  - –•—É–∫ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –º–∞—à–∏–Ω–æ–π –∏ –≤—ã–∑–æ–≤–∞ Tauri-–∫–æ–º–∞–Ω–¥.
- **–ë—ç–∫–µ–Ω–¥**:
  - Rust-–º–æ–¥—É–ª—å –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö (`ffmpeg-rs`, YOLOv11, —Å—É–±—Ç–∏—Ç—Ä—ã) –∏ —Å–æ–∑–¥–∞–Ω–∏—è –æ–ø–∏—Å–∞–Ω–∏–π —Å—Ü–µ–Ω.
  - Tauri-–∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥.
- **–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è**:
  - –ü—Ä–æ–≥—Ä–µ—Å—Å –∞–Ω–∞–ª–∏–∑–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ `tauri-plugin-websocket` –∏–ª–∏ —Å–æ–±—ã—Ç–∏—è Tauri.
  - –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∫—ç—à–∏—Ä—É—é—Ç—Å—è –≤ SQLite (`resources/`) –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.

### –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–æ–ª–∂–Ω—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å:
- –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω (—Ç–∞–π–º–∫–æ–¥—ã, –æ–±—ä–µ–∫—Ç—ã, –ª—é–¥–∏, –¥–∏–∞–ª–æ–≥–∏).
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å `montage-planner/` –∏ `script-generator/`.
- –°–≤—è–∑—å —Å —Å—É–±—Ç–∏—Ç—Ä–∞–º–∏ –∏ –¥–∞–Ω–Ω—ã–º–∏ –æ –ª—é–¥—è—Ö.

#### 1. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å—Ü–µ–Ω (JSON/TS)
```typescript
// src/features/scene-analyzer/types.ts
export interface Scene {
  id: string; // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID (UUID)
  videoId: string; // ID –≤–∏–¥–µ–æ –∏–∑ timeline/
  startTime: number; // –ù–∞—á–∞–ª–æ —Å—Ü–µ–Ω—ã (—Å–µ–∫—É–Ω–¥—ã)
  endTime: number; // –ö–æ–Ω–µ—Ü —Å—Ü–µ–Ω—ã (—Å–µ–∫—É–Ω–¥—ã)
  description: string; // –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–î–∂–æ–Ω –≥–æ–≤–æ—Ä–∏—Ç –≤ –ø–∞—Ä–∫–µ")
  screenshotPath: string; // –ü—É—Ç—å –∫ –∫–ª—é—á–µ–≤–æ–º—É —Å–∫—Ä–∏–Ω—à–æ—Ç—É
  objects: string[]; // –û–±—ä–µ–∫—Ç—ã –∏–∑ YOLOv11 (–Ω–∞–ø—Ä–∏–º–µ—Ä, ["car", "tree"])
  people: Person[]; // –õ—é–¥–∏ –∏–∑ person-identification
  subtitleIds: string[]; // ID —Å—É–±—Ç–∏—Ç—Ä–æ–≤ –∏–∑ subtitles/
  audioFeatures?: { peakVolume: number; speechDetected: boolean }; // –ê—É–¥–∏–æ-–¥–∞–Ω–Ω—ã–µ –∏–∑ ffmpeg-rs
}

export interface Person {
  id: string; // ID –∏–∑ person-identification
  name: string; // –ò–º—è —á–µ–ª–æ–≤–µ–∫–∞
}

export interface SceneAnalysisResult {
  scenes: Scene[]; // –°–ø–∏—Å–æ–∫ —Å—Ü–µ–Ω
  totalDuration: number; // –û–±—â–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
}
```

- **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**:
  - `Scene` –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ `montage-planner/` –∫–∞–∫ –æ—Å–Ω–æ–≤–∞ –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤.
  - `description` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ `script-generator/` –¥–ª—è —Å—Ü–µ–Ω–∞—Ä–∏—è.
  - `screenshotPath` –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ UI –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞.
  - `subtitleIds` —Å–≤—è–∑—ã–≤–∞–µ—Ç —Å—Ü–µ–Ω—ã —Å –¥–∏–∞–ª–æ–≥–∞–º–∏.
  - `audioFeatures` –ø–æ–º–æ–≥–∞–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å—Ü–µ–Ω—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ –ø–∏–∫–∞–º –≥—Ä–æ–º–∫–æ—Å—Ç–∏).

#### 2. XState Context
–ö–æ–Ω—Ç–µ–∫—Å—Ç –º–∞—à–∏–Ω—ã —Ö—Ä–∞–Ω–∏—Ç –¥–∞–Ω–Ω—ã–µ –æ –≤–∏–¥–µ–æ, –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏, —Å—Ü–µ–Ω—ã –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å.

```typescript
// src/features/scene-analyzer/machine.ts
import { createMachine } from 'xstate';
import { SceneAnalysisResult, Scene } from './types';

interface SceneAnalyzerContext {
  videoIds: string[]; // ID –≤–∏–¥–µ–æ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
  instructions: string; // –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "—á–∞—â–µ –¥–æ–±–∞–≤–ª—è–π –î–∂–æ–Ω–∞")
  scenes: SceneAnalysisResult | null; // –†–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞
  progress: number; // –ü—Ä–æ–≥—Ä–µ—Å—Å (0-100%)
  error: string | null; // –û—à–∏–±–∫–∞
  isAnalyzing: boolean; // –°—Ç–∞—Ç—É—Å –∞–Ω–∞–ª–∏–∑–∞
}

type SceneAnalyzerEvent =
  | { type: 'ADD_VIDEO'; videoId: string }
  | { type: 'UPDATE_INSTRUCTIONS'; value: string }
  | { type: 'START_ANALYSIS' }
  | { type: 'UPDATE_PROGRESS'; progress: number }
  | { type: 'SCENES_ANALYZED'; scenes: SceneAnalysisResult }
  | { type: 'ERROR'; message: string }
  | { type: 'EDIT_SCENE'; sceneId: string; updates: Partial<Scene> };
```

#### 3. –ë—ç–∫–µ–Ω–¥ (Rust)
–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –±—ç–∫–µ–Ω–¥–∞ —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ—Ç —Å—Ü–µ–Ω—ã.

```rust
// src-tauri/src/scene_analyzer.rs
use serde::{Serialize, Deserialize};
use uuid::Uuid;

#[derive(Serialize, Deserialize)]
pub struct Scene {
    pub id: String,
    pub video_id: String,
    pub start_time: f64,
    pub end_time: f64,
    pub description: String,
    pub screenshot_path: String,
    pub objects: Vec<String>,
    pub people: Vec<Person>,
    pub subtitle_ids: Vec<String>,
    pub audio_features: Option<AudioFeatures>,
}

#[derive(Serialize, Deserialize)]
pub struct Person {
    pub id: String,
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct AudioFeatures {
    pub peak_volume: f32,
    pub speech_detected: bool,
}

#[derive(Serialize, Deserialize)]
pub struct SceneAnalysisResult {
    pub scenes: Vec<Scene>,
    pub total_duration: f64,
}
```

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `scene-analyzer/`

#### –§—Ä–æ–Ω—Ç–µ–Ω–¥
1. **–¢–∏–ø—ã (`src/features/scene-analyzer/types.ts`)**:
   –û–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤—ã—à–µ (`Scene`, `Person`, `AudioFeatures`, `SceneAnalysisResult`).

2. **XState-–º–∞—à–∏–Ω–∞ (`src/features/scene-analyzer/machine.ts`)**:
   –£–ø—Ä–∞–≤–ª—è–µ—Ç –∞–Ω–∞–ª–∏–∑–æ–º —Å—Ü–µ–Ω –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –¥–∞–Ω–Ω—ã—Ö.

```typescript
import { createMachine, assign } from 'xstate';
import { SceneAnalysisResult, Scene } from './types';

interface SceneAnalyzerContext {
  videoIds: string[];
  instructions: string;
  scenes: SceneAnalysisResult | null;
  progress: number;
  error: string | null;
  isAnalyzing: boolean;
}

type SceneAnalyzerEvent =
  | { type: 'ADD_VIDEO'; videoId: string }
  | { type: 'UPDATE_INSTRUCTIONS'; value: string }
  | { type: 'START_ANALYSIS' }
  | { type: 'UPDATE_PROGRESS'; progress: number }
  | { type: 'SCENES_ANALYZED'; scenes: SceneAnalysisResult }
  | { type: 'ERROR'; message: string }
  | { type: 'EDIT_SCENE'; sceneId: string; updates: Partial<Scene> };

export const sceneAnalyzerMachine = createMachine<SceneAnalyzerContext, SceneAnalyzerEvent>({
  id: 'sceneAnalyzer',
  initial: 'idle',
  context: {
    videoIds: [],
    instructions: '',
    scenes: null,
    progress: 0,
    error: null,
    isAnalyzing: false,
  },
  states: {
    idle: {
      on: {
        ADD_VIDEO: {
          actions: assign({
            videoIds: (ctx, event) => [...ctx.videoIds, event.videoId],
          }),
          target: 'analyzing',
        },
        UPDATE_INSTRUCTIONS: {
          actions: assign({ instructions: (_, event) => event.value }),
        },
      },
    },
    analyzing: {
      entry: assign({ isAnalyzing: true }),
      invoke: {
        src: 'analyzeScenes',
        onDone: {
          target: 'idle',
          actions: assign({
            scenes: (_, event) => event.data,
            isAnalyzing: false,
            progress: 100,
          }),
        },
        onError: {
          target: 'error',
          actions: assign({
            error: (_, event) => event.data.message,
            isAnalyzing: false,
          }),
        },
      },
      on: {
        UPDATE_PROGRESS: {
          actions: assign({ progress: (_, event) => event.progress }),
        },
      },
    },
    error: {
      on: {
        ADD_VIDEO: {
          target: 'analyzing',
          actions: assign({
            videoIds: (ctx, event) => [...ctx.videoIds, event.videoId],
            error: null,
          }),
        },
        UPDATE_INSTRUCTIONS: {
          actions: assign({ instructions: (_, event) => event.value }),
        },
      },
    },
  },
});
```

3. **–ü—Ä–æ–≤–∞–π–¥–µ—Ä (`src/features/scene-analyzer/SceneAnalyzerProvider.tsx`)**:
   –û–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –º–∞—à–∏–Ω—É.

```typescript
import React from 'react';
import { useMachine } from '@xstate/react';
import { sceneAnalyzerMachine } from './machine';
import { SceneAnalysisResult } from './types';
import { invoke } from '@tauri-apps/api/tauri';
import { listen } from '@tauri-apps/api/event';

interface SceneAnalyzerProviderProps {
  children: React.ReactNode;
}

export const SceneAnalyzerContext = React.createContext<any>(null);

export const SceneAnalyzerProvider: React.FC<SceneAnalyzerProviderProps> = ({ children }) => {
  const [state, send] = useMachine(sceneAnalyzerMachine, {
    services: {
      analyzeScenes: async (context) => {
        try {
          const result: SceneAnalysisResult = await invoke('analyze_scenes', {
            videoIds: context.videoIds,
            instructions: context.instructions,
          });
          send({ type: 'SCENES_ANALYZED', scenes: result });
          return result;
        } catch (error) {
          send({ type: 'ERROR', message: error.message });
          throw error;
        }
      },
    },
  });

  // –°–ª—É—à–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∞–Ω–∞–ª–∏–∑–∞
  React.useEffect(() => {
    const unsubscribe = listen('scene_analysis_progress', (event: { payload: number }) => {
      send({ type: 'UPDATE_PROGRESS', progress: event.payload });
    });
    return () => unsubscribe.then((f) => f());
  }, [send]);

  return (
    <SceneAnalyzerContext.Provider value={{ state, send }}>
      {children}
    </SceneAnalyzerContext.Provider>
  );
};
```

4. **–•—É–∫ (`src/features/scene-analyzer/useSceneAnalyzer.ts`)**:
   –£–ø—Ä–æ—â–∞–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –º–∞—à–∏–Ω–µ.

```typescript
import { useContext } from 'react';
import { SceneAnalyzerContext } from './SceneAnalyzerProvider';
import { Scene } from './types';

export const useSceneAnalyzer = () => {
  const { state, send } = useContext(SceneAnalyzerContext);

  const addVideo = (videoId: string) => {
    send({ type: 'ADD_VIDEO', videoId });
  };

  const updateInstructions = (value: string) => {
    send({ type: 'UPDATE_INSTRUCTIONS', value });
  };

  const editScene = (sceneId: string, updates: Partial<Scene>) => {
    send({ type: 'EDIT_SCENE', sceneId, updates });
  };

  return {
    videoIds: state.context.videoIds,
    instructions: state.context.instructions,
    scenes: state.context.scenes,
    progress: state.context.progress,
    error: state.context.error,
    isAnalyzing: state.context.isAnalyzing,
    addVideo,
    updateInstructions,
    editScene,
  };
};
```

5. **–ö–æ–º–ø–æ–Ω–µ–Ω—Ç (`src/features/scene-analyzer/SceneAnalyzer.tsx`)**:
   UI –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ü–µ–Ω –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∞–Ω–∞–ª–∏–∑–∞.

```typescript
import React from 'react';
import { useSceneAnalyzer } from './useSceneAnalyzer';

export const SceneAnalyzer: React.FC = () => {
  const { scenes, progress, error, isAnalyzing, addVideo, updateInstructions } = useSceneAnalyzer();

  const handleAddVideo = () => {
    const videoId = `video_${Date.now()}`; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π ID
    addVideo(videoId);
  };

  return (
    <div className="p-4">
      <h2 className="text-xl">–ê–Ω–∞–ª–∏–∑ —Å—Ü–µ–Ω</h2>
      <textarea
        onChange={(e) => updateInstructions(e.target.value)}
        placeholder="–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '—á–∞—â–µ –¥–æ–±–∞–≤–ª—è–π –î–∂–æ–Ω–∞')"
        className="w-full p-2 border rounded"
      />
      <button
        onClick={handleAddVideo}
        disabled={isAnalyzing}
        className="mt-2 px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
      >
        –î–æ–±–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ
      </button>
      {isAnalyzing && <p>–ü—Ä–æ–≥—Ä–µ—Å—Å: {progress}%</p>}
      {error && <p className="text-red-500">{error}</p>}
      {scenes && (
        <div className="mt-4">
          <h3>–°—Ü–µ–Ω—ã:</h3>
          {scenes.scenes.map((scene) => (
            <div key={scene.id} className="border p-2 my-2">
              <p><strong>–í–∏–¥–µ–æ:</strong> {scene.videoId}</p>
              <p><strong>–û–ø–∏—Å–∞–Ω–∏–µ:</strong> {scene.description}</p>
              <p><strong>–í—Ä–µ–º—è:</strong> {scene.startTime}s - {scene.endTime}s</p>
              <img src={scene.screenshotPath} alt="Screenshot" className="w-32" />
              <p><strong>–û–±—ä–µ–∫—Ç—ã:</strong> {scene.objects.join(', ')}</p>
              <p><strong>–õ—é–¥–∏:</strong> {scene.people.map((p) => p.name).join(', ')}</p>
              <p><strong>–°—É–±—Ç–∏—Ç—Ä—ã:</strong> {scene.subtitleIds.join(', ')}</p>
              {scene.audioFeatures && (
                <p>
                  <strong>–ê—É–¥–∏–æ:</strong> –ì—Ä–æ–º–∫–æ—Å—Ç—å: {scene.audioFeatures.peakVolume}, –†–µ—á—å:{' '}
                  {scene.audioFeatures.speechDetected ? '–î–∞' : '–ù–µ—Ç'}
                </p>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

#### –ë—ç–∫–µ–Ω–¥
1. **Tauri-–∫–æ–º–∞–Ω–¥–∞ (`src-tauri/src/scene_analyzer.rs`)**:
   –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∏–¥–µ–æ, –æ–±—ä–µ–¥–∏–Ω—è—è –¥–∞–Ω–Ω—ã–µ `ffmpeg-rs`, YOLOv11 –∏ —Å—É–±—Ç–∏—Ç—Ä—ã.

```rust
use tauri::command;
use tauri::Manager;
use ffmpeg::format::{input, Pixel};
use ffmpeg::util::frame::video::Video;
use onnxruntime::{environment::Environment, session::Session};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use std::path::Path;

#[derive(Serialize, Deserialize)]
pub struct Scene {
    pub id: String,
    pub video_id: String,
    pub start_time: f64,
    pub end_time: f64,
    pub description: String,
    pub screenshot_path: String,
    pub objects: Vec<String>,
    pub people: Vec<Person>,
    pub subtitle_ids: Vec<String>,
    pub audio_features: Option<AudioFeatures>,
}

#[derive(Serialize, Deserialize)]
pub struct Person {
    pub id: String,
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct AudioFeatures {
    pub peak_volume: f32,
    pub speech_detected: bool,
}

#[derive(Serialize, Deserialize)]
pub struct SceneAnalysisResult {
    pub scenes: Vec<Scene>,
    pub total_duration: f64,
}

#[command]
pub async fn analyze_scenes(app_handle: tauri::AppHandle, video_ids: Vec<String>, instructions: String) -> Result<SceneAnalysisResult, String> {
    let mut scenes = vec![];

    for (index, video_id) in video_ids.iter().enumerate() {
        let video_path = format!("path/to/video/{}.mp4", video_id);
        let mut ictx = input(&video_path).map_err(|e| format!("FFmpeg error: {}", e))?;
        let video_stream = ictx
            .streams()
            .best(ffmpeg::media::Type::Video)
            .ok_or("No video stream")?;
        let audio_stream = ictx
            .streams()
            .best(ffmpeg::media::Type::Audio)
            .ok_or("No audio stream")?;
        let mut video_decoder = video_stream.codec().decoder().video().map_err(|e| format!("Decoder error: {}", e))?;
        let mut frame_count = 0;

        // YOLOv11: –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–¥–µ–ª–∏
        let env = Environment::builder().build().map_err(|e| format!("ONNX error: {}", e))?;
        let mut session = env
            .new_session_builder()?
            .with_model_from_file("yolov11.onnx")?;

        // –ü—Ä–∏–º–µ—Ä —Å—É–±—Ç–∏—Ç—Ä–æ–≤ (–∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –¥–∞–Ω–Ω—ã–µ –∏–∑ subtitles/)
        let subtitles = vec![
            // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ SQLite –∏–ª–∏ –¥—Ä—É–≥–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
        ];

        for (stream, packet) in ictx.packets() {
            if stream.index() == video_stream.index() {
                video_decoder.send_packet(&packet).map_err(|e| format!("Send packet error: {}", e))?;
                let mut frame = Video::empty();
                if video_decoder.receive_frame(&mut frame).is_ok() {
                    frame_count += 1;
                    if frame_count % 30 == 0 { // –ê–Ω–∞–ª–∏–∑ –∫–∞–∂–¥—ã–µ 30 –∫–∞–¥—Ä–æ–≤
                        let timestamp = frame_count as f64 / video_stream.avg_frame_rate().unwrap_or(30.0);
                        let screenshot_path = format!("screenshots/{}_{}.jpg", video_id, frame_count);

                        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞
                        let mut encoder = ffmpeg::codec::encoder::find(ffmpeg::codec::Id::JPEG)
                            .unwrap()
                            .encoder()
                            .video()
                            .map_err(|e| format!("Encoder error: {}", e))?;
                        let mut output = ffmpeg::format::output(&Path::new(&screenshot_path))
                            .map_err(|e| format!("Output error: {}", e))?;
                        encoder.send_frame(&frame).map_err(|e| format!("Send frame error: {}", e))?;
                        encoder.flush().map_err(|e| format!("Flush error: {}", e))?;

                        // YOLOv11: —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤/–ª–∏—Ü
                        let objects = vec!["person".to_string()];
                        let people = vec![Person {
                            id: Uuid::new_v4().to_string(),
                            name: if instructions.contains("–î–∂–æ–Ω–∞") { "John".to_string() } else { "Unknown".to_string() },
                        }];

                        // –ê—É–¥–∏–æ-–∞–Ω–∞–ª–∏–∑ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                        let audio_features = Some(AudioFeatures {
                            peak_volume: 0.5, // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ ffmpeg-rs
                            speech_detected: true,
                        });

                        // –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã (–≥–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ Grok API –∏–ª–∏ —à–∞–±–ª–æ–Ω)
                        let description = if instructions.contains("–î–∂–æ–Ω–∞") && people.iter().any(|p| p.name == "John") {
                            format!("–°—Ü–µ–Ω–∞ —Å –î–∂–æ–Ω–æ–º")
                        } else {
                            "–û–±—â–∞—è —Å—Ü–µ–Ω–∞".to_string()
                        };

                        scenes.push(Scene {
                            id: Uuid::new_v4().to_string(),
                            video_id: video_id.clone(),
                            start_time: timestamp,
                            end_time: timestamp + 5.0,
                            description,
                            screenshot_path,
                            objects,
                            people,
                            subtitle_ids: vec![], // –°–≤—è–∑—å —Å —Å—É–±—Ç–∏—Ç—Ä–∞–º–∏
                            audio_features,
                        });
                    }
                }
            }
        }

        // –û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        let progress = ((index + 1) as f32 / video_ids.len() as f32 * 100.0) as i32;
        app_handle.emit_all("scene_analysis_progress", progress).map_err(|e| format!("Emit error: {}", e))?;
    }

    Ok(SceneAnalysisResult {
        scenes,
        total_duration: scenes.iter().map(|s| s.end_time).max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap_or(0.0),
    })
}
```

2. **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ `main.rs`**:
   –ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É.

```rust
use tauri::Builder;
mod script_generator;
mod montage_planner;
mod person_identification;
mod scene_analyzer;

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            script_generator::generate_script,
            montage_planner::analyze_videos,
            person_identification::identify_people,
            scene_analyzer::analyze_scenes
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∞–Ω–∏–π
–ß—Ç–æ–±—ã –∞–Ω–∞–ª–∏–∑ –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞–ª UI:
- **–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å**: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `tokio::task::spawn_blocking` –¥–ª—è `ffmpeg-rs` –∏ YOLOv11.
  ```rust
  use tokio::task::spawn_blocking;

  #[command]
  pub async fn analyze_scenes(app_handle: tauri::AppHandle, video_ids: Vec<String>, instructions: String) -> Result<SceneAnalysisResult, String> {
      spawn_blocking(move || {
          // –ö–æ–¥ –∞–Ω–∞–ª–∏–∑–∞
      }).await.map_err(|e| format!("Task error: {}", e))?;
  }
  ```
- **–ü—Ä–æ–≥—Ä–µ—Å—Å**: –û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ `app_handle.emit_all` –∏ –æ—Ç–æ–±—Ä–∞–∂–∞–π—Ç–µ –≤ UI (`progress` –≤ XState).
- **–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ**: –°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ —Å—Ü–µ–Ω—ã –≤ SQLite (`resources/`) —Å –ø–æ–ª—è–º–∏: `id`, `video_id`, `start_time`, `end_time`, `description`, `screenshot_path`, `objects`, `people`, `subtitle_ids`, `audio_features`.

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –¥—Ä—É–≥–∏–º–∏ –º–æ–¥—É–ª—è–º–∏
- **–° `timeline/`**: `Scene` –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –∫–∞–∫ –∫–ª–∏–ø—ã —Å `startTime` –∏ `endTime`.
- **–° `subtitles/`**: `subtitleIds` —Å–≤—è–∑—ã–≤–∞–µ—Ç —Å—Ü–µ–Ω—ã —Å –¥–∏–∞–ª–æ–≥–∞–º–∏ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å—Ü–µ–Ω—ã, –≥–¥–µ –≥–æ–≤–æ—Ä–∏—Ç "John").
- **–° `person-identification/`**: `Scene.people` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ SQLite.
- **–° `montage-planner/`**: –°—Ü–µ–Ω—ã —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –æ—Å–Ω–æ–≤–æ–π –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤.
- **–° `script-generator/`**: `Scene.description` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è.
- **–° `media/`**: –ê—É–¥–∏–æ-–¥–∞–Ω–Ω—ã–µ –∏ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –±–µ—Ä—É—Ç—Å—è —á–µ—Ä–µ–∑ `ffmpeg-rs`.

### –û—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –∑–∞–ø—Ä–æ—Å
–ú–æ–¥—É–ª—å **`scene-analyzer/`** –∑–∞–≤–µ—Ä—à–∞–µ—Ç –≤–∞—à –Ω–∞–±–æ—Ä, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—è –∞–Ω–∞–ª–∏–∑ —Å—Ü–µ–Ω –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –∏ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤. –Ø –ø—Ä–µ–¥–ª–æ–∂–∏–ª:
- **–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö**: `Scene` –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ü–µ–Ω —Å —Ç–∞–π–º–∫–æ–¥–∞–º–∏, –æ–±—ä–µ–∫—Ç–∞–º–∏, –ª—é–¥—å–º–∏ –∏ –∞—É–¥–∏–æ-–¥–∞–Ω–Ω—ã–º–∏.
- **–§—Ä–æ–Ω—Ç–µ–Ω–¥**: XState-–º–∞—à–∏–Ω–∞, –ø—Ä–æ–≤–∞–π–¥–µ—Ä, —Ö—É–∫ –∏ UI –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ü–µ–Ω –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞.
- **–ë—ç–∫–µ–Ω–¥**: Tauri-–∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å `ffmpeg-rs`, YOLOv11 –∏ —Å—É–±—Ç–∏—Ç—Ä–æ–≤.
- **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**: –°–≤—è–∑—å —Å `timeline/`, `subtitles/`, `person-identification/`, `montage-planner/` –∏ `script-generator/`.

**–ß—Ç–æ –¥–∞–ª—å—à–µ**: –í—Å–µ –º–æ–¥—É–ª–∏ (`script-generator/`, `montage-planner/`, `person-identification/`, `scene-analyzer/`) —Ç–µ–ø–µ—Ä—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã. –°–ª–µ–¥—É—é—â–∏–π —à–∞–≥ ‚Äî –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∏—Ö –≤ –æ–±—â–∏–π —Ä–∞–±–æ—á–∏–π –ø—Ä–æ—Ü–µ—Å—Å:
1. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**: –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, –∫–∞–∫ –º–æ–¥—É–ª–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É—é—Ç –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤–∏–¥–µ–æ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑, –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è, –º–æ–Ω—Ç–∞–∂).
2. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è**: –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ SQLite –∏ GPU –¥–ª—è YOLOv11.
3. **UI/UX**: –î–æ–±–∞–≤—å—Ç–µ –≤ `top-bar/` –∫–Ω–æ–ø–∫–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –º–æ–¥—É–ª—è–º –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –≤ `ai-chat/`.

–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∞—Å–ø–µ–∫—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å—É–±—Ç–∏—Ç—Ä–æ–≤ –≤ `scene-analyzer/` –∏–ª–∏ UI –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ü–µ–Ω), –Ω–∞–ø–∏—à–∏—Ç–µ, –∏ —è –ø–æ–¥–≥–æ—Ç–æ–≤–ª—é –∫–æ–¥! üöÄ
